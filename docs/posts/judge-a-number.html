<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/68b325cd48e1bda6f336.css" as="style"/><link rel="stylesheet" href="/_next/static/css/68b325cd48e1bda6f336.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8fa755d3830e88407993.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8fa755d3830e88407993.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d4ca226b082815b6b5f.js"></script><script src="/_next/static/chunks/webpack-61095c13c5984b221292.js" defer=""></script><script src="/_next/static/chunks/main-f388e32f9dd9c15fe4aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0306f4935296309b3a70.js" defer=""></script><script src="/_next/static/chunks/587-bc2ad70379c664eec3bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-c1b17b61179fd32e454b.js" defer=""></script><script src="/_next/static/ou0rr8MMJxdbORpj3pRfb/_buildManifest.js" defer=""></script><script src="/_next/static/ou0rr8MMJxdbORpj3pRfb/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="slug__Wrapper-sc-zxcg8a-0 RttbQ"><div class="header"><div><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8c-14.7 12.8-14.7 35.6 0 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"></path></svg></div><button class="Button__InsideButton-sc-19071w6-0 gYqsup">light</button></div><div class="slug__PostWrapper-sc-zxcg8a-1 fLQWSN"><div class="post"><h1>如何用正则表达式判断一个数是否是质数</h1>
<p>本文展示了一种判断一个数是否是质数的奇技淫巧，采用的是正则表达式方法。</p>
<p>太长不看</p>
<pre><code>function isPrime(n){
    return !(Array(n+1).join(1).match(/^1?$|^(11+?)\1+?$/))
}
</code></pre>
<p>原理解释
这个方法主要分为三步：</p>
<p>将待求数字转变为一元形式（unary form）;
检测这个数是一还是零；
检测这个数是否是很多个 1 组成；
我们分开来慢慢说：</p>
<p>Array(n+1).join(1)这是将数字转化为一个长度为待求 n+1 的数组。</p>
<p>在 ES6 下，也可以这么写："1".repeat(n);</p>
<p>接下来就是正则匹配的过程。/^1?$/匹配的是一个开头为 1，结尾也是 1 的数，数量为 1 个或者一个也没有。这就是第二步的作用。</p>
<p>/^(11+?)\1+$/ 这个正则匹配的是第三步，首先一个捕获组（/11+?/）匹配的是至少两个 11 为一组的情况，在 + 之后的 ? 表示这个匹配是非贪心的，要是没有这个？的话，这个捕获组就会匹配全部的字符串了。</p>
<p>再之后我们看一下\1+?，这会返回第一个匹配的位置，+?同样表示非贪心匹配。</p>
<p>总而言之，第三步是这样匹配的：当捕获组匹配到“11”时，同时会确定他的位置，接着正则表达式会匹配复数个”11”，如果匹配失败了（例如 n 是奇数的情况），那么匹配会返回之前的位置，并在括号里面加一个 1 来继续匹配，重复上面的动作。</p>
<p>这看起来就好像在使用多个数去整除输入的整数 n 一样。</p>
<p>如果匹配结果是 true，那么就说明这个数是 1）0 或 1；2）它会被整除，因此是合数，所以给返回值添加一个取反(!)。</p>
<p>ES6 的写法是这样的：</p>
<pre><code>function isPrime(n){
    const regex = /^1+?$|^(11+?)\1+?$/
    return !("1".repeat(n).match(regex))
}
</code></pre>
<p>其他
相信你也能看出来，这个方法非常的蛮。是的，一般来说判断一个数是否是质数的方法是这样的：</p>
<pre><code>function isPrime(n){
    const root = Math,sqrt(n)
    for(let i=0;i&#x3C;=root;i+=2){
        if(n%i===0){
            return false
        }
    }
    return true
}
</code></pre>
<p>时间复杂度是 O(n^0.5)，这个方法大概是 O(n);</p>
<p>此外，该方法受 String 长度的限制，大多数浏览器中，string 的最大长度小于 2.68 亿，所以不能判断诸如 1000000000000066600000000000001 是否是质数。（当然她是）</p>
<p>总的来说，这个方法也蛮有意思的。</p>
<p><a href="https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Fitnext.io%2Fa-wild-way-to-check-if-a-number-is-prime-using-a-regular-expression-4edfb725f895">原文链接</a></p>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"如何用正则表达式判断一个数是否是质数","date":"2020-10-08T12:44:58.817Z","slug":"judge-a-number","author":{"name":"Alfxjx","picture":"/assets/blog/authors/alfxjx.jpeg"},"content":"\u003ch1\u003e如何用正则表达式判断一个数是否是质数\u003c/h1\u003e\n\u003cp\u003e本文展示了一种判断一个数是否是质数的奇技淫巧，采用的是正则表达式方法。\u003c/p\u003e\n\u003cp\u003e太长不看\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPrime(n){\n    return !(Array(n+1).join(1).match(/^1?$|^(11+?)\\1+?$/))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原理解释\n这个方法主要分为三步：\u003c/p\u003e\n\u003cp\u003e将待求数字转变为一元形式（unary form）;\n检测这个数是一还是零；\n检测这个数是否是很多个 1 组成；\n我们分开来慢慢说：\u003c/p\u003e\n\u003cp\u003eArray(n+1).join(1)这是将数字转化为一个长度为待求 n+1 的数组。\u003c/p\u003e\n\u003cp\u003e在 ES6 下，也可以这么写：\"1\".repeat(n);\u003c/p\u003e\n\u003cp\u003e接下来就是正则匹配的过程。/^1?$/匹配的是一个开头为 1，结尾也是 1 的数，数量为 1 个或者一个也没有。这就是第二步的作用。\u003c/p\u003e\n\u003cp\u003e/^(11+?)\\1+$/ 这个正则匹配的是第三步，首先一个捕获组（/11+?/）匹配的是至少两个 11 为一组的情况，在 + 之后的 ? 表示这个匹配是非贪心的，要是没有这个？的话，这个捕获组就会匹配全部的字符串了。\u003c/p\u003e\n\u003cp\u003e再之后我们看一下\\1+?，这会返回第一个匹配的位置，+?同样表示非贪心匹配。\u003c/p\u003e\n\u003cp\u003e总而言之，第三步是这样匹配的：当捕获组匹配到“11”时，同时会确定他的位置，接着正则表达式会匹配复数个”11”，如果匹配失败了（例如 n 是奇数的情况），那么匹配会返回之前的位置，并在括号里面加一个 1 来继续匹配，重复上面的动作。\u003c/p\u003e\n\u003cp\u003e这看起来就好像在使用多个数去整除输入的整数 n 一样。\u003c/p\u003e\n\u003cp\u003e如果匹配结果是 true，那么就说明这个数是 1）0 或 1；2）它会被整除，因此是合数，所以给返回值添加一个取反(!)。\u003c/p\u003e\n\u003cp\u003eES6 的写法是这样的：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPrime(n){\n    const regex = /^1+?$|^(11+?)\\1+?$/\n    return !(\"1\".repeat(n).match(regex))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其他\n相信你也能看出来，这个方法非常的蛮。是的，一般来说判断一个数是否是质数的方法是这样的：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPrime(n){\n    const root = Math,sqrt(n)\n    for(let i=0;i\u0026#x3C;=root;i+=2){\n        if(n%i===0){\n            return false\n        }\n    }\n    return true\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e时间复杂度是 O(n^0.5)，这个方法大概是 O(n);\u003c/p\u003e\n\u003cp\u003e此外，该方法受 String 长度的限制，大多数浏览器中，string 的最大长度小于 2.68 亿，所以不能判断诸如 1000000000000066600000000000001 是否是质数。（当然她是）\u003c/p\u003e\n\u003cp\u003e总的来说，这个方法也蛮有意思的。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Fitnext.io%2Fa-wild-way-to-check-if-a-number-is-prime-using-a-regular-expression-4edfb725f895\"\u003e原文链接\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"judge-a-number"},"buildId":"ou0rr8MMJxdbORpj3pRfb","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>