<!DOCTYPE html><html><head><link rel="stylesheet" href="/style/index.css"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2649b9740f492fab27ec.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2649b9740f492fab27ec.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8fa755d3830e88407993.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8fa755d3830e88407993.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-fb76148cfcfb42ca18eb.js" defer=""></script><script src="/_next/static/chunks/framework-6c6eb080c4d41d8fd79b.js" defer=""></script><script src="/_next/static/chunks/main-4fc50673e5500481d568.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c9691b12b0ed909d1554.js" defer=""></script><script src="/_next/static/chunks/35-6549e75a8f594562e7e3.js" defer=""></script><script src="/_next/static/chunks/180-897780fff2e4dfc2b281.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-53ae0e5ed6860e2ab9aa.js" defer=""></script><script src="/_next/static/QvzCC1E_8zhBBH90haSTz/_buildManifest.js" defer=""></script><script src="/_next/static/QvzCC1E_8zhBBH90haSTz/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Post__Wrapper-sc-q8sq7-0 ikfRfU"><div class="ProgressBar__FixedTopWrapper-sc-1ufpd9c-0 ProgressBar__ProgressBarWrapperFixed-sc-1ufpd9c-1 lmAxqe fSwpDk"><div class="bar-used"></div></div><div class="header"><div class="icon-wrapper"><div class="icons"><svg class="arrow_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8c-14.7 12.8-14.7 35.6 0 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"></path></svg></div><div class="icons"><a href="/tech"><svg class="code_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="m541.141 268.864 61.718 16.939-132.395 482.474-61.717-16.938L541.14 268.864zm-212.138 29.803 44.885 45.61-175.36 172.587 175.04 167.573-44.267 46.23-222.634-213.163 222.336-218.837zm355.882 0 222.336 218.837-222.634 213.163-44.267-46.23 175.019-167.573L640 344.277l44.885-45.61z"></path></svg></a></div></div></div><div class="toggle"><button class="Button__InsideButton-sc-19071w6-0 cEJOXC"><div class="LightDarkSwitcher__Switcher-sc-hbms9j-0 irISBV"><svg class="sun_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M448 64v195.2a224.832 224.832 0 0 0-100.992 42.24L208.512 163.2l-45.248 45.312 138.24 138.496A218.624 218.624 0 0 0 259.008 448H64v64h195.008c5.504 37.76 20.48 72 42.496 100.992l-138.24 138.496 45.248 45.248L347.008 658.24C376 680 410.496 695.232 448 700.736V896h64V700.8a222.4 222.4 0 0 0 100.992-42.56l138.496 138.496 45.248-45.248L658.24 612.992A216.32 216.32 0 0 0 700.992 512H896v-64H700.992a216.32 216.32 0 0 0-42.752-100.992l138.496-138.496-45.248-45.248-138.496 138.24A224.832 224.832 0 0 0 512 259.2V64zm32 256c88.768 0 160 71.232 160 160s-71.232 160-160 160a159.488 159.488 0 0 1-160-160c0-88.768 71.232-160 160-160z"></path></svg></div></button></div><div style="height:3.25rem"></div><div class="Post-sc-1u8x57o-0 Post__PostWrapper-sc-q8sq7-1 bzjUit hPLIeh"><div class="info"><h1>On Axios Requests &amp; Wrapping</h1><div class="user"><img class="img" src="/assets/authors/alfxjx.jpg" alt="Alfxjx"/><span class="title">Alfxjx</span><div class="date">2022-02-22</div></div></div><div class="post"><h2>why axios？</h2>
<p>前后端交互最常见的就是 <code>http</code> 请求，为了提高效率，需要对 <code>http</code> 请求进行封装，目前的现代开发过程中，可以使用 Axios，一种对于 <code>http</code> 请求的封装，或者是<code>fetch</code>，全新的异步请求<code>api</code>，本文主要是介绍我们项目中是如何根据后端返回的类型，对请求进行封装。</p>
<p><a href="https://www.axios-http.cn/">Axios</a> 是一个基于 promise 的网络请求库，可以用于浏览器和 <code>node.js</code>。<code>api</code> 简单，返回一个 <code>Promise</code> 对象，以供异步的处理。
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a> 提供了一个 JavaScript 接口，用于访问和操纵 <code>HTTP</code> 管道的一些具体部分，例如请求和响应。它还提供了一个全局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">fetch()</a> 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。
事实上两种都可以，相信你看了这篇文章之后也可以自己封装一下 <code>fetch</code>，甚至可以使用适配器模式去一统两种 api。那下面就看看是怎么对 <code>axios</code> 进行封装的。</p>
<h2>Requests</h2>
<p>首先先看看实际生产中，<code>axios</code> 需要做什么工作:</p>
<h3>拦截器，错误处理</h3>
<p><code>axios</code> 在使用的过程中需要生成一个 <code>axiosBase</code> 实例，从开始发送请求到收到响应可以分成以下几个过程：</p>
<ol>
<li>发起请求 <code>axiosInstance.get()</code></li>
<li>进入请求拦截器 <code>axiosBase.interceptors.request.use(...requestIntercepter);</code></li>
<li>(server) 服务端进行响应</li>
<li>进入响应拦截器 <code>axiosBase.interceptors.response.use(responseIntercepter);</code></li>
<li>返回响应，在业务中进行使用。</li>
</ol>
<p>可以看出除了请求和响应之外，<code>axios</code> 提供的最多的配置就是请求拦截和响应拦截，程序设计的目的就是写出可维护并且能复用的代码，因此在两个拦截器中类似管道做通用的处理。</p>
<h3>请求和响应</h3>
<ol>
<li>业务中常见的有 <code>GET/POST/PUT</code> 请求，<code>post</code> 请求又会根据 <code>content-type</code> 分成两种，针对这些变化的量，锚定住代码中不变的量，需要进行设计。</li>
<li>在常见的业务中，可能会是使用 <code>access-token</code> 的方式进行鉴权，在请求的拦截器中，可以拿到 <code>config</code> 参数，可以添加认证信息</li>
<li>对于返回的响应报文，由于一般的返回报文是一样的，在响应拦截器中对响应进行第一步的通用处理，减少业务端的重复代码。</li>
</ol>
<h3>业务异常 VS Http 异常</h3>
<p>响应拦截中，最常见的就是对异常情况进行处理，由于 <code>axios</code> 返回的是一个 <code>Promise</code>对象，因此要对返回的结果进行处理判断，之后返回 <code>Promise.reject</code> / <code>Promise.resolve</code>; 对于 <code>http</code> 的异常来说，由于本身就是一个 error，一般会放在 <code>Promise.catch</code> 里面去处理。</p>
<h2>Wrapping</h2>
<h3>生成实例</h3>
<p>一般来说 baseURL 是不太会改变的,如果项目如果是比较稳定的话，可以把全局的设置也写上，如： <code>withCredentials</code></p>
<pre><code>axios.defaults.headers.post["Content-Type"] = "application/json";
axios.defaults.withCredentials = true;
const baseURL = NODE_ENV === "development" ? "/api" : VUE_APP_PROD_API;

// 基本的axios实例
const axiosBase = axios.create({
	baseURL: baseURL,
});
</code></pre>
<p>如果项目中依赖多个api，那么这里可以生成多个实例，配置不同的 baseURL (开发中需要配置对于的proxies).</p>
<pre><code>// next.js 之类的 jamstack，可以自己生成 api routes 的，具有不同的 backend
const axioRoutes = axios.create({
  baseURL: "/api-routes"
});
</code></pre>
<h3>拦截器</h3>
<p>拦截器的主要功能就是对请求和响应进行处理，包装，最常见的就是附带token进行鉴权的操作：</p>
<pre><code>axiosBase.interceptors.request.use((config: AxiosRequestConfig) => {
	const token = sessionStorage.getItem("token");
	if (token &#x26;&#x26; config.headers) {
		config.headers.Authorization = `Bearer ${token}`;
	}
	return config;
});
axiosBase.interceptors.response.use(
	(res: AxiosResponse&#x3C;IResponse&#x3C;any>>) => {
		if (!res) {
			return false;
		}
		if (Object.prototype.hasOwnProperty.call(res.data, "token")) {
			sessionStorage.setItem("token", res.data.token as string);
		}
		return res;
	},
	(err: AxiosError&#x3C;{ errorMessage: string; success: boolean }>) =>
		Promise.reject(err)
);

</code></pre>
<h2>处理异常</h2>
<p>请求一个很重复的操作就是处理异常，一般来说异常都很有规律性，可分成业务操作错误导致的业务异常和由于请求失败导致的HTTP异常。</p>
<h3>业务异常</h3>
<p><code>AxiosInstance</code> 会返回一个 <code>Promise</code>，对于业务异常都是在http returnCode 为200的时候。以 POST 请求为例子：</p>
<p>定义一个 标准的返回体：</p>
<pre><code>export interface IResponse&#x3C;T> {
	data: T;
	errorMessage: string;
	success: boolean;
	token?: string;
}
</code></pre>
<p>当返回success为false的时候，表示出现了业务异常。 由于是Promise.then，可以在拦截器里面进行处理，也可以在实例返回中进行处理，这个地方如果不同的请求方法处理方式不同，就放到对应请求的实例里面去处理，反之就存在拦截器就可以。一般来说不同的请求方式返回的应是一致的：</p>
<pre><code>axiosBase.interceptors.response.use(
	(res: AxiosResponse&#x3C;IResponse&#x3C;any>>) => {
		if (!res) {
			return false;
		}
    if (!res.data.success) {
			notify.warning(res.data.errorMessage);
		}
    // token...
	},
	(err: AxiosError&#x3C;{ errorMessage: string; success: boolean }>) =>
		Promise.reject(err)
);

</code></pre>
<h3>http error</h3>
<p>对于 http 的异常，为了能够在封装中对其进行统一处理，需要对实例返回的Promise进行二次封装，还是以POST请求为例：</p>
<pre><code>const httpFuncs = {
  post&#x3C;T>(
			url: string,
			data: any,
			config?: AxiosRequestConfig
		): Promise&#x3C;AxiosResponse&#x3C;IResponse&#x3C;T>>> {
			return new Promise((resolve, reject) => {
				axiosInstance
					.post(url, data, config)
					.then((res: AxiosResponse&#x3C;IResponse&#x3C;T>>) => resolve(res))
          // http error
					.catch((err: AxiosError&#x3C;IErrorProps>) => {
						notify.error(err.response?.data.errorMessage as string);
						if (
							err.response?.status === 401 &#x26;&#x26;
							isNoAuth(window.location.pathname)
						) {
							setTimeout(() => {
								window.location.href = "/person/login";
							}, 1000);
						}
						return reject(err);
					});
			});
		}
}
</code></pre>
<p>在 <code>Promise.catch</code>中，处理返回的http error， 主要是401 和其他的500错误，这样就无需在具体的业务中关心这些异常的处理了。</p>
<h2>More</h2>
<p>到此，基本就是完成了对 <code>axios</code> 等请求库的常规封装。</p>
<h3>设计模式？</h3>
<p>或许可以使用一个httpFactory来对http请求进行统一的管理，这样就不会在从mock升级到正式的情况都时候，要到每一个实例里面去修改了。</p>
<pre><code>enum enumType {
	BASE,
	MOCK
}

export class HttpFactory {
  public static getHttp(type:enumType){
    switch (type) {
      case enumType.BASE:
        return http
      case enumType.MOCK:
        return httpMock
      default:
        return http
    }
  }
}

</code></pre>
<p>使用的时候就直接使用 <code>HttpFactory.getHttp(enumType.MOCK).post&#x3C;IUserInfo>('/userinfo')</code>, 这样升级的时候，直接把枚举修改一下即可。</p>
<p>实际生产中，可以使用配置文件来写这个枚举，这样就可以做到统一的管理。</p>
<h2>End</h2>
<p><a href="">在线演示</a></p>
<p>总的来说最适合应用的才是最好的，本文只是介绍了我们在改造为 ts + axios  + next.js 时候的经验，事实上对于 next.js，可以使用 <a href="https://swr.vercel.app">useSWR</a> 等库，也进行了很好的封装。</p>
<h2>References</h2>
<ol>
<li><a href="https://segmentfault.com/a/1190000021071492">比较 fetch()和 Axios</a></li>
<li><a href="https://juejin.cn/post/6968630178163458084">完整的 Axios 封装-单独 API 管理层、参数序列化、取消重复请求、Loading、状态码...</a></li>
<li><a href="https://juejin.cn/post/7053471988752318472">封装 Axios 只看这一篇文章就行了</a></li>
<li><a href="https://juejin.cn/post/6969070102868131853#heading-4">错误处理 - 最后的完善</a></li>
<li><a href="https://segmentfault.com/a/1190000021769678">vue+ts下对axios的封装</a></li>
<li><a href="https://www.cnblogs.com/double-W/p/12875623.html">TS 泛型接口</a></li>
<li><a href="https://markdowner.net/article/153598623580815360">如何使用装饰器模式极大地增强fetch()</a></li>
</ol>
</div><div id="comments"></div></div><div class="Footer__FooterWrapper-sc-1ysspqt-0 llpwQT"><div class="my-main-font text"><span>Powerd by Next.js on gh-pages, </span><a href="/xujianxiang-resume.pdf">My Resume</a></div><div class="Footer__IconList-sc-1ysspqt-1 liWOyP"><a href="https://github.com/alfxjx"><svg class="github_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="32" height="32"><path d="M960 512c0 97.76-28.704 185.216-85.664 263.264-56.96 78.016-130.496 131.84-220.64 161.856-10.304 1.824-18.368.448-22.848-4.032a22.4 22.4 0 0 1-7.2-17.504v-122.88c0-37.632-10.304-65.44-30.464-82.912a409.856 409.856 0 0 0 59.616-10.368 222.752 222.752 0 0 0 54.72-22.816c18.848-10.784 34.528-23.36 47.104-38.592 12.544-15.232 22.848-35.904 30.912-61.44 8.096-25.568 12.128-54.688 12.128-87.904 0-47.072-15.232-86.976-46.208-120.16 14.368-35.456 13.024-74.912-4.48-118.848-10.752-3.616-26.432-1.344-47.072 6.272s-38.56 16.16-53.824 25.568l-21.984 13.888C587.776 285.088 550.56 280.16 512 280.16s-75.776 4.928-112.096 15.232a444.48 444.48 0 0 0-24.672-15.68c-10.336-6.272-26.464-13.888-48.896-22.432-21.952-8.96-39.008-11.232-50.24-8.064-17.024 43.936-18.368 83.424-4.032 118.848-30.496 33.632-46.176 73.536-46.176 120.608 0 33.216 4.032 62.336 12.128 87.456 8.032 25.12 18.368 45.76 30.496 61.44 12.544 15.68 28.224 28.704 47.072 39.04 18.848 10.304 37.216 17.92 54.72 22.816a409.6 409.6 0 0 0 59.648 10.368c-15.712 13.856-25.12 34.048-28.704 60.064a99.744 99.744 0 0 1-26.464 8.512 178.208 178.208 0 0 1-33.184 2.688c-13.024 0-25.568-4.032-38.144-12.544-12.544-8.512-23.296-20.64-32.256-36.32a97.472 97.472 0 0 0-28.256-30.496c-11.232-8.064-21.088-12.576-28.704-13.92l-11.648-1.792c-8.096 0-13.92.928-17.056 2.688-3.136 1.792-4.032 4.032-2.688 6.72s3.136 5.408 5.376 8.096 4.928 4.928 7.616 7.168l4.032 2.688c8.544 4.032 17.056 11.232 25.568 21.984 8.544 10.752 14.368 20.64 18.4 29.6l5.824 13.44c4.928 14.816 13.44 26.912 25.568 35.872 12.096 8.992 25.088 14.816 39.008 17.504 13.888 2.688 27.36 4.032 40.352 4.032s23.776-.448 32.288-2.24l13.472-2.24c0 14.784 0 32.288.416 52.032 0 19.744.48 30.496.48 31.392a22.624 22.624 0 0 1-7.648 17.472c-4.928 4.48-12.992 5.824-23.296 4.032-90.144-30.048-163.68-83.84-220.64-161.888C92.256 697.216 64 609.312 64 512c0-81.152 20.192-156.064 60.096-224.672s94.176-122.88 163.232-163.232C355.936 84.192 430.816 64 512 64s156.064 20.192 224.672 60.096 122.88 94.176 163.232 163.232C939.808 355.488 960 430.848 960 512"></path></svg></a><a href="https://weibo.com/u/1950371745"><svg class="weibo_svg__icon" viewBox="0 0 1026 1024" xmlns="http://www.w3.org/2000/svg" width="32.063" height="32"><path d="M0 61.5zM780 577c-11-2-18-5.5-21-9.5-3-4.5-4-8-1.5-12l3-5.5c.5-.5 1.5-2 2-3 .5-1.5 2-4.5 4.5-9 2-4.5 4-9.5 5-14s2-10.5 2.5-17 .5-13.5-.5-19.5-3-12.5-6.5-20c-3.5-7-7.5-13.5-13.5-19.5-10-10-23-16.5-39.5-19.5-16-3-32.5-3-48.5-.5s-31.5 5.5-45.5 9.5c-14.5 4-26 7.5-35.5 11.5l-14 6.5c-7 2-13 3.5-18 4.5-4.5.5-8.5.5-11-.5s-4.5-2-6-3-2-3.5-1.5-7.5.5-7.5 1-10c.5-3 1.5-7.5 2.5-13.5 1.5-6 2.5-11 3-14.5 0-8.5-.5-16.5-1.5-24s-3.5-16-7-25.5-9-17-15.5-22.5c-7-5.5-15.5-10.5-26-14s-24-4.5-40.5-3-35 5.5-56 13c-25 8.5-50.5 21.5-76.5 38-26 17-48 34.5-67 52.5-19 18.5-36.5 36-52 53.5-16 17-28 31-36.5 42l-12 17c-23.5 31-41 61.5-52.5 92.5s-17 54-16 70V723c4.5 34.5 15 65.5 31.5 92.5 17 27.5 37 49.5 60 66 23.5 17 51 31 82.5 43s62 20.5 91 26 59.5 9 92 11.5c53 4.5 108 0 165-12.5s110-34.5 159-65c49-31 84-68 104-111 12-25 18.5-49 19-71s-3.5-40.5-11.5-54.5-18-26.5-30.5-37c-12.5-11-24.5-18.5-35.5-23.5-10-6-20-9.5-28.5-10.5zM452 911.5c-77.5 3.5-143.5-11.5-197.5-45s-81-76.5-81-128c0-51 27-95 80.5-132s120-57 198-61S596 555 650 584s80.5 69.5 80.5 120.5c0 51.5-27.5 98-82.5 139.5s-120 64-196 67.5zm-31.5-298c-21 2-39.5 7-56 14.5S335 644 326 654c-9.5 9.5-17 20-23.5 31s-11 22-13.5 33-4 20.5-5 29.5c-.5 9-1 16-1 21l1 8.5v4.5c0 2 .5 6.5 2 13s3.5 12.5 6 18 6.5 11.5 12.5 18 12.5 12 20.5 16c47.5 23 91.5 30 132.5 21s74-29.5 99-62c10-12 16.5-27.5 20-45 3-18 2.5-36-2-54.5s-12.5-35-24-50-28.5-26.5-51-35c-23.5-9-49.5-11-79-7.5zM382 817c-4.5.5-8.5 1-12.5.5s-7.5-1-11-2-6.5-2.5-9.5-4-6-3.5-8-6l-6-7.5c-2-2.5-3-5.5-4.5-8.5s-1.5-6.5-1.5-10c0-8 2-15.5 6.5-23s10-14 18-19.5c7.5-5.5 16-8.5 25.5-9 6.5-.5 12.5-.5 19 .5 6 1 11.5 3 15.5 5.5 4.5 2.5 8 5.5 11.5 8.5 3 3 5.5 7 7 11.5s2 9 2 14c0 8-2.5 15.5-7 22.5S416 804 408 809c-8 4-16.5 7-26 8zm91.5-77.5c-5 3.5-10 5-15.5 5-5.5-.5-9-2.5-11.5-7l-2-4.5c-.5-1.5-1-3-1-4.5V724c0-2 .5-4 1-5.5l2-4.5c.5-1.5 2-2.5 3-3l3-4.5c5.5-4.5 11.5-6 16.5-5.5s9 3.5 11.5 8.5c2 3 3 6 2.5 9.5s-1.5 7-3 10c-1.5 4.5-4 7.5-6.5 10.5zm382-225c4.5 0 8.5-1 12-3s6.5-5 8.5-8 3.5-6.5 4.5-10c.5-.5 1-2 1-3 8.5-82-20-128.5-86-140-19.5-3.5-37.5-4-54-1-5 0-9.5 1.5-13 4s-6.5 5.5-9 9.5-4 8-4 12.5c0 7 2.5 13.5 7.5 18.5s11 7.5 18.5 7.5c56-13 86 5 90.5 54 1.5 12 .5 23.5-2 34.5 0 7 2.5 13.5 7.5 18.5 4.5 3.5 10.5 6 18 6zM837 211c-31.5-7-74-5.5-127 4.5-.5 0-1.5.5-2 1l-1 2-1 1c-8 2-14.5 6.5-19.5 13.5s-7.5 14-7.5 22c0 11 3.5 19.5 11 27 7 7 16 11 26 11h3c.5 0 2.5-.5 5-1s5-1.5 8-1.5c3-.5 6-1 9-2s6-2 8.5-3S757 284 764 284s16 .5 26.5 1.5 22 4 34.5 8c12.5 4.5 25 9.5 37.5 16s25 15.5 37.5 27 23.5 24.5 33 40c18.5 42.5 22.5 83 11 122.5 0 .5 0 1.5-.5 2s-1 2.5-1.5 5.5-1.5 5.5-2 8-1.5 5.5-2 9.5-1 7.5-1 10c0 6.5 2 12 5.5 16 3.5 4.5 8 7.5 13.5 9 5.5 2 11.5 2.5 19 2.5 20 0 32-12 35.5-36.5 8.5-28 13.5-54.5 14.5-80s-.5-48-5.5-67c-4.5-19.5-11.5-37.5-21-54.5s-20-31-32.5-43c-12-12-26-22.5-41-32.5-15-9.5-29.5-17.5-43.5-23-15-5.5-29.5-10.5-44.5-14z"></path></svg></a><a href="https://juejin.cn/user/2330620383728551"><svg class="juejin_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M832 739.533h57.958v30.105H587.571v-30.105h48.538l-31.54-184.525-.819-4.506 4.608-.716 21.095-3.482 4.505-.717.82 4.506 32.46 189.645h49.87V510.874H571.391v-30.106h145.613V381.44H619.93v-30.106h228.556v30.106H747.52v99.328h162.918v30.106H747.622v228.659h53.453l32.461-189.543.717-4.505 4.505.717 21.095 3.481 4.608.717-.82 4.506L832 739.533zm-428.032-9.728V582.45h74.854V423.22h-30.617v129.127h-44.237V413.798H373.35v138.548h-43.52V423.219h-30.617v159.232h74.137v147.354h-43.52V602.624h-30.617V759.91H478.72V602.624h-30.618v127.18h-44.134zM148.89 582.45l-21.607 21.197-3.174 3.174-3.175-3.174L105.78 588.8l-3.379-3.277 3.38-3.277 43.11-42.393V364.237h-37.684V334.13h37.684V254.26h30.617v79.872h44.135v30.106h-44.135v145.715l25.6-25.088 3.175-3.174 3.174 3.174 15.155 14.746 3.38 3.276-3.38 3.277-47.104 46.285v65.024c0 33.178-5.12 65.024-13.824 94.413-5.325 18.022-10.547 31.13-14.745 39.629l-4.71 9.42-2.049 3.994-4.096-1.946-19.251-9.113-4.198-2.048 2.048-4.199 4.608-9.42c.716-1.332 2.252-4.813 3.993-9.319 2.97-7.475 5.94-15.974 8.704-25.497 7.885-26.932 12.698-56.013 12.698-86.016V582.45zm97.792 180.122.921-4.506 2.15-10.24c12.8-61.645 17.511-195.584 16.999-358.605h220.672v-134.86H234.496l.102 4.71.205 10.65c.205 10.24.615 32.768.82 59.904.409 44.748.511 91.033.102 136.601-1.229 129.536-6.144 227.84-16.077 275.559l-2.15 10.24-.922 4.505 4.506.922 20.992 4.198 4.608.922zm19.865-403.456-1.024-74.65h191.181v74.65H266.547zm634.266 31.437 3.072-3.277 14.54-15.36 3.175-3.38-3.482-3.174-121.344-109.875-3.072-1.229h-126.77l-3.073 1.229-121.241 109.875-3.482 3.175 3.174 3.379 14.541 15.36 3.072 3.277 3.38-2.97 115.2-103.014h103.833l115.2 103.014 3.277 2.97z"></path></svg></a></div></div></div><div class="Toast__StyledContainer-sc-1p228qg-0 gWqgDn"><div class="Toastify"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"On Axios Requests \u0026 Wrapping","date":"2022-02-22T14:22:22.712Z","slug":"axios-wrapping","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"\u003ch2\u003ewhy axios？\u003c/h2\u003e\n\u003cp\u003e前后端交互最常见的就是 \u003ccode\u003ehttp\u003c/code\u003e 请求，为了提高效率，需要对 \u003ccode\u003ehttp\u003c/code\u003e 请求进行封装，目前的现代开发过程中，可以使用 Axios，一种对于 \u003ccode\u003ehttp\u003c/code\u003e 请求的封装，或者是\u003ccode\u003efetch\u003c/code\u003e，全新的异步请求\u003ccode\u003eapi\u003c/code\u003e，本文主要是介绍我们项目中是如何根据后端返回的类型，对请求进行封装。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.axios-http.cn/\"\u003eAxios\u003c/a\u003e 是一个基于 promise 的网络请求库，可以用于浏览器和 \u003ccode\u003enode.js\u003c/code\u003e。\u003ccode\u003eapi\u003c/code\u003e 简单，返回一个 \u003ccode\u003ePromise\u003c/code\u003e 对象，以供异步的处理。\n\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API\"\u003eFetch API\u003c/a\u003e 提供了一个 JavaScript 接口，用于访问和操纵 \u003ccode\u003eHTTP\u003c/code\u003e 管道的一些具体部分，例如请求和响应。它还提供了一个全局 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/fetch\"\u003efetch()\u003c/a\u003e 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。\n事实上两种都可以，相信你看了这篇文章之后也可以自己封装一下 \u003ccode\u003efetch\u003c/code\u003e，甚至可以使用适配器模式去一统两种 api。那下面就看看是怎么对 \u003ccode\u003eaxios\u003c/code\u003e 进行封装的。\u003c/p\u003e\n\u003ch2\u003eRequests\u003c/h2\u003e\n\u003cp\u003e首先先看看实际生产中，\u003ccode\u003eaxios\u003c/code\u003e 需要做什么工作:\u003c/p\u003e\n\u003ch3\u003e拦截器，错误处理\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eaxios\u003c/code\u003e 在使用的过程中需要生成一个 \u003ccode\u003eaxiosBase\u003c/code\u003e 实例，从开始发送请求到收到响应可以分成以下几个过程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e发起请求 \u003ccode\u003eaxiosInstance.get()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e进入请求拦截器 \u003ccode\u003eaxiosBase.interceptors.request.use(...requestIntercepter);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e(server) 服务端进行响应\u003c/li\u003e\n\u003cli\u003e进入响应拦截器 \u003ccode\u003eaxiosBase.interceptors.response.use(responseIntercepter);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e返回响应，在业务中进行使用。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看出除了请求和响应之外，\u003ccode\u003eaxios\u003c/code\u003e 提供的最多的配置就是请求拦截和响应拦截，程序设计的目的就是写出可维护并且能复用的代码，因此在两个拦截器中类似管道做通用的处理。\u003c/p\u003e\n\u003ch3\u003e请求和响应\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e业务中常见的有 \u003ccode\u003eGET/POST/PUT\u003c/code\u003e 请求，\u003ccode\u003epost\u003c/code\u003e 请求又会根据 \u003ccode\u003econtent-type\u003c/code\u003e 分成两种，针对这些变化的量，锚定住代码中不变的量，需要进行设计。\u003c/li\u003e\n\u003cli\u003e在常见的业务中，可能会是使用 \u003ccode\u003eaccess-token\u003c/code\u003e 的方式进行鉴权，在请求的拦截器中，可以拿到 \u003ccode\u003econfig\u003c/code\u003e 参数，可以添加认证信息\u003c/li\u003e\n\u003cli\u003e对于返回的响应报文，由于一般的返回报文是一样的，在响应拦截器中对响应进行第一步的通用处理，减少业务端的重复代码。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e业务异常 VS Http 异常\u003c/h3\u003e\n\u003cp\u003e响应拦截中，最常见的就是对异常情况进行处理，由于 \u003ccode\u003eaxios\u003c/code\u003e 返回的是一个 \u003ccode\u003ePromise\u003c/code\u003e对象，因此要对返回的结果进行处理判断，之后返回 \u003ccode\u003ePromise.reject\u003c/code\u003e / \u003ccode\u003ePromise.resolve\u003c/code\u003e; 对于 \u003ccode\u003ehttp\u003c/code\u003e 的异常来说，由于本身就是一个 error，一般会放在 \u003ccode\u003ePromise.catch\u003c/code\u003e 里面去处理。\u003c/p\u003e\n\u003ch2\u003eWrapping\u003c/h2\u003e\n\u003ch3\u003e生成实例\u003c/h3\u003e\n\u003cp\u003e一般来说 baseURL 是不太会改变的,如果项目如果是比较稳定的话，可以把全局的设置也写上，如： \u003ccode\u003ewithCredentials\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaxios.defaults.headers.post[\"Content-Type\"] = \"application/json\";\naxios.defaults.withCredentials = true;\nconst baseURL = NODE_ENV === \"development\" ? \"/api\" : VUE_APP_PROD_API;\n\n// 基本的axios实例\nconst axiosBase = axios.create({\n\tbaseURL: baseURL,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果项目中依赖多个api，那么这里可以生成多个实例，配置不同的 baseURL (开发中需要配置对于的proxies).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// next.js 之类的 jamstack，可以自己生成 api routes 的，具有不同的 backend\nconst axioRoutes = axios.create({\n  baseURL: \"/api-routes\"\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e拦截器\u003c/h3\u003e\n\u003cp\u003e拦截器的主要功能就是对请求和响应进行处理，包装，最常见的就是附带token进行鉴权的操作：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaxiosBase.interceptors.request.use((config: AxiosRequestConfig) =\u003e {\n\tconst token = sessionStorage.getItem(\"token\");\n\tif (token \u0026#x26;\u0026#x26; config.headers) {\n\t\tconfig.headers.Authorization = `Bearer ${token}`;\n\t}\n\treturn config;\n});\naxiosBase.interceptors.response.use(\n\t(res: AxiosResponse\u0026#x3C;IResponse\u0026#x3C;any\u003e\u003e) =\u003e {\n\t\tif (!res) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Object.prototype.hasOwnProperty.call(res.data, \"token\")) {\n\t\t\tsessionStorage.setItem(\"token\", res.data.token as string);\n\t\t}\n\t\treturn res;\n\t},\n\t(err: AxiosError\u0026#x3C;{ errorMessage: string; success: boolean }\u003e) =\u003e\n\t\tPromise.reject(err)\n);\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e处理异常\u003c/h2\u003e\n\u003cp\u003e请求一个很重复的操作就是处理异常，一般来说异常都很有规律性，可分成业务操作错误导致的业务异常和由于请求失败导致的HTTP异常。\u003c/p\u003e\n\u003ch3\u003e业务异常\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eAxiosInstance\u003c/code\u003e 会返回一个 \u003ccode\u003ePromise\u003c/code\u003e，对于业务异常都是在http returnCode 为200的时候。以 POST 请求为例子：\u003c/p\u003e\n\u003cp\u003e定义一个 标准的返回体：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport interface IResponse\u0026#x3C;T\u003e {\n\tdata: T;\n\terrorMessage: string;\n\tsuccess: boolean;\n\ttoken?: string;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当返回success为false的时候，表示出现了业务异常。 由于是Promise.then，可以在拦截器里面进行处理，也可以在实例返回中进行处理，这个地方如果不同的请求方法处理方式不同，就放到对应请求的实例里面去处理，反之就存在拦截器就可以。一般来说不同的请求方式返回的应是一致的：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaxiosBase.interceptors.response.use(\n\t(res: AxiosResponse\u0026#x3C;IResponse\u0026#x3C;any\u003e\u003e) =\u003e {\n\t\tif (!res) {\n\t\t\treturn false;\n\t\t}\n    if (!res.data.success) {\n\t\t\tnotify.warning(res.data.errorMessage);\n\t\t}\n    // token...\n\t},\n\t(err: AxiosError\u0026#x3C;{ errorMessage: string; success: boolean }\u003e) =\u003e\n\t\tPromise.reject(err)\n);\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ehttp error\u003c/h3\u003e\n\u003cp\u003e对于 http 的异常，为了能够在封装中对其进行统一处理，需要对实例返回的Promise进行二次封装，还是以POST请求为例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst httpFuncs = {\n  post\u0026#x3C;T\u003e(\n\t\t\turl: string,\n\t\t\tdata: any,\n\t\t\tconfig?: AxiosRequestConfig\n\t\t): Promise\u0026#x3C;AxiosResponse\u0026#x3C;IResponse\u0026#x3C;T\u003e\u003e\u003e {\n\t\t\treturn new Promise((resolve, reject) =\u003e {\n\t\t\t\taxiosInstance\n\t\t\t\t\t.post(url, data, config)\n\t\t\t\t\t.then((res: AxiosResponse\u0026#x3C;IResponse\u0026#x3C;T\u003e\u003e) =\u003e resolve(res))\n          // http error\n\t\t\t\t\t.catch((err: AxiosError\u0026#x3C;IErrorProps\u003e) =\u003e {\n\t\t\t\t\t\tnotify.error(err.response?.data.errorMessage as string);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terr.response?.status === 401 \u0026#x26;\u0026#x26;\n\t\t\t\t\t\t\tisNoAuth(window.location.pathname)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsetTimeout(() =\u003e {\n\t\t\t\t\t\t\t\twindow.location.href = \"/person/login\";\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003ePromise.catch\u003c/code\u003e中，处理返回的http error， 主要是401 和其他的500错误，这样就无需在具体的业务中关心这些异常的处理了。\u003c/p\u003e\n\u003ch2\u003eMore\u003c/h2\u003e\n\u003cp\u003e到此，基本就是完成了对 \u003ccode\u003eaxios\u003c/code\u003e 等请求库的常规封装。\u003c/p\u003e\n\u003ch3\u003e设计模式？\u003c/h3\u003e\n\u003cp\u003e或许可以使用一个httpFactory来对http请求进行统一的管理，这样就不会在从mock升级到正式的情况都时候，要到每一个实例里面去修改了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eenum enumType {\n\tBASE,\n\tMOCK\n}\n\nexport class HttpFactory {\n  public static getHttp(type:enumType){\n    switch (type) {\n      case enumType.BASE:\n        return http\n      case enumType.MOCK:\n        return httpMock\n      default:\n        return http\n    }\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用的时候就直接使用 \u003ccode\u003eHttpFactory.getHttp(enumType.MOCK).post\u0026#x3C;IUserInfo\u003e('/userinfo')\u003c/code\u003e, 这样升级的时候，直接把枚举修改一下即可。\u003c/p\u003e\n\u003cp\u003e实际生产中，可以使用配置文件来写这个枚举，这样就可以做到统一的管理。\u003c/p\u003e\n\u003ch2\u003eEnd\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"\"\u003e在线演示\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e总的来说最适合应用的才是最好的，本文只是介绍了我们在改造为 ts + axios  + next.js 时候的经验，事实上对于 next.js，可以使用 \u003ca href=\"https://swr.vercel.app\"\u003euseSWR\u003c/a\u003e 等库，也进行了很好的封装。\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://segmentfault.com/a/1190000021071492\"\u003e比较 fetch()和 Axios\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6968630178163458084\"\u003e完整的 Axios 封装-单独 API 管理层、参数序列化、取消重复请求、Loading、状态码...\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7053471988752318472\"\u003e封装 Axios 只看这一篇文章就行了\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6969070102868131853#heading-4\"\u003e错误处理 - 最后的完善\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://segmentfault.com/a/1190000021769678\"\u003evue+ts下对axios的封装\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/double-W/p/12875623.html\"\u003eTS 泛型接口\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://markdowner.net/article/153598623580815360\"\u003e如何使用装饰器模式极大地增强fetch()\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n","coverImage":"/assets/blog/axios.jpg"}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"axios-wrapping"},"buildId":"QvzCC1E_8zhBBH90haSTz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>