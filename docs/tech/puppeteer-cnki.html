<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="/style/index.css"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&amp;display=swap"/><script async="" defer="" data-website-id="3890bdd6-8ff5-4da5-8b72-45ba24876897" src="https://umami-alfxjx.up.railway.app/umami.js"></script><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2649b9740f492fab27ec.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2649b9740f492fab27ec.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8fa755d3830e88407993.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8fa755d3830e88407993.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-fb76148cfcfb42ca18eb.js" defer=""></script><script src="/_next/static/chunks/framework-6c6eb080c4d41d8fd79b.js" defer=""></script><script src="/_next/static/chunks/main-4fc50673e5500481d568.js" defer=""></script><script src="/_next/static/chunks/pages/_app-075949e5fa5ffddc911e.js" defer=""></script><script src="/_next/static/chunks/252f366e-b63e9f131b12ce609c69.js" defer=""></script><script src="/_next/static/chunks/1bfc9850-b8804bb07d4f86914404.js" defer=""></script><script src="/_next/static/chunks/0c428ae2-eb29eaaad2b07bc95110.js" defer=""></script><script src="/_next/static/chunks/1a48c3c1-63272919e4bbaae4097e.js" defer=""></script><script src="/_next/static/chunks/608-bb5bf9a1b1d10ad22ac0.js" defer=""></script><script src="/_next/static/chunks/553-f50d93340fc41d40714e.js" defer=""></script><script src="/_next/static/chunks/307-d4f637d0181fb2085729.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-6a6947d46afa43b14f3e.js" defer=""></script><script src="/_next/static/Q5-ARss9H4OnstBP8NDja/_buildManifest.js" defer=""></script><script src="/_next/static/Q5-ARss9H4OnstBP8NDja/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap">@font-face{font-family:'Poppins';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiEyp8kv8JHgFVrFJM.woff) format('woff')}@font-face{font-family:'Poppins';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiByp8kv8JHgFVrLGT9V1g.woff) format('woff')}@font-face{font-family:'Poppins';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiEyp8kv8JHgFVrJJbecnFHGPezSQ.woff2) format('woff2');unicode-range:U+0900-097F,U+1CD0-1CF6,U+1CF8-1CF9,U+200C-200D,U+20A8,U+20B9,U+25CC,U+A830-A839,U+A8E0-A8FB}@font-face{font-family:'Poppins';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiEyp8kv8JHgFVrJJnecnFHGPezSQ.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Poppins';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Poppins';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiByp8kv8JHgFVrLGT9Z11lFd2JQEl8qw.woff2) format('woff2');unicode-range:U+0900-097F,U+1CD0-1CF6,U+1CF8-1CF9,U+200C-200D,U+20A8,U+20B9,U+25CC,U+A830-A839,U+A8E0-A8FB}@font-face{font-family:'Poppins';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiByp8kv8JHgFVrLGT9Z1JlFd2JQEl8qw.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Poppins';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/poppins/v20/pxiByp8kv8JHgFVrLGT9Z1xlFd2JQEk.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="Post__Wrapper-sc-q8sq7-0 dzXARM"><div class="ProgressBar__FixedTopWrapper-sc-1ufpd9c-0 ProgressBar__ProgressBarWrapperFixed-sc-1ufpd9c-1 lmAxqe ketkUq"><div class="bar-used"></div></div><div class="header"><div class="icon-wrapper"><div class="icons"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M21 11H6.414l5.293-5.293-1.414-1.414L2.586 12l7.707 7.707 1.414-1.414L6.414 13H21z"></path></svg></div><div class="icons"><a href="/tech"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m7.375 16.781 1.25-1.562L4.601 12l4.024-3.219-1.25-1.562-5 4a1 1 0 0 0 0 1.562l5 4zm9.25-9.562-1.25 1.562L19.399 12l-4.024 3.219 1.25 1.562 5-4a1 1 0 0 0 0-1.562l-5-4zm-1.649-4.003-4 18-1.953-.434 4-18z"></path></svg></a></div></div></div><div class="toggle"><button class="switch__SwitchWrapper-sc-19ps08m-0 eMIOez"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></svg><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278zM4.858 1.311A7.269 7.269 0 0 0 1.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.316 7.316 0 0 0 5.205-2.162c-.337.042-.68.063-1.029.063-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286z"></path></svg><div class="round"></div></button></div><div style="height:3.25rem"></div><div class="Post-sc-1u8x57o-0 Post__PostWrapper-sc-q8sq7-1 hcSpXI fqyuhB"><div class="info"><h1>[Puppeteer]我是如何做到写EXCEL时速3k行的</h1><div class="user"><img class="img" src="/assets/authors/alfxjx.jpg" alt="Alfxjx"/><span class="title">Alfxjx</span><div class="date">2020-05-04</div></div></div><div class="post"><h2>起因</h2>
<p>之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目</p>
<p>统计某某期刊的信息。</p>
<p>粗粗看了一下14个人的群里，有我这样延毕的~~老狗~~ 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法：</p>
<p><strong>CODING</strong>!!!</p>
<h2>开干吧</h2>
<p>首先确定技术栈，因为主攻前端不懂就问，所以选择node作为主要的开发语言，加之要做的是统计文章的信息，稍微想了一下，这个需求不就是~~爬虫~~CV嘛。</p>
<p><code>puppeteer</code>是<code>nodejs</code>中一个很好用的自动化工具，都不能说他是爬虫，因为他广泛应用于自动化测试中，可以看看<a href="https://zhuanlan.zhihu.com/p/76237595">这篇文章</a>。</p>
<p>借鉴一下我朋友的<a href="http://www.weidongwei.com/blog/15?title=puppeteer%E7%88%AC%E7%9F%A5%E4%B9%8E">这个文章</a>，首先：</p>
<pre><code>npm i -S puppeteer
</code></pre>
<p>这里因为一下众所周知的原因，下载<code>Chromium</code>可能有点费劲，我这边之前玩<code>puppeteer</code>的时候就装好了，看官可以自行解决一下（搬瓦工啥的）；</p>
<p><code>puppeteer</code> 作为一个自动化测试的库，其实就是自己在操作<code>Chrome</code>浏览器在进行一下指令，所以使用这个编写的代码我觉得还是很直观的。</p>
<h2>观察需求</h2>
<ul>
<li>获取2014-2015年焊接学报的所有学术文章的标题，作者与单位，起止页码，摘要关键词等信息</li>
<li>作者需要按行分开，作者和单位需要对应上</li>
<li>在上面的基础上，其他行需要合并。
<img src="https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480345-841eca98-9523-4f7b-a31c-8c0d14bf5202.png#align=left&#x26;display=inline&#x26;height=779&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=779&#x26;originWidth=1440&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1440" alt="">
<a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&#x26;pykm=HJXB&#x26;Year=&#x26;Issue=&#x26;Entry=">文章列表页</a>
<img src="https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480374-000ad5f3-f718-4157-875d-9c4fd4f2134e.png#align=left&#x26;display=inline&#x26;height=737&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=737&#x26;originWidth=1440&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1440" alt="">
<a href="http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=HJXB201401001&#x26;dbname=CJFD2014&#x26;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhMFE3R2FlMkI4akFIS1N4bGlEUUZtWT0%3D%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">单个文章的示例</a></li>
</ul>
<h2>解决方案</h2>
<ul>
<li>入口是CNKI的期刊文章列表页，基于ASPX生成。</li>
<li>在文章列表页，就可以得到一部分信息</li>
<li>摘要，关键词需要进入对应的文章页面去获取</li>
<li>作者和单位的对应需要进入pdf查看**（未完成）**</li>
<li>完成抓取之后再将数据导出成excel</li>
</ul>
<blockquote>
<p>可以看出，信息呈现三层形式保存。</p>
</blockquote>
<h2>爬取所有的首层信息</h2>
<p>首先一些准备工作，引入包和规定的格式：</p>
<pre><code>const puppeteer = require('puppeteer');
const url = 'https://navi.cnki.net/knavi/JournalDetail?pcode=CJFD&#x26;pykm=HJXB';
// 统一设定一个等待时间，防止操作太快被目标认出来
const TIME = 3000;
</code></pre>
<p>接下来就是主函数：</p>
<pre><code>// 一个立即执行的异步函数
(async () => {
    const browser = await puppeteer.launch({
		// headless: false, // false浏览器界面启动
		slowMo: 100, // 放慢浏览器执行速度，方便测试观察
		args: [
			// 启动 Chrome 的参数
			'–no-sandbox',
			// '--window-size=1280,960',
		],
	});
    // 创建新页面
    const page = await browser.newPage();
    // 这一句就是前往目标页面
    await page.goto(url, {
		// 网络空闲说明已加载完毕
		waitUntil: 'networkidle2',
	});
	console.log('page加载完成！');
})()
</code></pre>
<p>经过上面的描述可以看出，<code>puppeteer</code>和<code>Electron</code>等有点类似，都是主进程中创建子进程进行操作。</p>
<p>接着就是在列表页选择对应的年份和期数，并且循环执行。</p>
<p><code>puppeteer</code>意为<strong>提线木偶</strong>，所以想让浏览器做什么就发出对应的指令即可：</p>
<p>首先是用到的两个<code>util</code>函数：</p>
<pre><code>// 因为网页上年份的按钮的id是数字开头，直接S()会出错
// 所以需要把它转换成Unicode
function getID(year) {
	let num = year - 2010;
	return `#\\0032\\0030\\0031\\003${num}\\005f\\0059\\0065\\0061\\0072\\005f\\0049\\0073\\0073\\0075\\0065`;
}

// 选择某一年某一期的id
function getNoDotID(year, num) {
	let _num = num &#x3C; 10 ? `0${num}` : `${num}`;
	return `#yq${year}${_num}`;
}
</code></pre>
<p>接下来：</p>
<pre><code>// 选择2014年，对每一期进行点击
// 年份点击事件
let yearNum = 2014;
const yearBtn = await page.$(getID(yearNum));
await yearBtn.click();
await page.waitFor(TIME);
let accNum = 1;
// 输出的结果，是一个二维数组。
let output = [];
// 从第一期开始，一个月一期
while (accNum &#x3C; 13) {
    // 循环选择第几期
    let NoDot = await page.$(getNoDotID(yearNum, accNum));
    NoDot.click();

    // 保存所有的信息
    await page.waitFor(TIME);

    console.log('选择列表...' + accNum);
    const list = await page.$('#CataLogContent');
    const items = await list.?('dd');

    const res = await page.evaluate(list => {
        // ...
    }, list);
    output.push(res);
    accNum++;
}
</code></pre>
<ul>
<li><code>page.$(), page.?()</code>类似于<code>document.querySelector/querySelectorAll</code>，返回一个节点元素</li>
<li><code>page.evaluate(function,node)</code> 是对上面选择到的对应的node节点进行浏览器内操作的方法，在function中实现。，function接受node作为参数。</li>
</ul>
<p>在<code>page.evaluate</code>的内部，我们将文章的信息（标题，起止页码等）以及链接提取出来保存起来。</p>
<pre><code>const res = await page.evaluate(list => {
    // 在这里就可以使用browser的对象啦
    const itemList = list.querySelectorAll('dd');
    let arr = [];
    // console.log(itemList);
    for (let item of itemList) {
        // 这里是发现cnki是基于aspx的网页
        // 并且跳转到对应的页面是有规律的，和filename之后的id有关
        // 另外，不同的年份有不同的数据库
        const getPaperId = function(id) {
            let match = /filename=(\w+)&#x26;/i.exec(id);
            return match[1];
        }
        let paperID = item.querySelector('.opts > .btn-view >a').href;
        let id = getPaperId(paperID);
        // 最后将2014年某一条的innerText和id保存成一个字符串，留着之后解析
        let content = item.innerText + '&#x26;' +id;
        arr.push(content);
    }
    return arr;
}, list);
</code></pre>
<p>这样运行一下<code>npm start</code>，得到的数据就log出来了。目前我就是直接复制了一下，当然也有其他的办法。</p>
<p>最终得到的<code>data.txt</code>:</p>
<pre><code>[
    ["5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\n樊丁;蒋锴;余淑荣;张健;\n1-4+113&#x26;HJXB201401001","铝合金超声-MIG焊接电弧行为\n范成磊;谢伟峰;杨春利;寇毅;\n5-8+113&#x26;HJXB201401002",...],
     ...
 ]
</code></pre>
<h2>爬取摘要，关键词等信息</h2>
<p>目前是有了部分信息，但是摘要和关键词还需要在第二层里面获取;</p>
<h3>对数据进行一些预处理</h3>
<p><code>npm run analysis</code></p>
<p>这一部分就是对上面得到的list进行处理，首先把2维数组拍平：</p>
<pre><code>const out2014S = require('./output2014');
const out2015S = require('./output2015');
const fs = require('fs');

// 获取引用
let out2014 = out2014S;
let out2015 = out2015S;
// flat
while (out2014.some(Array.isArray)) {
	out2014 = [].concat(...out2014);
}

while (out2015.some(Array.isArray)) {
	out2015 = [].concat(...out2015);
}
</code></pre>
<p>目前得到的数据示例如下：</p>
<pre><code>"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\n樊丁;蒋锴;余淑荣;张健;\n1-4+113&#x26;HJXB201401001",
    ...

</code></pre>
<p>需要对这个进行分析，自定义一个split函数：</p>
<pre><code>function SecondeSplit(arr, year) {
    // 数据序列化一下，保存下\n用于分割
	let str = JSON.stringify(arr);
	console.log('str' + str);
	let nArr = str.split('\\n');
	console.log('nArr' + nArr);
	// 0 title
	// 1 string authors
	// 2 pages and link
	let res = {};
    // clean
	res.title = nArr[0].replace(/\"/i, '');
	let names = nArr[1].split(';');
	res.name = names.slice(0, names.length - 1);
    // 存在有的文章没有页码和链接等问题
	if (nArr[2]) {
		let linkArr = nArr[2].split('&#x26;');
        // clean
		let link = linkArr[1].replace(/\"/i, '');
        // 两年的dbname稍有不同
		if (year === 2014) {
			res.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=${link}&#x26;dbname=CJFD2014`;
		}
		if (year === 2015) {
			res.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=${link}&#x26;dbname=CJFDLAST2015`;
		}
		let pages = linkArr[0].split('+');
		let pageArr = pages[0].split('-');
		res.start = pageArr[0];
		res.end = pageArr[1];
	}
	return res;
}

// 对两年的数据进行操作
let ret2014 = [];
out2014.forEach(i => {
	let tmp = SecondeSplit(i, 2014);
	ret2014.push(tmp);
});
// ... 2015一样

let ret = ret2014.concat(ret2015);

let jsonObj = {};
jsonObj.data = ret;
// \t能够保存一个比较美观的json
let wObj = JSON.stringify(jsonObj, '', '\t');
fs.writeFile('data.json', wObj, err => {
	console.log(err);
});

</code></pre>
<h3>爬取摘要等</h3>
<p><code>npm run abstract</code></p>
<p>这里的主要思路就是继续操作<code>puppeteer</code>，对每一个链接，获取对应摘要，学校和关键词信息</p>
<p>这里的<code>puppeteer</code>并没有用基于<code>async</code>的写法，用<code>then</code>也很方便。</p>
<pre><code>const obj = require('../data1.json');
const fs = require('fs');
const puppeteer = require('puppeteer');
// 因为要对obj操作
let data = obj;
const len = data.data.length;
puppeteer
	.launch({
		headless: true,
	})
	.then(async browser => {
		for (let i = 0; i &#x3C; len; i++) {
			if (data.data[i].link) {
				const res = await getAbstract(i, data.data[i].link, browser);
                // 这里就用keyword来判断是否抓取成功了
				console.log(i + ': ' + res.keywords);
				data.data[i].abstract = res.abstract;
				data.data[i].school = res.school;
				data.data[i].keywords = res.keywords;
			}
		}
	})
	.then(() => {
		console.log('获取信息完成！');
		// console.log(data.data[0].abstract);
    	// 保存到data1.json
		save(data);
	});

</code></pre>
<p><code>getAbstract</code>是一个获取摘要的函数，需要传browser实例，链接和序号：</p>
<pre><code>async function getAbstract(num, link, browser) {
	const page = await browser.newPage();
	await page.goto(link);
	await page.waitFor(3000);
    // 摘要
	let abs = await page.$('#ChDivSummary');
	let abstract = await page.evaluate(abs => {
		return abs.innerText;
	}, abs);
    // 学校
	let schoolDOM = await page.$('.orgn');
	let school = await page.evaluate(schoolDOM => {
		let arr = schoolDOM.querySelectorAll('span > a');
		let res = '';
		arr.forEach(i => {
			res += i.text + ',';
		});
        // 拼接为字符串后就删掉最后一个逗号
		return res.slice(0, res.length - 1);
	}, schoolDOM);
    // 关键词
	let keysDOM = await page.$('#catalog_KEYWORD');
	let keys = await page.evaluate(keysDOM => {
    // let arr = keysDOM.querySelectorAll('p')[2].querySelectorAll('a');
    // 上面的写法并不好，因为有的挂了基金有的没挂，所以不一定是第三个
    // 发现关键词里面一个dom是有id的
    // 所以选用了兄弟节点的方法。
    let arr = keysDOM.parentNode.children;
    let res = '';
    for(let j=1;j&#x3C;arr.length;j++){
      res += arr[j].text.replace(/ /g, '').replace(/\n/g, '');
    }
		return res;
	}, keysDOM);
	await page.waitFor(3000);
    // 节省内存，每次查询完就关闭页面
	await page.close();
	return {
		abstract: abstract,
		school: school,
		keywords: keys,
	};
}

</code></pre>
<p>这样就得到了完整的数据：</p>
<pre><code>{
	"data": [
		{
			"title": "5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性",
			"name": [
				"樊丁",
				"蒋锴",
				"余淑荣",
				"张健"
			],
			"link": "http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=HJXB201401001&#x26;dbname=CJFD2014",
			"start": "1",
			"end": "4",
			"abstract": "以5052铝合金和热镀锌ST04Z钢为研究对象,采用预置涂粉CO2激光搭接熔钎焊方法进行工艺试验.利用光学显微镜、扫描电镜和拉伸试验机对熔钎焊接头的微观组织和力学性能进行了研究.结果表明,涂助溶剂和粉末后,焊缝成形明显改善,镀锌层没有烧损;熔—钎焊接头过渡层最大厚度小于10μm,针状Al-Fe金属间化合物没有向熔化的铝侧明显析出;接头具有较高的力学性能,最大机械抗载能力可达到208 MPa,约为5052铝合金母材抗拉强度的95.41%. ",
			"school": "兰州理工大学甘肃省有色金属新材料省部共建国家重点实验室,兰州理工大学有色金属合金及加工教育部重点实验室",
			"keywords": "铝钢;激光焊接;熔钎焊;粉末;"
		},
        ...
    ]
}

</code></pre>
<h2>将数据导出到EXCEL</h2>
<p>这里就是将数据导出啦，需求里面写的还是很明白的：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480515-8d1e0e12-02a0-40ca-90ca-173fbd56336f.png#align=left&#x26;display=inline&#x26;height=362&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=362&#x26;originWidth=1492&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1492" alt=""></p>
<p>我的想法就是根据每一个item的作者list的长度，首先是写出若干行，然后再将除了作者和单位之外的行进行合并。</p>
<pre><code>const Excel = require('exceljs');
const data = require('../data1.json');

// 数据预处理
let input = [];
let obj = data.data;
obj.forEach((item, index) => {
	let len = item.name.length;

	let link = item.link;
	let reg = /HJXB201(4|5)([0-9]{2})/i;

	let year = -1;
	let juan = -1;
	let vol = -1;
	if (link) {
		year = link.substring(link.length - 4, link.length);
        // 2014年是35卷，2015=36卷
		juan = year == 2014 ? 35 : 36;
        // 期数在链接里面就可以查出，是第二个匹配项
		vol = reg.exec(link)[2];
	}

	for (let i = 0; i &#x3C; len; i++) {
        // 将数据整理成exceljs需要的样子
		input.push({
			index: index + 1,
			title: item.title,
			name: item.name[i],
			lang: '中文',
			school: item.school,
			abstract: item.abstract,
			year: year,
			juan: juan,
			vol: vol,
			keyType: '关键词',
			paperName: '焊接学报',
			keywords: item.keywords,
			start: item.start,
			end: item.end,
		});
	}
});

</code></pre>
<p>接着使用exceljs来创建工作表：</p>
<pre><code>// excel处理
let workbook = new Excel.Workbook();

workbook.creator = 'xujx';

let sheet = workbook.addWorksheet('sheet 1');

sheet.columns = [
	{ header: '序号', key: 'index', width: 10 },
	{ header: '唯一标识类型', key: 'onlykey', width: 10 },
	{ header: '唯一标识', key: 'onlyid', width: 10 },
	{ header: '题名', key: 'title', width: 15 },
	{ header: '正文语种', key: 'lang', width: 10 },
	{ header: '责任者/责任者姓名', key: 'name', width: 15 },
	{ header: '责任者/责任者机构/责任机构名称', key: 'school', width: 15 },
	{ header: '摘要', key: 'abstract', width: 15 },
	{ header: '主题/主题元素类型', key: 'keyType', width: 15 },
	{ header: '主题/主题名称', key: 'keywords', width: 15 },
	{ header: '期刊名称', key: 'paperName', width: 15 },
	{ header: '出版年', key: 'year', width: 15 },
	{ header: '规范期刊URI', key: 'URI', width: 15 },
	{ header: '卷', key: 'juan', width: 15 },
	{ header: '期', key: 'vol', width: 15 },
	{ header: '起始页码', key: 'start', width: 15 },
	{ header: '结束页码', key: 'end', width: 15 },
	{ header: '收录信息/收录类别代码', key: 'typeCode', width: 15 },
];

sheet.addRows(input);

</code></pre>
<p>在这之后就合并单元格：</p>
<pre><code>// 合并单元格
// 首先获取每一项的作者个数，保存在一个array中
let nameLength = [];
obj.forEach(item => {
	if (item.name.length) {
		nameLength.push(item.name.length);
	} else {
		nameLength.push(0);
	}
});

</code></pre>
<p>合并单元格从第二行开始（第一行是表头）：</p>
<pre><code>for (let j = 0; j &#x3C; ret.length; j += 2) {
	sheet.mergeCells(`A${ret[j]}:A${ret[j + 1]}`);
	sheet.mergeCells(`B${ret[j]}:B${ret[j + 1]}`);
	sheet.mergeCells(`C${ret[j]}:C${ret[j + 1]}`);
	sheet.mergeCells(`D${ret[j]}:D${ret[j + 1]}`);
	sheet.mergeCells(`E${ret[j]}:E${ret[j + 1]}`);
	sheet.mergeCells(`H${ret[j]}:H${ret[j + 1]}`);
	sheet.mergeCells(`I${ret[j]}:I${ret[j + 1]}`);
	sheet.mergeCells(`J${ret[j]}:J${ret[j + 1]}`);
	sheet.mergeCells(`K${ret[j]}:K${ret[j + 1]}`);
	sheet.mergeCells(`L${ret[j]}:L${ret[j + 1]}`);
	sheet.mergeCells(`M${ret[j]}:M${ret[j + 1]}`);
	sheet.mergeCells(`N${ret[j]}:N${ret[j + 1]}`);
	sheet.mergeCells(`O${ret[j]}:O${ret[j + 1]}`);
	sheet.mergeCells(`P${ret[j]}:P${ret[j + 1]}`);
	sheet.mergeCells(`Q${ret[j]}:Q${ret[j + 1]}`);
	sheet.mergeCells(`R${ret[j]}:R${ret[j + 1]}`);
}

workbook.xlsx.writeFile('1.xlsx').then(function() {
	// done
	console.log('done');
});

</code></pre>
<p>上面的数组<code>ret</code>是这样得到的，它保存了合并单元格的起止位置。</p>
<pre><code>let ret = [];
// 是从第2行开始
ret.push(2);
// 对于每一个作者长度
for (let i = 0; i &#x3C; nameLength.length; i++) {
    // 表示尾部的那个节点的位置
	let head = ret[ret.length - 1];
    // 目前数组长度为偶数，说明现在是成对的，因此需要把尾部节点的下一个数加入数组
	if (ret.length % 2 === 0) {
		ret.push(head + 1);
        // 同时，由于这一循环并没有用到nameLength数组，所以不算做循环++
    	i--;
	} else {
        // 如果是奇数，说明需要添加一个步长，来合并单元格
        // 所以需要一个作者个数-1的步长
    	ret.push(head + nameLength[i] - 1);
	}
}

</code></pre>
<p>这样就完成了99%了！</p>
<h3>未完成的部分</h3>
<ul>
<li>但是需求里面还说需要作者和作者的单位对应，这就需要把文章下载下来分析了。</li>
<li>我目前的尝试是<code>pdf2json</code>，不过并不成功，时间紧迫就开启人工智能模式 ——手动搞了一下</li>
<li>确实有点累。</li>
</ul>
<h2>源码地址</h2>
<p><a href="https://github.com/Alfxjx/CNKI-HJXB-Crawler">Github 求个star吧555</a></p>
<p><a href="https://juejin.cn/post/6844904083921305614">原文地址</a></p>
</div><div id="comments"></div></div><div class="Footer__FooterWrapper-sc-1ysspqt-0 bPlNKY"><div class="my-main-font text"><span>Powerd by <a href="https://nextjs.org">Next.js</a> on<!-- --> <a href="https://vercel.com">Vercel</a> with ♥ 2020-<!-- -->2022</span></div><div class="Footer__IconList-sc-1ysspqt-1 fShAcK"><a href="https://github.com/alfxjx"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/alfxjx"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="https://weibo.com/u/1950371745"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg"><path d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7 0 395.3 0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"></path></svg></a><a href="https://juejin.cn/user/2330620383728551"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg"><path d="M11.445 21.832a1 1 0 0 0 1.11 0l9-6A.998.998 0 0 0 21.8 14.4l-9-12c-.377-.504-1.223-.504-1.6 0l-9 12a1 1 0 0 0 .245 1.432l9 6zM13 19.131V6l6.565 8.754L13 19.131zM11 6v13.131l-6.565-4.377L11 6z"></path></svg></a><a href="https://umami-alfxjx.up.railway.app/share/eaSooCGG/Blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 384 512" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg"><path d="M181.9 256.1c-5-16-4.9-46.9-2-46.9 8.4 0 7.6 36.9 2 46.9zm-1.7 47.2c-7.7 20.2-17.3 43.3-28.4 62.7 18.3-7 39-17.2 62.9-21.9-12.7-9.6-24.9-23.4-34.5-40.8zM86.1 428.1c0 .8 13.2-5.4 34.9-40.2-6.7 6.3-29.1 24.5-34.9 40.2zM248 160h136v328c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V24C0 10.7 10.7 0 24 0h200v136c0 13.2 10.8 24 24 24zm-8 171.8c-20-12.2-33.3-29-42.7-53.8 4.5-18.5 11.6-46.6 6.2-64.2-4.7-29.4-42.4-26.5-47.8-6.8-5 18.3-.4 44.1 8.1 77-11.6 27.6-28.7 64.6-40.8 85.8-.1 0-.1.1-.2.1-27.1 13.9-73.6 44.5-54.5 68 5.6 6.9 16 10 21.5 10 17.9 0 35.7-18 61.1-61.8 25.8-8.5 54.1-19.1 79-23.2 21.7 11.8 47.1 19.5 64 19.5 29.2 0 31.2-32 19.7-43.4-13.9-13.6-54.3-9.7-73.6-7.2zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-74.1 255.3c4.1-2.7-2.5-11.9-42.8-9 37.1 15.8 42.8 9 42.8 9z"></path></svg></a><a href="/xujianxiang-resume.pdf"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" d="M0 0h24v24H0z"></path><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-5h2v5zm4 0h-2v-3h2v3zm0-5h-2v-2h2v2zm4 5h-2V7h2v10z"></path></svg></a></div></div></div><div class="Toast__StyledContainer-sc-1p228qg-0 gWqgDn"><div class="Toastify"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"[Puppeteer]我是如何做到写EXCEL时速3k行的","date":"2020-05-03T16:35:07.322Z","slug":"puppeteer-cnki","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"\u003ch2\u003e起因\u003c/h2\u003e\n\u003cp\u003e之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目\u003c/p\u003e\n\u003cp\u003e统计某某期刊的信息。\u003c/p\u003e\n\u003cp\u003e粗粗看了一下14个人的群里，有我这样延毕的~~老狗~~ 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCODING\u003c/strong\u003e!!!\u003c/p\u003e\n\u003ch2\u003e开干吧\u003c/h2\u003e\n\u003cp\u003e首先确定技术栈，因为主攻前端不懂就问，所以选择node作为主要的开发语言，加之要做的是统计文章的信息，稍微想了一下，这个需求不就是~~爬虫~~CV嘛。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epuppeteer\u003c/code\u003e是\u003ccode\u003enodejs\u003c/code\u003e中一个很好用的自动化工具，都不能说他是爬虫，因为他广泛应用于自动化测试中，可以看看\u003ca href=\"https://zhuanlan.zhihu.com/p/76237595\"\u003e这篇文章\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e借鉴一下我朋友的\u003ca href=\"http://www.weidongwei.com/blog/15?title=puppeteer%E7%88%AC%E7%9F%A5%E4%B9%8E\"\u003e这个文章\u003c/a\u003e，首先：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enpm i -S puppeteer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里因为一下众所周知的原因，下载\u003ccode\u003eChromium\u003c/code\u003e可能有点费劲，我这边之前玩\u003ccode\u003epuppeteer\u003c/code\u003e的时候就装好了，看官可以自行解决一下（搬瓦工啥的）；\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epuppeteer\u003c/code\u003e 作为一个自动化测试的库，其实就是自己在操作\u003ccode\u003eChrome\u003c/code\u003e浏览器在进行一下指令，所以使用这个编写的代码我觉得还是很直观的。\u003c/p\u003e\n\u003ch2\u003e观察需求\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e获取2014-2015年焊接学报的所有学术文章的标题，作者与单位，起止页码，摘要关键词等信息\u003c/li\u003e\n\u003cli\u003e作者需要按行分开，作者和单位需要对应上\u003c/li\u003e\n\u003cli\u003e在上面的基础上，其他行需要合并。\r\n\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480345-841eca98-9523-4f7b-a31c-8c0d14bf5202.png#align=left\u0026#x26;display=inline\u0026#x26;height=779\u0026#x26;margin=%5Bobject%20Object%5D\u0026#x26;originHeight=779\u0026#x26;originWidth=1440\u0026#x26;size=0\u0026#x26;status=done\u0026#x26;style=none\u0026#x26;width=1440\" alt=\"\"\u003e\r\n\u003ca href=\"http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD\u0026#x26;pykm=HJXB\u0026#x26;Year=\u0026#x26;Issue=\u0026#x26;Entry=\"\u003e文章列表页\u003c/a\u003e\r\n\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480374-000ad5f3-f718-4157-875d-9c4fd4f2134e.png#align=left\u0026#x26;display=inline\u0026#x26;height=737\u0026#x26;margin=%5Bobject%20Object%5D\u0026#x26;originHeight=737\u0026#x26;originWidth=1440\u0026#x26;size=0\u0026#x26;status=done\u0026#x26;style=none\u0026#x26;width=1440\" alt=\"\"\u003e\r\n\u003ca href=\"http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=HJXB201401001\u0026#x26;dbname=CJFD2014\u0026#x26;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhMFE3R2FlMkI4akFIS1N4bGlEUUZtWT0%3D%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!\"\u003e单个文章的示例\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e解决方案\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e入口是CNKI的期刊文章列表页，基于ASPX生成。\u003c/li\u003e\n\u003cli\u003e在文章列表页，就可以得到一部分信息\u003c/li\u003e\n\u003cli\u003e摘要，关键词需要进入对应的文章页面去获取\u003c/li\u003e\n\u003cli\u003e作者和单位的对应需要进入pdf查看**（未完成）**\u003c/li\u003e\n\u003cli\u003e完成抓取之后再将数据导出成excel\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以看出，信息呈现三层形式保存。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e爬取所有的首层信息\u003c/h2\u003e\n\u003cp\u003e首先一些准备工作，引入包和规定的格式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst puppeteer = require('puppeteer');\r\nconst url = 'https://navi.cnki.net/knavi/JournalDetail?pcode=CJFD\u0026#x26;pykm=HJXB';\r\n// 统一设定一个等待时间，防止操作太快被目标认出来\r\nconst TIME = 3000;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来就是主函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 一个立即执行的异步函数\r\n(async () =\u003e {\r\n    const browser = await puppeteer.launch({\r\n\t\t// headless: false, // false浏览器界面启动\r\n\t\tslowMo: 100, // 放慢浏览器执行速度，方便测试观察\r\n\t\targs: [\r\n\t\t\t// 启动 Chrome 的参数\r\n\t\t\t'–no-sandbox',\r\n\t\t\t// '--window-size=1280,960',\r\n\t\t],\r\n\t});\r\n    // 创建新页面\r\n    const page = await browser.newPage();\r\n    // 这一句就是前往目标页面\r\n    await page.goto(url, {\r\n\t\t// 网络空闲说明已加载完毕\r\n\t\twaitUntil: 'networkidle2',\r\n\t});\r\n\tconsole.log('page加载完成！');\r\n})()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e经过上面的描述可以看出，\u003ccode\u003epuppeteer\u003c/code\u003e和\u003ccode\u003eElectron\u003c/code\u003e等有点类似，都是主进程中创建子进程进行操作。\u003c/p\u003e\n\u003cp\u003e接着就是在列表页选择对应的年份和期数，并且循环执行。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epuppeteer\u003c/code\u003e意为\u003cstrong\u003e提线木偶\u003c/strong\u003e，所以想让浏览器做什么就发出对应的指令即可：\u003c/p\u003e\n\u003cp\u003e首先是用到的两个\u003ccode\u003eutil\u003c/code\u003e函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 因为网页上年份的按钮的id是数字开头，直接S()会出错\r\n// 所以需要把它转换成Unicode\r\nfunction getID(year) {\r\n\tlet num = year - 2010;\r\n\treturn `#\\\\0032\\\\0030\\\\0031\\\\003${num}\\\\005f\\\\0059\\\\0065\\\\0061\\\\0072\\\\005f\\\\0049\\\\0073\\\\0073\\\\0075\\\\0065`;\r\n}\r\n\r\n// 选择某一年某一期的id\r\nfunction getNoDotID(year, num) {\r\n\tlet _num = num \u0026#x3C; 10 ? `0${num}` : `${num}`;\r\n\treturn `#yq${year}${_num}`;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 选择2014年，对每一期进行点击\r\n// 年份点击事件\r\nlet yearNum = 2014;\r\nconst yearBtn = await page.$(getID(yearNum));\r\nawait yearBtn.click();\r\nawait page.waitFor(TIME);\r\nlet accNum = 1;\r\n// 输出的结果，是一个二维数组。\r\nlet output = [];\r\n// 从第一期开始，一个月一期\r\nwhile (accNum \u0026#x3C; 13) {\r\n    // 循环选择第几期\r\n    let NoDot = await page.$(getNoDotID(yearNum, accNum));\r\n    NoDot.click();\r\n\r\n    // 保存所有的信息\r\n    await page.waitFor(TIME);\r\n\r\n    console.log('选择列表...' + accNum);\r\n    const list = await page.$('#CataLogContent');\r\n    const items = await list.?('dd');\r\n\r\n    const res = await page.evaluate(list =\u003e {\r\n        // ...\r\n    }, list);\r\n    output.push(res);\r\n    accNum++;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epage.$(), page.?()\u003c/code\u003e类似于\u003ccode\u003edocument.querySelector/querySelectorAll\u003c/code\u003e，返回一个节点元素\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epage.evaluate(function,node)\u003c/code\u003e 是对上面选择到的对应的node节点进行浏览器内操作的方法，在function中实现。，function接受node作为参数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在\u003ccode\u003epage.evaluate\u003c/code\u003e的内部，我们将文章的信息（标题，起止页码等）以及链接提取出来保存起来。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst res = await page.evaluate(list =\u003e {\r\n    // 在这里就可以使用browser的对象啦\r\n    const itemList = list.querySelectorAll('dd');\r\n    let arr = [];\r\n    // console.log(itemList);\r\n    for (let item of itemList) {\r\n        // 这里是发现cnki是基于aspx的网页\r\n        // 并且跳转到对应的页面是有规律的，和filename之后的id有关\r\n        // 另外，不同的年份有不同的数据库\r\n        const getPaperId = function(id) {\r\n            let match = /filename=(\\w+)\u0026#x26;/i.exec(id);\r\n            return match[1];\r\n        }\r\n        let paperID = item.querySelector('.opts \u003e .btn-view \u003ea').href;\r\n        let id = getPaperId(paperID);\r\n        // 最后将2014年某一条的innerText和id保存成一个字符串，留着之后解析\r\n        let content = item.innerText + '\u0026#x26;' +id;\r\n        arr.push(content);\r\n    }\r\n    return arr;\r\n}, list);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样运行一下\u003ccode\u003enpm start\u003c/code\u003e，得到的数据就log出来了。目前我就是直接复制了一下，当然也有其他的办法。\u003c/p\u003e\n\u003cp\u003e最终得到的\u003ccode\u003edata.txt\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[\r\n    [\"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\\n樊丁;蒋锴;余淑荣;张健;\\n1-4+113\u0026#x26;HJXB201401001\",\"铝合金超声-MIG焊接电弧行为\\n范成磊;谢伟峰;杨春利;寇毅;\\n5-8+113\u0026#x26;HJXB201401002\",...],\r\n     ...\r\n ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e爬取摘要，关键词等信息\u003c/h2\u003e\n\u003cp\u003e目前是有了部分信息，但是摘要和关键词还需要在第二层里面获取;\u003c/p\u003e\n\u003ch3\u003e对数据进行一些预处理\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enpm run analysis\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这一部分就是对上面得到的list进行处理，首先把2维数组拍平：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst out2014S = require('./output2014');\r\nconst out2015S = require('./output2015');\r\nconst fs = require('fs');\r\n\r\n// 获取引用\r\nlet out2014 = out2014S;\r\nlet out2015 = out2015S;\r\n// flat\r\nwhile (out2014.some(Array.isArray)) {\r\n\tout2014 = [].concat(...out2014);\r\n}\r\n\r\nwhile (out2015.some(Array.isArray)) {\r\n\tout2015 = [].concat(...out2015);\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e目前得到的数据示例如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\\n樊丁;蒋锴;余淑荣;张健;\\n1-4+113\u0026#x26;HJXB201401001\",\r\n    ...\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e需要对这个进行分析，自定义一个split函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction SecondeSplit(arr, year) {\r\n    // 数据序列化一下，保存下\\n用于分割\r\n\tlet str = JSON.stringify(arr);\r\n\tconsole.log('str' + str);\r\n\tlet nArr = str.split('\\\\n');\r\n\tconsole.log('nArr' + nArr);\r\n\t// 0 title\r\n\t// 1 string authors\r\n\t// 2 pages and link\r\n\tlet res = {};\r\n    // clean\r\n\tres.title = nArr[0].replace(/\\\"/i, '');\r\n\tlet names = nArr[1].split(';');\r\n\tres.name = names.slice(0, names.length - 1);\r\n    // 存在有的文章没有页码和链接等问题\r\n\tif (nArr[2]) {\r\n\t\tlet linkArr = nArr[2].split('\u0026#x26;');\r\n        // clean\r\n\t\tlet link = linkArr[1].replace(/\\\"/i, '');\r\n        // 两年的dbname稍有不同\r\n\t\tif (year === 2014) {\r\n\t\t\tres.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=${link}\u0026#x26;dbname=CJFD2014`;\r\n\t\t}\r\n\t\tif (year === 2015) {\r\n\t\t\tres.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=${link}\u0026#x26;dbname=CJFDLAST2015`;\r\n\t\t}\r\n\t\tlet pages = linkArr[0].split('+');\r\n\t\tlet pageArr = pages[0].split('-');\r\n\t\tres.start = pageArr[0];\r\n\t\tres.end = pageArr[1];\r\n\t}\r\n\treturn res;\r\n}\r\n\r\n// 对两年的数据进行操作\r\nlet ret2014 = [];\r\nout2014.forEach(i =\u003e {\r\n\tlet tmp = SecondeSplit(i, 2014);\r\n\tret2014.push(tmp);\r\n});\r\n// ... 2015一样\r\n\r\nlet ret = ret2014.concat(ret2015);\r\n\r\nlet jsonObj = {};\r\njsonObj.data = ret;\r\n// \\t能够保存一个比较美观的json\r\nlet wObj = JSON.stringify(jsonObj, '', '\\t');\r\nfs.writeFile('data.json', wObj, err =\u003e {\r\n\tconsole.log(err);\r\n});\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e爬取摘要等\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enpm run abstract\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这里的主要思路就是继续操作\u003ccode\u003epuppeteer\u003c/code\u003e，对每一个链接，获取对应摘要，学校和关键词信息\u003c/p\u003e\n\u003cp\u003e这里的\u003ccode\u003epuppeteer\u003c/code\u003e并没有用基于\u003ccode\u003easync\u003c/code\u003e的写法，用\u003ccode\u003ethen\u003c/code\u003e也很方便。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst obj = require('../data1.json');\r\nconst fs = require('fs');\r\nconst puppeteer = require('puppeteer');\r\n// 因为要对obj操作\r\nlet data = obj;\r\nconst len = data.data.length;\r\npuppeteer\r\n\t.launch({\r\n\t\theadless: true,\r\n\t})\r\n\t.then(async browser =\u003e {\r\n\t\tfor (let i = 0; i \u0026#x3C; len; i++) {\r\n\t\t\tif (data.data[i].link) {\r\n\t\t\t\tconst res = await getAbstract(i, data.data[i].link, browser);\r\n                // 这里就用keyword来判断是否抓取成功了\r\n\t\t\t\tconsole.log(i + ': ' + res.keywords);\r\n\t\t\t\tdata.data[i].abstract = res.abstract;\r\n\t\t\t\tdata.data[i].school = res.school;\r\n\t\t\t\tdata.data[i].keywords = res.keywords;\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\t.then(() =\u003e {\r\n\t\tconsole.log('获取信息完成！');\r\n\t\t// console.log(data.data[0].abstract);\r\n    \t// 保存到data1.json\r\n\t\tsave(data);\r\n\t});\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetAbstract\u003c/code\u003e是一个获取摘要的函数，需要传browser实例，链接和序号：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003easync function getAbstract(num, link, browser) {\r\n\tconst page = await browser.newPage();\r\n\tawait page.goto(link);\r\n\tawait page.waitFor(3000);\r\n    // 摘要\r\n\tlet abs = await page.$('#ChDivSummary');\r\n\tlet abstract = await page.evaluate(abs =\u003e {\r\n\t\treturn abs.innerText;\r\n\t}, abs);\r\n    // 学校\r\n\tlet schoolDOM = await page.$('.orgn');\r\n\tlet school = await page.evaluate(schoolDOM =\u003e {\r\n\t\tlet arr = schoolDOM.querySelectorAll('span \u003e a');\r\n\t\tlet res = '';\r\n\t\tarr.forEach(i =\u003e {\r\n\t\t\tres += i.text + ',';\r\n\t\t});\r\n        // 拼接为字符串后就删掉最后一个逗号\r\n\t\treturn res.slice(0, res.length - 1);\r\n\t}, schoolDOM);\r\n    // 关键词\r\n\tlet keysDOM = await page.$('#catalog_KEYWORD');\r\n\tlet keys = await page.evaluate(keysDOM =\u003e {\r\n    // let arr = keysDOM.querySelectorAll('p')[2].querySelectorAll('a');\r\n    // 上面的写法并不好，因为有的挂了基金有的没挂，所以不一定是第三个\r\n    // 发现关键词里面一个dom是有id的\r\n    // 所以选用了兄弟节点的方法。\r\n    let arr = keysDOM.parentNode.children;\r\n    let res = '';\r\n    for(let j=1;j\u0026#x3C;arr.length;j++){\r\n      res += arr[j].text.replace(/ /g, '').replace(/\\n/g, '');\r\n    }\r\n\t\treturn res;\r\n\t}, keysDOM);\r\n\tawait page.waitFor(3000);\r\n    // 节省内存，每次查询完就关闭页面\r\n\tawait page.close();\r\n\treturn {\r\n\t\tabstract: abstract,\r\n\t\tschool: school,\r\n\t\tkeywords: keys,\r\n\t};\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就得到了完整的数据：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\r\n\t\"data\": [\r\n\t\t{\r\n\t\t\t\"title\": \"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\",\r\n\t\t\t\"name\": [\r\n\t\t\t\t\"樊丁\",\r\n\t\t\t\t\"蒋锴\",\r\n\t\t\t\t\"余淑荣\",\r\n\t\t\t\t\"张健\"\r\n\t\t\t],\r\n\t\t\t\"link\": \"http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=HJXB201401001\u0026#x26;dbname=CJFD2014\",\r\n\t\t\t\"start\": \"1\",\r\n\t\t\t\"end\": \"4\",\r\n\t\t\t\"abstract\": \"以5052铝合金和热镀锌ST04Z钢为研究对象,采用预置涂粉CO2激光搭接熔钎焊方法进行工艺试验.利用光学显微镜、扫描电镜和拉伸试验机对熔钎焊接头的微观组织和力学性能进行了研究.结果表明,涂助溶剂和粉末后,焊缝成形明显改善,镀锌层没有烧损;熔—钎焊接头过渡层最大厚度小于10μm,针状Al-Fe金属间化合物没有向熔化的铝侧明显析出;接头具有较高的力学性能,最大机械抗载能力可达到208 MPa,约为5052铝合金母材抗拉强度的95.41%. \",\r\n\t\t\t\"school\": \"兰州理工大学甘肃省有色金属新材料省部共建国家重点实验室,兰州理工大学有色金属合金及加工教育部重点实验室\",\r\n\t\t\t\"keywords\": \"铝钢;激光焊接;熔钎焊;粉末;\"\r\n\t\t},\r\n        ...\r\n    ]\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e将数据导出到EXCEL\u003c/h2\u003e\n\u003cp\u003e这里就是将数据导出啦，需求里面写的还是很明白的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480515-8d1e0e12-02a0-40ca-90ca-173fbd56336f.png#align=left\u0026#x26;display=inline\u0026#x26;height=362\u0026#x26;margin=%5Bobject%20Object%5D\u0026#x26;originHeight=362\u0026#x26;originWidth=1492\u0026#x26;size=0\u0026#x26;status=done\u0026#x26;style=none\u0026#x26;width=1492\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e我的想法就是根据每一个item的作者list的长度，首先是写出若干行，然后再将除了作者和单位之外的行进行合并。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst Excel = require('exceljs');\r\nconst data = require('../data1.json');\r\n\r\n// 数据预处理\r\nlet input = [];\r\nlet obj = data.data;\r\nobj.forEach((item, index) =\u003e {\r\n\tlet len = item.name.length;\r\n\r\n\tlet link = item.link;\r\n\tlet reg = /HJXB201(4|5)([0-9]{2})/i;\r\n\r\n\tlet year = -1;\r\n\tlet juan = -1;\r\n\tlet vol = -1;\r\n\tif (link) {\r\n\t\tyear = link.substring(link.length - 4, link.length);\r\n        // 2014年是35卷，2015=36卷\r\n\t\tjuan = year == 2014 ? 35 : 36;\r\n        // 期数在链接里面就可以查出，是第二个匹配项\r\n\t\tvol = reg.exec(link)[2];\r\n\t}\r\n\r\n\tfor (let i = 0; i \u0026#x3C; len; i++) {\r\n        // 将数据整理成exceljs需要的样子\r\n\t\tinput.push({\r\n\t\t\tindex: index + 1,\r\n\t\t\ttitle: item.title,\r\n\t\t\tname: item.name[i],\r\n\t\t\tlang: '中文',\r\n\t\t\tschool: item.school,\r\n\t\t\tabstract: item.abstract,\r\n\t\t\tyear: year,\r\n\t\t\tjuan: juan,\r\n\t\t\tvol: vol,\r\n\t\t\tkeyType: '关键词',\r\n\t\t\tpaperName: '焊接学报',\r\n\t\t\tkeywords: item.keywords,\r\n\t\t\tstart: item.start,\r\n\t\t\tend: item.end,\r\n\t\t});\r\n\t}\r\n});\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接着使用exceljs来创建工作表：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// excel处理\r\nlet workbook = new Excel.Workbook();\r\n\r\nworkbook.creator = 'xujx';\r\n\r\nlet sheet = workbook.addWorksheet('sheet 1');\r\n\r\nsheet.columns = [\r\n\t{ header: '序号', key: 'index', width: 10 },\r\n\t{ header: '唯一标识类型', key: 'onlykey', width: 10 },\r\n\t{ header: '唯一标识', key: 'onlyid', width: 10 },\r\n\t{ header: '题名', key: 'title', width: 15 },\r\n\t{ header: '正文语种', key: 'lang', width: 10 },\r\n\t{ header: '责任者/责任者姓名', key: 'name', width: 15 },\r\n\t{ header: '责任者/责任者机构/责任机构名称', key: 'school', width: 15 },\r\n\t{ header: '摘要', key: 'abstract', width: 15 },\r\n\t{ header: '主题/主题元素类型', key: 'keyType', width: 15 },\r\n\t{ header: '主题/主题名称', key: 'keywords', width: 15 },\r\n\t{ header: '期刊名称', key: 'paperName', width: 15 },\r\n\t{ header: '出版年', key: 'year', width: 15 },\r\n\t{ header: '规范期刊URI', key: 'URI', width: 15 },\r\n\t{ header: '卷', key: 'juan', width: 15 },\r\n\t{ header: '期', key: 'vol', width: 15 },\r\n\t{ header: '起始页码', key: 'start', width: 15 },\r\n\t{ header: '结束页码', key: 'end', width: 15 },\r\n\t{ header: '收录信息/收录类别代码', key: 'typeCode', width: 15 },\r\n];\r\n\r\nsheet.addRows(input);\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这之后就合并单元格：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 合并单元格\r\n// 首先获取每一项的作者个数，保存在一个array中\r\nlet nameLength = [];\r\nobj.forEach(item =\u003e {\r\n\tif (item.name.length) {\r\n\t\tnameLength.push(item.name.length);\r\n\t} else {\r\n\t\tnameLength.push(0);\r\n\t}\r\n});\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e合并单元格从第二行开始（第一行是表头）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efor (let j = 0; j \u0026#x3C; ret.length; j += 2) {\r\n\tsheet.mergeCells(`A${ret[j]}:A${ret[j + 1]}`);\r\n\tsheet.mergeCells(`B${ret[j]}:B${ret[j + 1]}`);\r\n\tsheet.mergeCells(`C${ret[j]}:C${ret[j + 1]}`);\r\n\tsheet.mergeCells(`D${ret[j]}:D${ret[j + 1]}`);\r\n\tsheet.mergeCells(`E${ret[j]}:E${ret[j + 1]}`);\r\n\tsheet.mergeCells(`H${ret[j]}:H${ret[j + 1]}`);\r\n\tsheet.mergeCells(`I${ret[j]}:I${ret[j + 1]}`);\r\n\tsheet.mergeCells(`J${ret[j]}:J${ret[j + 1]}`);\r\n\tsheet.mergeCells(`K${ret[j]}:K${ret[j + 1]}`);\r\n\tsheet.mergeCells(`L${ret[j]}:L${ret[j + 1]}`);\r\n\tsheet.mergeCells(`M${ret[j]}:M${ret[j + 1]}`);\r\n\tsheet.mergeCells(`N${ret[j]}:N${ret[j + 1]}`);\r\n\tsheet.mergeCells(`O${ret[j]}:O${ret[j + 1]}`);\r\n\tsheet.mergeCells(`P${ret[j]}:P${ret[j + 1]}`);\r\n\tsheet.mergeCells(`Q${ret[j]}:Q${ret[j + 1]}`);\r\n\tsheet.mergeCells(`R${ret[j]}:R${ret[j + 1]}`);\r\n}\r\n\r\nworkbook.xlsx.writeFile('1.xlsx').then(function() {\r\n\t// done\r\n\tconsole.log('done');\r\n});\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的数组\u003ccode\u003eret\u003c/code\u003e是这样得到的，它保存了合并单元格的起止位置。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet ret = [];\r\n// 是从第2行开始\r\nret.push(2);\r\n// 对于每一个作者长度\r\nfor (let i = 0; i \u0026#x3C; nameLength.length; i++) {\r\n    // 表示尾部的那个节点的位置\r\n\tlet head = ret[ret.length - 1];\r\n    // 目前数组长度为偶数，说明现在是成对的，因此需要把尾部节点的下一个数加入数组\r\n\tif (ret.length % 2 === 0) {\r\n\t\tret.push(head + 1);\r\n        // 同时，由于这一循环并没有用到nameLength数组，所以不算做循环++\r\n    \ti--;\r\n\t} else {\r\n        // 如果是奇数，说明需要添加一个步长，来合并单元格\r\n        // 所以需要一个作者个数-1的步长\r\n    \tret.push(head + nameLength[i] - 1);\r\n\t}\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就完成了99%了！\u003c/p\u003e\n\u003ch3\u003e未完成的部分\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e但是需求里面还说需要作者和作者的单位对应，这就需要把文章下载下来分析了。\u003c/li\u003e\n\u003cli\u003e我目前的尝试是\u003ccode\u003epdf2json\u003c/code\u003e，不过并不成功，时间紧迫就开启人工智能模式 ——手动搞了一下\u003c/li\u003e\n\u003cli\u003e确实有点累。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e源码地址\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Alfxjx/CNKI-HJXB-Crawler\"\u003eGithub 求个star吧555\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://juejin.cn/post/6844904083921305614\"\u003e原文地址\u003c/a\u003e\u003c/p\u003e\n","coverImage":"/assets/blog/puppeteer.jfif"}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"puppeteer-cnki"},"buildId":"Q5-ARss9H4OnstBP8NDja","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>