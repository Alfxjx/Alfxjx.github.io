<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6ac04af9c34471e28ed7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6ac04af9c34471e28ed7.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8fa755d3830e88407993.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8fa755d3830e88407993.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-61095c13c5984b221292.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-588261c74baf7142d208.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ba362a84ebeb8af99e09.js" defer=""></script><script src="/_next/static/chunks/218-9c9954576784832dc5a8.js" defer=""></script><script src="/_next/static/chunks/105-42ae8ba0786c723858a1.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-14a1c96b5641bda3795c.js" defer=""></script><script src="/_next/static/vAXKNB2ztkDyOXgsMiReF/_buildManifest.js" defer=""></script><script src="/_next/static/vAXKNB2ztkDyOXgsMiReF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Post__Wrapper-sc-q8sq7-0 blKUxx"><div class="ProgressBar__ProgressBarWrapper-sc-1ufpd9c-0 gqWHWe"><div class="bar-used"></div></div><div class="header"><div class="icon-wrapper"><div class="icons"><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8c-14.7 12.8-14.7 35.6 0 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"></path></svg></div><div class="icons"><a href="/tech"><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M541.141 268.864l61.718 16.939-132.395 482.474-61.717-16.938L541.14 268.864zm-212.138 29.803l44.885 45.61-175.36 172.587 175.04 167.573-44.267 46.23-222.634-213.163 222.336-218.837zm355.882 0l222.336 218.837-222.634 213.163-44.267-46.23 175.019-167.573L640 344.277l44.885-45.61z"></path></svg></a></div></div></div><div class="toggle"><button class="Button__InsideButton-sc-19071w6-0 cyRVLS"><div class="LightDarkSwitcher__Switcher-sc-hbms9j-0 cBdTSF"><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M448 64v195.2a224.832 224.832 0 0 0-100.992 42.24L208.512 163.2l-45.248 45.312 138.24 138.496A218.624 218.624 0 0 0 259.008 448H64v64h195.008c5.504 37.76 20.48 72 42.496 100.992l-138.24 138.496 45.248 45.248L347.008 658.24C376 680 410.496 695.232 448 700.736V896h64V700.8a222.4 222.4 0 0 0 100.992-42.56l138.496 138.496 45.248-45.248L658.24 612.992A216.32 216.32 0 0 0 700.992 512H896v-64H700.992a216.32 216.32 0 0 0-42.752-100.992l138.496-138.496-45.248-45.248-138.496 138.24A224.832 224.832 0 0 0 512 259.2V64zm32 256c88.768 0 160 71.232 160 160s-71.232 160-160 160a159.488 159.488 0 0 1-160-160c0-88.768 71.232-160 160-160z"></path></svg></div></button></div><div style="height:3.25rem"></div><div class="Post-sc-1u8x57o-0 Post__PostWrapper-sc-q8sq7-1 fbyABu mIDzq"><div class="info"><h1>[Puppeteer]我是如何做到写EXCEL时速3k行的</h1><div class="user"><img class="img" src="/assets/authors/alfxjx.jpg" alt="Alfxjx"/><span class="title">Alfxjx</span><div class="date">2020-05-04</div></div></div><div class="post"><h2>起因</h2>
<p>之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目</p>
<p>统计某某期刊的信息。</p>
<p>粗粗看了一下14个人的群里，有我这样延毕的~~老狗~~ 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法：</p>
<p><strong>CODING</strong>!!!</p>
<h2>开干吧</h2>
<p>首先确定技术栈，因为主攻前端不懂就问，所以选择node作为主要的开发语言，加之要做的是统计文章的信息，稍微想了一下，这个需求不就是~~爬虫~~CV嘛。</p>
<p><code>puppeteer</code>是<code>nodejs</code>中一个很好用的自动化工具，都不能说他是爬虫，因为他广泛应用于自动化测试中，可以看看<a href="https://zhuanlan.zhihu.com/p/76237595">这篇文章</a>。</p>
<p>借鉴一下我朋友的<a href="http://www.weidongwei.com/blog/15?title=puppeteer%E7%88%AC%E7%9F%A5%E4%B9%8E">这个文章</a>，首先：</p>
<pre><code>npm i -S puppeteer
</code></pre>
<p>这里因为一下众所周知的原因，下载<code>Chromium</code>可能有点费劲，我这边之前玩<code>puppeteer</code>的时候就装好了，看官可以自行解决一下（搬瓦工啥的）；</p>
<p><code>puppeteer</code> 作为一个自动化测试的库，其实就是自己在操作<code>Chrome</code>浏览器在进行一下指令，所以使用这个编写的代码我觉得还是很直观的。</p>
<h2>观察需求</h2>
<ul>
<li>获取2014-2015年焊接学报的所有学术文章的标题，作者与单位，起止页码，摘要关键词等信息</li>
<li>作者需要按行分开，作者和单位需要对应上</li>
<li>在上面的基础上，其他行需要合并。
<img src="https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480345-841eca98-9523-4f7b-a31c-8c0d14bf5202.png#align=left&#x26;display=inline&#x26;height=779&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=779&#x26;originWidth=1440&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1440" alt="">
<a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&#x26;pykm=HJXB&#x26;Year=&#x26;Issue=&#x26;Entry=">文章列表页</a>
<img src="https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480374-000ad5f3-f718-4157-875d-9c4fd4f2134e.png#align=left&#x26;display=inline&#x26;height=737&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=737&#x26;originWidth=1440&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1440" alt="">
<a href="http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=HJXB201401001&#x26;dbname=CJFD2014&#x26;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhMFE3R2FlMkI4akFIS1N4bGlEUUZtWT0%3D%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">单个文章的示例</a></li>
</ul>
<h2>解决方案</h2>
<ul>
<li>入口是CNKI的期刊文章列表页，基于ASPX生成。</li>
<li>在文章列表页，就可以得到一部分信息</li>
<li>摘要，关键词需要进入对应的文章页面去获取</li>
<li>作者和单位的对应需要进入pdf查看**（未完成）**</li>
<li>完成抓取之后再将数据导出成excel</li>
</ul>
<blockquote>
<p>可以看出，信息呈现三层形式保存。</p>
</blockquote>
<h2>爬取所有的首层信息</h2>
<p>首先一些准备工作，引入包和规定的格式：</p>
<pre><code class="language-javascript">const puppeteer = require('puppeteer');
const url = 'https://navi.cnki.net/knavi/JournalDetail?pcode=CJFD&#x26;pykm=HJXB';
// 统一设定一个等待时间，防止操作太快被目标认出来
const TIME = 3000;
</code></pre>
<p>接下来就是主函数：</p>
<pre><code class="language-javascript">// 一个立即执行的异步函数
(async () => {
    const browser = await puppeteer.launch({
		// headless: false, // false浏览器界面启动
		slowMo: 100, // 放慢浏览器执行速度，方便测试观察
		args: [
			// 启动 Chrome 的参数
			'–no-sandbox',
			// '--window-size=1280,960',
		],
	});
    // 创建新页面
    const page = await browser.newPage();
    // 这一句就是前往目标页面
    await page.goto(url, {
		// 网络空闲说明已加载完毕
		waitUntil: 'networkidle2',
	});
	console.log('page加载完成！');
})()
</code></pre>
<p>经过上面的描述可以看出，<code>puppeteer</code>和<code>Electron</code>等有点类似，都是主进程中创建子进程进行操作。</p>
<p>接着就是在列表页选择对应的年份和期数，并且循环执行。</p>
<p><code>puppeteer</code>意为<strong>提线木偶</strong>，所以想让浏览器做什么就发出对应的指令即可：</p>
<p>首先是用到的两个<code>util</code>函数：</p>
<pre><code class="language-javascript">// 因为网页上年份的按钮的id是数字开头，直接S()会出错
// 所以需要把它转换成Unicode
function getID(year) {
	let num = year - 2010;
	return `#\\0032\\0030\\0031\\003${num}\\005f\\0059\\0065\\0061\\0072\\005f\\0049\\0073\\0073\\0075\\0065`;
}

// 选择某一年某一期的id
function getNoDotID(year, num) {
	let _num = num &#x3C; 10 ? `0${num}` : `${num}`;
	return `#yq${year}${_num}`;
}
</code></pre>
<p>接下来：</p>
<pre><code class="language-javascript">// 选择2014年，对每一期进行点击
// 年份点击事件
let yearNum = 2014;
const yearBtn = await page.$(getID(yearNum));
await yearBtn.click();
await page.waitFor(TIME);
let accNum = 1;
// 输出的结果，是一个二维数组。
let output = [];
// 从第一期开始，一个月一期
while (accNum &#x3C; 13) {
    // 循环选择第几期
    let NoDot = await page.$(getNoDotID(yearNum, accNum));
    NoDot.click();

    // 保存所有的信息
    await page.waitFor(TIME);

    console.log('选择列表...' + accNum);
    const list = await page.$('#CataLogContent');
    const items = await list.?('dd');

    const res = await page.evaluate(list => {
        // ...
    }, list);
    output.push(res);
    accNum++;
}
</code></pre>
<ul>
<li><code>page.$(), page.?()</code>类似于<code>document.querySelector/querySelectorAll</code>，返回一个节点元素</li>
<li><code>page.evaluate(function,node)</code> 是对上面选择到的对应的node节点进行浏览器内操作的方法，在function中实现。，function接受node作为参数。</li>
</ul>
<p>在<code>page.evaluate</code>的内部，我们将文章的信息（标题，起止页码等）以及链接提取出来保存起来。</p>
<pre><code class="language-javascript">const res = await page.evaluate(list => {
    // 在这里就可以使用browser的对象啦
    const itemList = list.querySelectorAll('dd');
    let arr = [];
    // console.log(itemList);
    for (let item of itemList) {
        // 这里是发现cnki是基于aspx的网页
        // 并且跳转到对应的页面是有规律的，和filename之后的id有关
        // 另外，不同的年份有不同的数据库
        const getPaperId = function(id) {
            let match = /filename=(\w+)&#x26;/i.exec(id);
            return match[1];
        }
        let paperID = item.querySelector('.opts > .btn-view >a').href;
        let id = getPaperId(paperID);
        // 最后将2014年某一条的innerText和id保存成一个字符串，留着之后解析
        let content = item.innerText + '&#x26;' +id;
        arr.push(content);
    }
    return arr;
}, list);
</code></pre>
<p>这样运行一下<code>npm start</code>，得到的数据就log出来了。目前我就是直接复制了一下，当然也有其他的办法。</p>
<p>最终得到的<code>data.txt</code>:</p>
<pre><code class="language-javascript">[
    ["5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\n樊丁;蒋锴;余淑荣;张健;\n1-4+113&#x26;HJXB201401001","铝合金超声-MIG焊接电弧行为\n范成磊;谢伟峰;杨春利;寇毅;\n5-8+113&#x26;HJXB201401002",...],
     ...
 ]
</code></pre>
<h2>爬取摘要，关键词等信息</h2>
<p>目前是有了部分信息，但是摘要和关键词还需要在第二层里面获取;</p>
<h3>对数据进行一些预处理</h3>
<p><code>npm run analysis</code></p>
<p>这一部分就是对上面得到的list进行处理，首先把2维数组拍平：</p>
<pre><code class="language-javascript">const out2014S = require('./output2014');
const out2015S = require('./output2015');
const fs = require('fs');

// 获取引用
let out2014 = out2014S;
let out2015 = out2015S;
// flat
while (out2014.some(Array.isArray)) {
	out2014 = [].concat(...out2014);
}

while (out2015.some(Array.isArray)) {
	out2015 = [].concat(...out2015);
}
</code></pre>
<p>目前得到的数据示例如下：</p>
<pre><code class="language-javascript">"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\n樊丁;蒋锴;余淑荣;张健;\n1-4+113&#x26;HJXB201401001",
    ...

</code></pre>
<p>需要对这个进行分析，自定义一个split函数：</p>
<pre><code class="language-javascript">function SecondeSplit(arr, year) {
    // 数据序列化一下，保存下\n用于分割
	let str = JSON.stringify(arr);
	console.log('str' + str);
	let nArr = str.split('\\n');
	console.log('nArr' + nArr);
	// 0 title
	// 1 string authors
	// 2 pages and link
	let res = {};
    // clean
	res.title = nArr[0].replace(/\"/i, '');
	let names = nArr[1].split(';');
	res.name = names.slice(0, names.length - 1);
    // 存在有的文章没有页码和链接等问题
	if (nArr[2]) {
		let linkArr = nArr[2].split('&#x26;');
        // clean
		let link = linkArr[1].replace(/\"/i, '');
        // 两年的dbname稍有不同
		if (year === 2014) {
			res.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=${link}&#x26;dbname=CJFD2014`;
		}
		if (year === 2015) {
			res.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=${link}&#x26;dbname=CJFDLAST2015`;
		}
		let pages = linkArr[0].split('+');
		let pageArr = pages[0].split('-');
		res.start = pageArr[0];
		res.end = pageArr[1];
	}
	return res;
}

// 对两年的数据进行操作
let ret2014 = [];
out2014.forEach(i => {
	let tmp = SecondeSplit(i, 2014);
	ret2014.push(tmp);
});
// ... 2015一样

let ret = ret2014.concat(ret2015);

let jsonObj = {};
jsonObj.data = ret;
// \t能够保存一个比较美观的json
let wObj = JSON.stringify(jsonObj, '', '\t');
fs.writeFile('data.json', wObj, err => {
	console.log(err);
});

</code></pre>
<h3>爬取摘要等</h3>
<p><code>npm run abstract</code></p>
<p>这里的主要思路就是继续操作<code>puppeteer</code>，对每一个链接，获取对应摘要，学校和关键词信息</p>
<p>这里的<code>puppeteer</code>并没有用基于<code>async</code>的写法，用<code>then</code>也很方便。</p>
<pre><code class="language-javascript">const obj = require('../data1.json');
const fs = require('fs');
const puppeteer = require('puppeteer');
// 因为要对obj操作
let data = obj;
const len = data.data.length;
puppeteer
	.launch({
		headless: true,
	})
	.then(async browser => {
		for (let i = 0; i &#x3C; len; i++) {
			if (data.data[i].link) {
				const res = await getAbstract(i, data.data[i].link, browser);
                // 这里就用keyword来判断是否抓取成功了
				console.log(i + ': ' + res.keywords);
				data.data[i].abstract = res.abstract;
				data.data[i].school = res.school;
				data.data[i].keywords = res.keywords;
			}
		}
	})
	.then(() => {
		console.log('获取信息完成！');
		// console.log(data.data[0].abstract);
    	// 保存到data1.json
		save(data);
	});

</code></pre>
<p><code>getAbstract</code>是一个获取摘要的函数，需要传browser实例，链接和序号：</p>
<pre><code class="language-javascript">async function getAbstract(num, link, browser) {
	const page = await browser.newPage();
	await page.goto(link);
	await page.waitFor(3000);
    // 摘要
	let abs = await page.$('#ChDivSummary');
	let abstract = await page.evaluate(abs => {
		return abs.innerText;
	}, abs);
    // 学校
	let schoolDOM = await page.$('.orgn');
	let school = await page.evaluate(schoolDOM => {
		let arr = schoolDOM.querySelectorAll('span > a');
		let res = '';
		arr.forEach(i => {
			res += i.text + ',';
		});
        // 拼接为字符串后就删掉最后一个逗号
		return res.slice(0, res.length - 1);
	}, schoolDOM);
    // 关键词
	let keysDOM = await page.$('#catalog_KEYWORD');
	let keys = await page.evaluate(keysDOM => {
    // let arr = keysDOM.querySelectorAll('p')[2].querySelectorAll('a');
    // 上面的写法并不好，因为有的挂了基金有的没挂，所以不一定是第三个
    // 发现关键词里面一个dom是有id的
    // 所以选用了兄弟节点的方法。
    let arr = keysDOM.parentNode.children;
    let res = '';
    for(let j=1;j&#x3C;arr.length;j++){
      res += arr[j].text.replace(/ /g, '').replace(/\n/g, '');
    }
		return res;
	}, keysDOM);
	await page.waitFor(3000);
    // 节省内存，每次查询完就关闭页面
	await page.close();
	return {
		abstract: abstract,
		school: school,
		keywords: keys,
	};
}

</code></pre>
<p>这样就得到了完整的数据：</p>
<pre><code class="language-json">{
	"data": [
		{
			"title": "5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性",
			"name": [
				"樊丁",
				"蒋锴",
				"余淑荣",
				"张健"
			],
			"link": "http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=HJXB201401001&#x26;dbname=CJFD2014",
			"start": "1",
			"end": "4",
			"abstract": "以5052铝合金和热镀锌ST04Z钢为研究对象,采用预置涂粉CO2激光搭接熔钎焊方法进行工艺试验.利用光学显微镜、扫描电镜和拉伸试验机对熔钎焊接头的微观组织和力学性能进行了研究.结果表明,涂助溶剂和粉末后,焊缝成形明显改善,镀锌层没有烧损;熔—钎焊接头过渡层最大厚度小于10μm,针状Al-Fe金属间化合物没有向熔化的铝侧明显析出;接头具有较高的力学性能,最大机械抗载能力可达到208 MPa,约为5052铝合金母材抗拉强度的95.41%. ",
			"school": "兰州理工大学甘肃省有色金属新材料省部共建国家重点实验室,兰州理工大学有色金属合金及加工教育部重点实验室",
			"keywords": "铝钢;激光焊接;熔钎焊;粉末;"
		},
        ...
    ]
}

</code></pre>
<h2>将数据导出到EXCEL</h2>
<p>这里就是将数据导出啦，需求里面写的还是很明白的：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480515-8d1e0e12-02a0-40ca-90ca-173fbd56336f.png#align=left&#x26;display=inline&#x26;height=362&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=362&#x26;originWidth=1492&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1492" alt=""></p>
<p>我的想法就是根据每一个item的作者list的长度，首先是写出若干行，然后再将除了作者和单位之外的行进行合并。</p>
<pre><code class="language-javascript">const Excel = require('exceljs');
const data = require('../data1.json');

// 数据预处理
let input = [];
let obj = data.data;
obj.forEach((item, index) => {
	let len = item.name.length;

	let link = item.link;
	let reg = /HJXB201(4|5)([0-9]{2})/i;

	let year = -1;
	let juan = -1;
	let vol = -1;
	if (link) {
		year = link.substring(link.length - 4, link.length);
        // 2014年是35卷，2015=36卷
		juan = year == 2014 ? 35 : 36;
        // 期数在链接里面就可以查出，是第二个匹配项
		vol = reg.exec(link)[2];
	}

	for (let i = 0; i &#x3C; len; i++) {
        // 将数据整理成exceljs需要的样子
		input.push({
			index: index + 1,
			title: item.title,
			name: item.name[i],
			lang: '中文',
			school: item.school,
			abstract: item.abstract,
			year: year,
			juan: juan,
			vol: vol,
			keyType: '关键词',
			paperName: '焊接学报',
			keywords: item.keywords,
			start: item.start,
			end: item.end,
		});
	}
});

</code></pre>
<p>接着使用exceljs来创建工作表：</p>
<pre><code class="language-javascript">// excel处理
let workbook = new Excel.Workbook();

workbook.creator = 'xujx';

let sheet = workbook.addWorksheet('sheet 1');

sheet.columns = [
	{ header: '序号', key: 'index', width: 10 },
	{ header: '唯一标识类型', key: 'onlykey', width: 10 },
	{ header: '唯一标识', key: 'onlyid', width: 10 },
	{ header: '题名', key: 'title', width: 15 },
	{ header: '正文语种', key: 'lang', width: 10 },
	{ header: '责任者/责任者姓名', key: 'name', width: 15 },
	{ header: '责任者/责任者机构/责任机构名称', key: 'school', width: 15 },
	{ header: '摘要', key: 'abstract', width: 15 },
	{ header: '主题/主题元素类型', key: 'keyType', width: 15 },
	{ header: '主题/主题名称', key: 'keywords', width: 15 },
	{ header: '期刊名称', key: 'paperName', width: 15 },
	{ header: '出版年', key: 'year', width: 15 },
	{ header: '规范期刊URI', key: 'URI', width: 15 },
	{ header: '卷', key: 'juan', width: 15 },
	{ header: '期', key: 'vol', width: 15 },
	{ header: '起始页码', key: 'start', width: 15 },
	{ header: '结束页码', key: 'end', width: 15 },
	{ header: '收录信息/收录类别代码', key: 'typeCode', width: 15 },
];

sheet.addRows(input);

</code></pre>
<p>在这之后就合并单元格：</p>
<pre><code class="language-javascript">// 合并单元格
// 首先获取每一项的作者个数，保存在一个array中
let nameLength = [];
obj.forEach(item => {
	if (item.name.length) {
		nameLength.push(item.name.length);
	} else {
		nameLength.push(0);
	}
});

</code></pre>
<p>合并单元格从第二行开始（第一行是表头）：</p>
<pre><code class="language-javascript">for (let j = 0; j &#x3C; ret.length; j += 2) {
	sheet.mergeCells(`A${ret[j]}:A${ret[j + 1]}`);
	sheet.mergeCells(`B${ret[j]}:B${ret[j + 1]}`);
	sheet.mergeCells(`C${ret[j]}:C${ret[j + 1]}`);
	sheet.mergeCells(`D${ret[j]}:D${ret[j + 1]}`);
	sheet.mergeCells(`E${ret[j]}:E${ret[j + 1]}`);
	sheet.mergeCells(`H${ret[j]}:H${ret[j + 1]}`);
	sheet.mergeCells(`I${ret[j]}:I${ret[j + 1]}`);
	sheet.mergeCells(`J${ret[j]}:J${ret[j + 1]}`);
	sheet.mergeCells(`K${ret[j]}:K${ret[j + 1]}`);
	sheet.mergeCells(`L${ret[j]}:L${ret[j + 1]}`);
	sheet.mergeCells(`M${ret[j]}:M${ret[j + 1]}`);
	sheet.mergeCells(`N${ret[j]}:N${ret[j + 1]}`);
	sheet.mergeCells(`O${ret[j]}:O${ret[j + 1]}`);
	sheet.mergeCells(`P${ret[j]}:P${ret[j + 1]}`);
	sheet.mergeCells(`Q${ret[j]}:Q${ret[j + 1]}`);
	sheet.mergeCells(`R${ret[j]}:R${ret[j + 1]}`);
}

workbook.xlsx.writeFile('1.xlsx').then(function() {
	// done
	console.log('done');
});

</code></pre>
<p>上面的数组<code>ret</code>是这样得到的，它保存了合并单元格的起止位置。</p>
<pre><code class="language-javascript">let ret = [];
// 是从第2行开始
ret.push(2);
// 对于每一个作者长度
for (let i = 0; i &#x3C; nameLength.length; i++) {
    // 表示尾部的那个节点的位置
	let head = ret[ret.length - 1];
    // 目前数组长度为偶数，说明现在是成对的，因此需要把尾部节点的下一个数加入数组
	if (ret.length % 2 === 0) {
		ret.push(head + 1);
        // 同时，由于这一循环并没有用到nameLength数组，所以不算做循环++
    	i--;
	} else {
        // 如果是奇数，说明需要添加一个步长，来合并单元格
        // 所以需要一个作者个数-1的步长
    	ret.push(head + nameLength[i] - 1);
	}
}

</code></pre>
<p>这样就完成了99%了！</p>
<h3>未完成的部分</h3>
<ul>
<li>但是需求里面还说需要作者和作者的单位对应，这就需要把文章下载下来分析了。</li>
<li>我目前的尝试是<code>pdf2json</code>，不过并不成功，时间紧迫就开启人工智能模式 ——手动搞了一下</li>
<li>确实有点累。</li>
</ul>
<h2>源码地址</h2>
<p><a href="https://github.com/Alfxjx/CNKI-HJXB-Crawler">Github 求个star吧555</a></p>
<p><a href="https://juejin.cn/post/6844904083921305614">原文地址</a></p>
</div><div id="comments"></div></div><div class="Footer__FooterWrapper-sc-1ysspqt-0 dduiPc"><div class="my-main-font text"><span>Powerd by Next.js on gh-pages, </span><a href="http://www.anbandon.work">More in old blog</a></div><div class="Footer__IconList-sc-1ysspqt-1 iXsBAW"><a href="https://github.com/alfxjx"><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="32" height="32"><defs><style></style></defs><path d="M960 512c0 97.76-28.704 185.216-85.664 263.264-56.96 78.016-130.496 131.84-220.64 161.856-10.304 1.824-18.368.448-22.848-4.032a22.4 22.4 0 0 1-7.2-17.504v-122.88c0-37.632-10.304-65.44-30.464-82.912a409.856 409.856 0 0 0 59.616-10.368 222.752 222.752 0 0 0 54.72-22.816c18.848-10.784 34.528-23.36 47.104-38.592 12.544-15.232 22.848-35.904 30.912-61.44 8.096-25.568 12.128-54.688 12.128-87.904 0-47.072-15.232-86.976-46.208-120.16 14.368-35.456 13.024-74.912-4.48-118.848-10.752-3.616-26.432-1.344-47.072 6.272s-38.56 16.16-53.824 25.568l-21.984 13.888C587.776 285.088 550.56 280.16 512 280.16s-75.776 4.928-112.096 15.232a444.48 444.48 0 0 0-24.672-15.68c-10.336-6.272-26.464-13.888-48.896-22.432-21.952-8.96-39.008-11.232-50.24-8.064-17.024 43.936-18.368 83.424-4.032 118.848-30.496 33.632-46.176 73.536-46.176 120.608 0 33.216 4.032 62.336 12.128 87.456 8.032 25.12 18.368 45.76 30.496 61.44 12.544 15.68 28.224 28.704 47.072 39.04 18.848 10.304 37.216 17.92 54.72 22.816a409.6 409.6 0 0 0 59.648 10.368c-15.712 13.856-25.12 34.048-28.704 60.064a99.744 99.744 0 0 1-26.464 8.512 178.208 178.208 0 0 1-33.184 2.688c-13.024 0-25.568-4.032-38.144-12.544-12.544-8.512-23.296-20.64-32.256-36.32a97.472 97.472 0 0 0-28.256-30.496c-11.232-8.064-21.088-12.576-28.704-13.92l-11.648-1.792c-8.096 0-13.92.928-17.056 2.688-3.136 1.792-4.032 4.032-2.688 6.72s3.136 5.408 5.376 8.096 4.928 4.928 7.616 7.168l4.032 2.688c8.544 4.032 17.056 11.232 25.568 21.984 8.544 10.752 14.368 20.64 18.4 29.6l5.824 13.44c4.928 14.816 13.44 26.912 25.568 35.872 12.096 8.992 25.088 14.816 39.008 17.504 13.888 2.688 27.36 4.032 40.352 4.032s23.776-.448 32.288-2.24l13.472-2.24c0 14.784 0 32.288.416 52.032 0 19.744.48 30.496.48 31.392a22.624 22.624 0 0 1-7.648 17.472c-4.928 4.48-12.992 5.824-23.296 4.032-90.144-30.048-163.68-83.84-220.64-161.888C92.256 697.216 64 609.312 64 512c0-81.152 20.192-156.064 60.096-224.672s94.176-122.88 163.232-163.232C355.936 84.192 430.816 64 512 64s156.064 20.192 224.672 60.096 122.88 94.176 163.232 163.232C939.808 355.488 960 430.848 960 512"></path></svg></a><a href="https://weibo.com/u/1950371745"><svg class="icon" viewBox="0 0 1026 1024" xmlns="http://www.w3.org/2000/svg" width="32.063" height="32"><defs><style></style></defs><path d="M0 61.5zM780 577c-11-2-18-5.5-21-9.5-3-4.5-4-8-1.5-12l3-5.5c.5-.5 1.5-2 2-3 .5-1.5 2-4.5 4.5-9 2-4.5 4-9.5 5-14s2-10.5 2.5-17 .5-13.5-.5-19.5-3-12.5-6.5-20c-3.5-7-7.5-13.5-13.5-19.5-10-10-23-16.5-39.5-19.5-16-3-32.5-3-48.5-.5s-31.5 5.5-45.5 9.5c-14.5 4-26 7.5-35.5 11.5l-14 6.5c-7 2-13 3.5-18 4.5-4.5.5-8.5.5-11-.5s-4.5-2-6-3-2-3.5-1.5-7.5.5-7.5 1-10c.5-3 1.5-7.5 2.5-13.5 1.5-6 2.5-11 3-14.5 0-8.5-.5-16.5-1.5-24s-3.5-16-7-25.5-9-17-15.5-22.5c-7-5.5-15.5-10.5-26-14s-24-4.5-40.5-3-35 5.5-56 13c-25 8.5-50.5 21.5-76.5 38-26 17-48 34.5-67 52.5-19 18.5-36.5 36-52 53.5-16 17-28 31-36.5 42l-12 17c-23.5 31-41 61.5-52.5 92.5s-17 54-16 70V723c4.5 34.5 15 65.5 31.5 92.5 17 27.5 37 49.5 60 66 23.5 17 51 31 82.5 43s62 20.5 91 26 59.5 9 92 11.5c53 4.5 108 0 165-12.5s110-34.5 159-65c49-31 84-68 104-111 12-25 18.5-49 19-71s-3.5-40.5-11.5-54.5-18-26.5-30.5-37c-12.5-11-24.5-18.5-35.5-23.5-10-6-20-9.5-28.5-10.5zM452 911.5c-77.5 3.5-143.5-11.5-197.5-45s-81-76.5-81-128c0-51 27-95 80.5-132s120-57 198-61S596 555 650 584s80.5 69.5 80.5 120.5c0 51.5-27.5 98-82.5 139.5s-120 64-196 67.5zm-31.5-298c-21 2-39.5 7-56 14.5S335 644 326 654c-9.5 9.5-17 20-23.5 31s-11 22-13.5 33-4 20.5-5 29.5c-.5 9-1 16-1 21l1 8.5v4.5c0 2 .5 6.5 2 13s3.5 12.5 6 18 6.5 11.5 12.5 18 12.5 12 20.5 16c47.5 23 91.5 30 132.5 21s74-29.5 99-62c10-12 16.5-27.5 20-45 3-18 2.5-36-2-54.5s-12.5-35-24-50-28.5-26.5-51-35c-23.5-9-49.5-11-79-7.5zM382 817c-4.5.5-8.5 1-12.5.5s-7.5-1-11-2-6.5-2.5-9.5-4-6-3.5-8-6l-6-7.5c-2-2.5-3-5.5-4.5-8.5s-1.5-6.5-1.5-10c0-8 2-15.5 6.5-23s10-14 18-19.5c7.5-5.5 16-8.5 25.5-9 6.5-.5 12.5-.5 19 .5 6 1 11.5 3 15.5 5.5 4.5 2.5 8 5.5 11.5 8.5 3 3 5.5 7 7 11.5s2 9 2 14c0 8-2.5 15.5-7 22.5S416 804 408 809c-8 4-16.5 7-26 8zm91.5-77.5c-5 3.5-10 5-15.5 5-5.5-.5-9-2.5-11.5-7l-2-4.5c-.5-1.5-1-3-1-4.5V724c0-2 .5-4 1-5.5l2-4.5c.5-1.5 2-2.5 3-3l3-4.5c5.5-4.5 11.5-6 16.5-5.5s9 3.5 11.5 8.5c2 3 3 6 2.5 9.5s-1.5 7-3 10c-1.5 4.5-4 7.5-6.5 10.5zm382-225c4.5 0 8.5-1 12-3s6.5-5 8.5-8 3.5-6.5 4.5-10c.5-.5 1-2 1-3 8.5-82-20-128.5-86-140-19.5-3.5-37.5-4-54-1-5 0-9.5 1.5-13 4s-6.5 5.5-9 9.5-4 8-4 12.5c0 7 2.5 13.5 7.5 18.5s11 7.5 18.5 7.5c56-13 86 5 90.5 54 1.5 12 .5 23.5-2 34.5 0 7 2.5 13.5 7.5 18.5 4.5 3.5 10.5 6 18 6zM837 211c-31.5-7-74-5.5-127 4.5-.5 0-1.5.5-2 1l-1 2-1 1c-8 2-14.5 6.5-19.5 13.5s-7.5 14-7.5 22c0 11 3.5 19.5 11 27 7 7 16 11 26 11h3c.5 0 2.5-.5 5-1s5-1.5 8-1.5c3-.5 6-1 9-2s6-2 8.5-3S757 284 764 284s16 .5 26.5 1.5 22 4 34.5 8c12.5 4.5 25 9.5 37.5 16s25 15.5 37.5 27 23.5 24.5 33 40c18.5 42.5 22.5 83 11 122.5 0 .5 0 1.5-.5 2s-1 2.5-1.5 5.5-1.5 5.5-2 8-1.5 5.5-2 9.5-1 7.5-1 10c0 6.5 2 12 5.5 16 3.5 4.5 8 7.5 13.5 9 5.5 2 11.5 2.5 19 2.5 20 0 32-12 35.5-36.5 8.5-28 13.5-54.5 14.5-80s-.5-48-5.5-67c-4.5-19.5-11.5-37.5-21-54.5s-20-31-32.5-43c-12-12-26-22.5-41-32.5-15-9.5-29.5-17.5-43.5-23-15-5.5-29.5-10.5-44.5-14z"></path></svg></a><a href="https://juejin.cn/user/2330620383728551"><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><defs><style></style></defs><path d="M832 739.533h57.958v30.105H587.571v-30.105h48.538l-31.54-184.525-.819-4.506 4.608-.716 21.095-3.482 4.505-.717.82 4.506 32.46 189.645h49.87V510.874H571.391v-30.106h145.613V381.44H619.93v-30.106h228.556v30.106H747.52v99.328h162.918v30.106H747.622v228.659h53.453l32.461-189.543.717-4.505 4.505.717 21.095 3.481 4.608.717-.82 4.506L832 739.533zm-428.032-9.728V582.45h74.854V423.22h-30.617v129.127h-44.237V413.798H373.35v138.548h-43.52V423.219h-30.617v159.232h74.137v147.354h-43.52V602.624h-30.617V759.91H478.72V602.624h-30.618v127.18h-44.134zM148.89 582.45l-21.607 21.197-3.174 3.174-3.175-3.174L105.78 588.8l-3.379-3.277 3.38-3.277 43.11-42.393V364.237h-37.684V334.13h37.684V254.26h30.617v79.872h44.135v30.106h-44.135v145.715l25.6-25.088 3.175-3.174 3.174 3.174 15.155 14.746 3.38 3.276-3.38 3.277-47.104 46.285v65.024c0 33.178-5.12 65.024-13.824 94.413-5.325 18.022-10.547 31.13-14.745 39.629l-4.71 9.42-2.049 3.994-4.096-1.946-19.251-9.113-4.198-2.048 2.048-4.199 4.608-9.42c.716-1.332 2.252-4.813 3.993-9.319 2.97-7.475 5.94-15.974 8.704-25.497 7.885-26.932 12.698-56.013 12.698-86.016V582.45zm97.792 180.122l.921-4.506 2.15-10.24c12.8-61.645 17.511-195.584 16.999-358.605h220.672v-134.86H234.496l.102 4.71.205 10.65c.205 10.24.615 32.768.82 59.904.409 44.748.511 91.033.102 136.601-1.229 129.536-6.144 227.84-16.077 275.559l-2.15 10.24-.922 4.505 4.506.922 20.992 4.198 4.608.922zm19.865-403.456l-1.024-74.65h191.181v74.65H266.547zm634.266 31.437l3.072-3.277 14.54-15.36 3.175-3.38-3.482-3.174-121.344-109.875-3.072-1.229h-126.77l-3.073 1.229-121.241 109.875-3.482 3.175 3.174 3.379 14.541 15.36 3.072 3.277 3.38-2.97 115.2-103.014h103.833l115.2 103.014 3.277 2.97z"></path></svg></a></div></div></div><div class="Toast__StyledContainer-sc-1p228qg-0 iqCFQa"><div class="Toastify"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"[Puppeteer]我是如何做到写EXCEL时速3k行的","date":"2020-05-03T16:35:07.322Z","slug":"puppeteer-cnki","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"\u003ch2\u003e起因\u003c/h2\u003e\n\u003cp\u003e之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目\u003c/p\u003e\n\u003cp\u003e统计某某期刊的信息。\u003c/p\u003e\n\u003cp\u003e粗粗看了一下14个人的群里，有我这样延毕的~~老狗~~ 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCODING\u003c/strong\u003e!!!\u003c/p\u003e\n\u003ch2\u003e开干吧\u003c/h2\u003e\n\u003cp\u003e首先确定技术栈，因为主攻前端不懂就问，所以选择node作为主要的开发语言，加之要做的是统计文章的信息，稍微想了一下，这个需求不就是~~爬虫~~CV嘛。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epuppeteer\u003c/code\u003e是\u003ccode\u003enodejs\u003c/code\u003e中一个很好用的自动化工具，都不能说他是爬虫，因为他广泛应用于自动化测试中，可以看看\u003ca href=\"https://zhuanlan.zhihu.com/p/76237595\"\u003e这篇文章\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e借鉴一下我朋友的\u003ca href=\"http://www.weidongwei.com/blog/15?title=puppeteer%E7%88%AC%E7%9F%A5%E4%B9%8E\"\u003e这个文章\u003c/a\u003e，首先：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enpm i -S puppeteer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里因为一下众所周知的原因，下载\u003ccode\u003eChromium\u003c/code\u003e可能有点费劲，我这边之前玩\u003ccode\u003epuppeteer\u003c/code\u003e的时候就装好了，看官可以自行解决一下（搬瓦工啥的）；\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epuppeteer\u003c/code\u003e 作为一个自动化测试的库，其实就是自己在操作\u003ccode\u003eChrome\u003c/code\u003e浏览器在进行一下指令，所以使用这个编写的代码我觉得还是很直观的。\u003c/p\u003e\n\u003ch2\u003e观察需求\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e获取2014-2015年焊接学报的所有学术文章的标题，作者与单位，起止页码，摘要关键词等信息\u003c/li\u003e\n\u003cli\u003e作者需要按行分开，作者和单位需要对应上\u003c/li\u003e\n\u003cli\u003e在上面的基础上，其他行需要合并。\n\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480345-841eca98-9523-4f7b-a31c-8c0d14bf5202.png#align=left\u0026#x26;display=inline\u0026#x26;height=779\u0026#x26;margin=%5Bobject%20Object%5D\u0026#x26;originHeight=779\u0026#x26;originWidth=1440\u0026#x26;size=0\u0026#x26;status=done\u0026#x26;style=none\u0026#x26;width=1440\" alt=\"\"\u003e\n\u003ca href=\"http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD\u0026#x26;pykm=HJXB\u0026#x26;Year=\u0026#x26;Issue=\u0026#x26;Entry=\"\u003e文章列表页\u003c/a\u003e\n\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480374-000ad5f3-f718-4157-875d-9c4fd4f2134e.png#align=left\u0026#x26;display=inline\u0026#x26;height=737\u0026#x26;margin=%5Bobject%20Object%5D\u0026#x26;originHeight=737\u0026#x26;originWidth=1440\u0026#x26;size=0\u0026#x26;status=done\u0026#x26;style=none\u0026#x26;width=1440\" alt=\"\"\u003e\n\u003ca href=\"http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=HJXB201401001\u0026#x26;dbname=CJFD2014\u0026#x26;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhMFE3R2FlMkI4akFIS1N4bGlEUUZtWT0%3D%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!\"\u003e单个文章的示例\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e解决方案\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e入口是CNKI的期刊文章列表页，基于ASPX生成。\u003c/li\u003e\n\u003cli\u003e在文章列表页，就可以得到一部分信息\u003c/li\u003e\n\u003cli\u003e摘要，关键词需要进入对应的文章页面去获取\u003c/li\u003e\n\u003cli\u003e作者和单位的对应需要进入pdf查看**（未完成）**\u003c/li\u003e\n\u003cli\u003e完成抓取之后再将数据导出成excel\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以看出，信息呈现三层形式保存。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e爬取所有的首层信息\u003c/h2\u003e\n\u003cp\u003e首先一些准备工作，引入包和规定的格式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst puppeteer = require('puppeteer');\nconst url = 'https://navi.cnki.net/knavi/JournalDetail?pcode=CJFD\u0026#x26;pykm=HJXB';\n// 统一设定一个等待时间，防止操作太快被目标认出来\nconst TIME = 3000;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来就是主函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 一个立即执行的异步函数\n(async () =\u003e {\n    const browser = await puppeteer.launch({\n\t\t// headless: false, // false浏览器界面启动\n\t\tslowMo: 100, // 放慢浏览器执行速度，方便测试观察\n\t\targs: [\n\t\t\t// 启动 Chrome 的参数\n\t\t\t'–no-sandbox',\n\t\t\t// '--window-size=1280,960',\n\t\t],\n\t});\n    // 创建新页面\n    const page = await browser.newPage();\n    // 这一句就是前往目标页面\n    await page.goto(url, {\n\t\t// 网络空闲说明已加载完毕\n\t\twaitUntil: 'networkidle2',\n\t});\n\tconsole.log('page加载完成！');\n})()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e经过上面的描述可以看出，\u003ccode\u003epuppeteer\u003c/code\u003e和\u003ccode\u003eElectron\u003c/code\u003e等有点类似，都是主进程中创建子进程进行操作。\u003c/p\u003e\n\u003cp\u003e接着就是在列表页选择对应的年份和期数，并且循环执行。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epuppeteer\u003c/code\u003e意为\u003cstrong\u003e提线木偶\u003c/strong\u003e，所以想让浏览器做什么就发出对应的指令即可：\u003c/p\u003e\n\u003cp\u003e首先是用到的两个\u003ccode\u003eutil\u003c/code\u003e函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 因为网页上年份的按钮的id是数字开头，直接S()会出错\n// 所以需要把它转换成Unicode\nfunction getID(year) {\n\tlet num = year - 2010;\n\treturn `#\\\\0032\\\\0030\\\\0031\\\\003${num}\\\\005f\\\\0059\\\\0065\\\\0061\\\\0072\\\\005f\\\\0049\\\\0073\\\\0073\\\\0075\\\\0065`;\n}\n\n// 选择某一年某一期的id\nfunction getNoDotID(year, num) {\n\tlet _num = num \u0026#x3C; 10 ? `0${num}` : `${num}`;\n\treturn `#yq${year}${_num}`;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 选择2014年，对每一期进行点击\n// 年份点击事件\nlet yearNum = 2014;\nconst yearBtn = await page.$(getID(yearNum));\nawait yearBtn.click();\nawait page.waitFor(TIME);\nlet accNum = 1;\n// 输出的结果，是一个二维数组。\nlet output = [];\n// 从第一期开始，一个月一期\nwhile (accNum \u0026#x3C; 13) {\n    // 循环选择第几期\n    let NoDot = await page.$(getNoDotID(yearNum, accNum));\n    NoDot.click();\n\n    // 保存所有的信息\n    await page.waitFor(TIME);\n\n    console.log('选择列表...' + accNum);\n    const list = await page.$('#CataLogContent');\n    const items = await list.?('dd');\n\n    const res = await page.evaluate(list =\u003e {\n        // ...\n    }, list);\n    output.push(res);\n    accNum++;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epage.$(), page.?()\u003c/code\u003e类似于\u003ccode\u003edocument.querySelector/querySelectorAll\u003c/code\u003e，返回一个节点元素\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epage.evaluate(function,node)\u003c/code\u003e 是对上面选择到的对应的node节点进行浏览器内操作的方法，在function中实现。，function接受node作为参数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在\u003ccode\u003epage.evaluate\u003c/code\u003e的内部，我们将文章的信息（标题，起止页码等）以及链接提取出来保存起来。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst res = await page.evaluate(list =\u003e {\n    // 在这里就可以使用browser的对象啦\n    const itemList = list.querySelectorAll('dd');\n    let arr = [];\n    // console.log(itemList);\n    for (let item of itemList) {\n        // 这里是发现cnki是基于aspx的网页\n        // 并且跳转到对应的页面是有规律的，和filename之后的id有关\n        // 另外，不同的年份有不同的数据库\n        const getPaperId = function(id) {\n            let match = /filename=(\\w+)\u0026#x26;/i.exec(id);\n            return match[1];\n        }\n        let paperID = item.querySelector('.opts \u003e .btn-view \u003ea').href;\n        let id = getPaperId(paperID);\n        // 最后将2014年某一条的innerText和id保存成一个字符串，留着之后解析\n        let content = item.innerText + '\u0026#x26;' +id;\n        arr.push(content);\n    }\n    return arr;\n}, list);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样运行一下\u003ccode\u003enpm start\u003c/code\u003e，得到的数据就log出来了。目前我就是直接复制了一下，当然也有其他的办法。\u003c/p\u003e\n\u003cp\u003e最终得到的\u003ccode\u003edata.txt\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e[\n    [\"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\\n樊丁;蒋锴;余淑荣;张健;\\n1-4+113\u0026#x26;HJXB201401001\",\"铝合金超声-MIG焊接电弧行为\\n范成磊;谢伟峰;杨春利;寇毅;\\n5-8+113\u0026#x26;HJXB201401002\",...],\n     ...\n ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e爬取摘要，关键词等信息\u003c/h2\u003e\n\u003cp\u003e目前是有了部分信息，但是摘要和关键词还需要在第二层里面获取;\u003c/p\u003e\n\u003ch3\u003e对数据进行一些预处理\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enpm run analysis\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这一部分就是对上面得到的list进行处理，首先把2维数组拍平：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst out2014S = require('./output2014');\nconst out2015S = require('./output2015');\nconst fs = require('fs');\n\n// 获取引用\nlet out2014 = out2014S;\nlet out2015 = out2015S;\n// flat\nwhile (out2014.some(Array.isArray)) {\n\tout2014 = [].concat(...out2014);\n}\n\nwhile (out2015.some(Array.isArray)) {\n\tout2015 = [].concat(...out2015);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e目前得到的数据示例如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\\n樊丁;蒋锴;余淑荣;张健;\\n1-4+113\u0026#x26;HJXB201401001\",\n    ...\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e需要对这个进行分析，自定义一个split函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction SecondeSplit(arr, year) {\n    // 数据序列化一下，保存下\\n用于分割\n\tlet str = JSON.stringify(arr);\n\tconsole.log('str' + str);\n\tlet nArr = str.split('\\\\n');\n\tconsole.log('nArr' + nArr);\n\t// 0 title\n\t// 1 string authors\n\t// 2 pages and link\n\tlet res = {};\n    // clean\n\tres.title = nArr[0].replace(/\\\"/i, '');\n\tlet names = nArr[1].split(';');\n\tres.name = names.slice(0, names.length - 1);\n    // 存在有的文章没有页码和链接等问题\n\tif (nArr[2]) {\n\t\tlet linkArr = nArr[2].split('\u0026#x26;');\n        // clean\n\t\tlet link = linkArr[1].replace(/\\\"/i, '');\n        // 两年的dbname稍有不同\n\t\tif (year === 2014) {\n\t\t\tres.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=${link}\u0026#x26;dbname=CJFD2014`;\n\t\t}\n\t\tif (year === 2015) {\n\t\t\tres.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=${link}\u0026#x26;dbname=CJFDLAST2015`;\n\t\t}\n\t\tlet pages = linkArr[0].split('+');\n\t\tlet pageArr = pages[0].split('-');\n\t\tres.start = pageArr[0];\n\t\tres.end = pageArr[1];\n\t}\n\treturn res;\n}\n\n// 对两年的数据进行操作\nlet ret2014 = [];\nout2014.forEach(i =\u003e {\n\tlet tmp = SecondeSplit(i, 2014);\n\tret2014.push(tmp);\n});\n// ... 2015一样\n\nlet ret = ret2014.concat(ret2015);\n\nlet jsonObj = {};\njsonObj.data = ret;\n// \\t能够保存一个比较美观的json\nlet wObj = JSON.stringify(jsonObj, '', '\\t');\nfs.writeFile('data.json', wObj, err =\u003e {\n\tconsole.log(err);\n});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e爬取摘要等\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enpm run abstract\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这里的主要思路就是继续操作\u003ccode\u003epuppeteer\u003c/code\u003e，对每一个链接，获取对应摘要，学校和关键词信息\u003c/p\u003e\n\u003cp\u003e这里的\u003ccode\u003epuppeteer\u003c/code\u003e并没有用基于\u003ccode\u003easync\u003c/code\u003e的写法，用\u003ccode\u003ethen\u003c/code\u003e也很方便。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst obj = require('../data1.json');\nconst fs = require('fs');\nconst puppeteer = require('puppeteer');\n// 因为要对obj操作\nlet data = obj;\nconst len = data.data.length;\npuppeteer\n\t.launch({\n\t\theadless: true,\n\t})\n\t.then(async browser =\u003e {\n\t\tfor (let i = 0; i \u0026#x3C; len; i++) {\n\t\t\tif (data.data[i].link) {\n\t\t\t\tconst res = await getAbstract(i, data.data[i].link, browser);\n                // 这里就用keyword来判断是否抓取成功了\n\t\t\t\tconsole.log(i + ': ' + res.keywords);\n\t\t\t\tdata.data[i].abstract = res.abstract;\n\t\t\t\tdata.data[i].school = res.school;\n\t\t\t\tdata.data[i].keywords = res.keywords;\n\t\t\t}\n\t\t}\n\t})\n\t.then(() =\u003e {\n\t\tconsole.log('获取信息完成！');\n\t\t// console.log(data.data[0].abstract);\n    \t// 保存到data1.json\n\t\tsave(data);\n\t});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetAbstract\u003c/code\u003e是一个获取摘要的函数，需要传browser实例，链接和序号：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function getAbstract(num, link, browser) {\n\tconst page = await browser.newPage();\n\tawait page.goto(link);\n\tawait page.waitFor(3000);\n    // 摘要\n\tlet abs = await page.$('#ChDivSummary');\n\tlet abstract = await page.evaluate(abs =\u003e {\n\t\treturn abs.innerText;\n\t}, abs);\n    // 学校\n\tlet schoolDOM = await page.$('.orgn');\n\tlet school = await page.evaluate(schoolDOM =\u003e {\n\t\tlet arr = schoolDOM.querySelectorAll('span \u003e a');\n\t\tlet res = '';\n\t\tarr.forEach(i =\u003e {\n\t\t\tres += i.text + ',';\n\t\t});\n        // 拼接为字符串后就删掉最后一个逗号\n\t\treturn res.slice(0, res.length - 1);\n\t}, schoolDOM);\n    // 关键词\n\tlet keysDOM = await page.$('#catalog_KEYWORD');\n\tlet keys = await page.evaluate(keysDOM =\u003e {\n    // let arr = keysDOM.querySelectorAll('p')[2].querySelectorAll('a');\n    // 上面的写法并不好，因为有的挂了基金有的没挂，所以不一定是第三个\n    // 发现关键词里面一个dom是有id的\n    // 所以选用了兄弟节点的方法。\n    let arr = keysDOM.parentNode.children;\n    let res = '';\n    for(let j=1;j\u0026#x3C;arr.length;j++){\n      res += arr[j].text.replace(/ /g, '').replace(/\\n/g, '');\n    }\n\t\treturn res;\n\t}, keysDOM);\n\tawait page.waitFor(3000);\n    // 节省内存，每次查询完就关闭页面\n\tawait page.close();\n\treturn {\n\t\tabstract: abstract,\n\t\tschool: school,\n\t\tkeywords: keys,\n\t};\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就得到了完整的数据：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n\t\"data\": [\n\t\t{\n\t\t\t\"title\": \"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\",\n\t\t\t\"name\": [\n\t\t\t\t\"樊丁\",\n\t\t\t\t\"蒋锴\",\n\t\t\t\t\"余淑荣\",\n\t\t\t\t\"张健\"\n\t\t\t],\n\t\t\t\"link\": \"http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD\u0026#x26;filename=HJXB201401001\u0026#x26;dbname=CJFD2014\",\n\t\t\t\"start\": \"1\",\n\t\t\t\"end\": \"4\",\n\t\t\t\"abstract\": \"以5052铝合金和热镀锌ST04Z钢为研究对象,采用预置涂粉CO2激光搭接熔钎焊方法进行工艺试验.利用光学显微镜、扫描电镜和拉伸试验机对熔钎焊接头的微观组织和力学性能进行了研究.结果表明,涂助溶剂和粉末后,焊缝成形明显改善,镀锌层没有烧损;熔—钎焊接头过渡层最大厚度小于10μm,针状Al-Fe金属间化合物没有向熔化的铝侧明显析出;接头具有较高的力学性能,最大机械抗载能力可达到208 MPa,约为5052铝合金母材抗拉强度的95.41%. \",\n\t\t\t\"school\": \"兰州理工大学甘肃省有色金属新材料省部共建国家重点实验室,兰州理工大学有色金属合金及加工教育部重点实验室\",\n\t\t\t\"keywords\": \"铝钢;激光焊接;熔钎焊;粉末;\"\n\t\t},\n        ...\n    ]\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e将数据导出到EXCEL\u003c/h2\u003e\n\u003cp\u003e这里就是将数据导出啦，需求里面写的还是很明白的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480515-8d1e0e12-02a0-40ca-90ca-173fbd56336f.png#align=left\u0026#x26;display=inline\u0026#x26;height=362\u0026#x26;margin=%5Bobject%20Object%5D\u0026#x26;originHeight=362\u0026#x26;originWidth=1492\u0026#x26;size=0\u0026#x26;status=done\u0026#x26;style=none\u0026#x26;width=1492\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e我的想法就是根据每一个item的作者list的长度，首先是写出若干行，然后再将除了作者和单位之外的行进行合并。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst Excel = require('exceljs');\nconst data = require('../data1.json');\n\n// 数据预处理\nlet input = [];\nlet obj = data.data;\nobj.forEach((item, index) =\u003e {\n\tlet len = item.name.length;\n\n\tlet link = item.link;\n\tlet reg = /HJXB201(4|5)([0-9]{2})/i;\n\n\tlet year = -1;\n\tlet juan = -1;\n\tlet vol = -1;\n\tif (link) {\n\t\tyear = link.substring(link.length - 4, link.length);\n        // 2014年是35卷，2015=36卷\n\t\tjuan = year == 2014 ? 35 : 36;\n        // 期数在链接里面就可以查出，是第二个匹配项\n\t\tvol = reg.exec(link)[2];\n\t}\n\n\tfor (let i = 0; i \u0026#x3C; len; i++) {\n        // 将数据整理成exceljs需要的样子\n\t\tinput.push({\n\t\t\tindex: index + 1,\n\t\t\ttitle: item.title,\n\t\t\tname: item.name[i],\n\t\t\tlang: '中文',\n\t\t\tschool: item.school,\n\t\t\tabstract: item.abstract,\n\t\t\tyear: year,\n\t\t\tjuan: juan,\n\t\t\tvol: vol,\n\t\t\tkeyType: '关键词',\n\t\t\tpaperName: '焊接学报',\n\t\t\tkeywords: item.keywords,\n\t\t\tstart: item.start,\n\t\t\tend: item.end,\n\t\t});\n\t}\n});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接着使用exceljs来创建工作表：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// excel处理\nlet workbook = new Excel.Workbook();\n\nworkbook.creator = 'xujx';\n\nlet sheet = workbook.addWorksheet('sheet 1');\n\nsheet.columns = [\n\t{ header: '序号', key: 'index', width: 10 },\n\t{ header: '唯一标识类型', key: 'onlykey', width: 10 },\n\t{ header: '唯一标识', key: 'onlyid', width: 10 },\n\t{ header: '题名', key: 'title', width: 15 },\n\t{ header: '正文语种', key: 'lang', width: 10 },\n\t{ header: '责任者/责任者姓名', key: 'name', width: 15 },\n\t{ header: '责任者/责任者机构/责任机构名称', key: 'school', width: 15 },\n\t{ header: '摘要', key: 'abstract', width: 15 },\n\t{ header: '主题/主题元素类型', key: 'keyType', width: 15 },\n\t{ header: '主题/主题名称', key: 'keywords', width: 15 },\n\t{ header: '期刊名称', key: 'paperName', width: 15 },\n\t{ header: '出版年', key: 'year', width: 15 },\n\t{ header: '规范期刊URI', key: 'URI', width: 15 },\n\t{ header: '卷', key: 'juan', width: 15 },\n\t{ header: '期', key: 'vol', width: 15 },\n\t{ header: '起始页码', key: 'start', width: 15 },\n\t{ header: '结束页码', key: 'end', width: 15 },\n\t{ header: '收录信息/收录类别代码', key: 'typeCode', width: 15 },\n];\n\nsheet.addRows(input);\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这之后就合并单元格：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 合并单元格\n// 首先获取每一项的作者个数，保存在一个array中\nlet nameLength = [];\nobj.forEach(item =\u003e {\n\tif (item.name.length) {\n\t\tnameLength.push(item.name.length);\n\t} else {\n\t\tnameLength.push(0);\n\t}\n});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e合并单元格从第二行开始（第一行是表头）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efor (let j = 0; j \u0026#x3C; ret.length; j += 2) {\n\tsheet.mergeCells(`A${ret[j]}:A${ret[j + 1]}`);\n\tsheet.mergeCells(`B${ret[j]}:B${ret[j + 1]}`);\n\tsheet.mergeCells(`C${ret[j]}:C${ret[j + 1]}`);\n\tsheet.mergeCells(`D${ret[j]}:D${ret[j + 1]}`);\n\tsheet.mergeCells(`E${ret[j]}:E${ret[j + 1]}`);\n\tsheet.mergeCells(`H${ret[j]}:H${ret[j + 1]}`);\n\tsheet.mergeCells(`I${ret[j]}:I${ret[j + 1]}`);\n\tsheet.mergeCells(`J${ret[j]}:J${ret[j + 1]}`);\n\tsheet.mergeCells(`K${ret[j]}:K${ret[j + 1]}`);\n\tsheet.mergeCells(`L${ret[j]}:L${ret[j + 1]}`);\n\tsheet.mergeCells(`M${ret[j]}:M${ret[j + 1]}`);\n\tsheet.mergeCells(`N${ret[j]}:N${ret[j + 1]}`);\n\tsheet.mergeCells(`O${ret[j]}:O${ret[j + 1]}`);\n\tsheet.mergeCells(`P${ret[j]}:P${ret[j + 1]}`);\n\tsheet.mergeCells(`Q${ret[j]}:Q${ret[j + 1]}`);\n\tsheet.mergeCells(`R${ret[j]}:R${ret[j + 1]}`);\n}\n\nworkbook.xlsx.writeFile('1.xlsx').then(function() {\n\t// done\n\tconsole.log('done');\n});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的数组\u003ccode\u003eret\u003c/code\u003e是这样得到的，它保存了合并单元格的起止位置。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elet ret = [];\n// 是从第2行开始\nret.push(2);\n// 对于每一个作者长度\nfor (let i = 0; i \u0026#x3C; nameLength.length; i++) {\n    // 表示尾部的那个节点的位置\n\tlet head = ret[ret.length - 1];\n    // 目前数组长度为偶数，说明现在是成对的，因此需要把尾部节点的下一个数加入数组\n\tif (ret.length % 2 === 0) {\n\t\tret.push(head + 1);\n        // 同时，由于这一循环并没有用到nameLength数组，所以不算做循环++\n    \ti--;\n\t} else {\n        // 如果是奇数，说明需要添加一个步长，来合并单元格\n        // 所以需要一个作者个数-1的步长\n    \tret.push(head + nameLength[i] - 1);\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就完成了99%了！\u003c/p\u003e\n\u003ch3\u003e未完成的部分\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e但是需求里面还说需要作者和作者的单位对应，这就需要把文章下载下来分析了。\u003c/li\u003e\n\u003cli\u003e我目前的尝试是\u003ccode\u003epdf2json\u003c/code\u003e，不过并不成功，时间紧迫就开启人工智能模式 ——手动搞了一下\u003c/li\u003e\n\u003cli\u003e确实有点累。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e源码地址\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Alfxjx/CNKI-HJXB-Crawler\"\u003eGithub 求个star吧555\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://juejin.cn/post/6844904083921305614\"\u003e原文地址\u003c/a\u003e\u003c/p\u003e\n","coverImage":"/assets/blog/puppeteer.jfif"}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"puppeteer-cnki"},"buildId":"vAXKNB2ztkDyOXgsMiReF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>