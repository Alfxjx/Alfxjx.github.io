<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2649b9740f492fab27ec.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2649b9740f492fab27ec.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8fa755d3830e88407993.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8fa755d3830e88407993.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-fb76148cfcfb42ca18eb.js" defer=""></script><script src="/_next/static/chunks/framework-6c6eb080c4d41d8fd79b.js" defer=""></script><script src="/_next/static/chunks/main-4fc50673e5500481d568.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4763a060e35e3213dba8.js" defer=""></script><script src="/_next/static/chunks/35-6549e75a8f594562e7e3.js" defer=""></script><script src="/_next/static/chunks/180-c61bb7e24e885f1dcc67.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-53ae0e5ed6860e2ab9aa.js" defer=""></script><script src="/_next/static/Ehk_RCBKDfsxeu7pxJYZH/_buildManifest.js" defer=""></script><script src="/_next/static/Ehk_RCBKDfsxeu7pxJYZH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Post__Wrapper-sc-q8sq7-0 ikfRfU"><div class="ProgressBar__FixedTopWrapper-sc-1ufpd9c-0 ProgressBar__ProgressBarWrapperFixed-sc-1ufpd9c-1 lmAxqe fSwpDk"><div class="bar-used"></div></div><div class="header"><div class="icon-wrapper"><div class="icons"><svg class="arrow_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8c-14.7 12.8-14.7 35.6 0 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"></path></svg></div><div class="icons"><a href="/tech"><svg class="code_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="m541.141 268.864 61.718 16.939-132.395 482.474-61.717-16.938L541.14 268.864zm-212.138 29.803 44.885 45.61-175.36 172.587 175.04 167.573-44.267 46.23-222.634-213.163 222.336-218.837zm355.882 0 222.336 218.837-222.634 213.163-44.267-46.23 175.019-167.573L640 344.277l44.885-45.61z"></path></svg></a></div></div></div><div class="toggle"><button class="Button__InsideButton-sc-19071w6-0 cEJOXC"><div class="LightDarkSwitcher__Switcher-sc-hbms9j-0 irISBV"><svg class="sun_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M448 64v195.2a224.832 224.832 0 0 0-100.992 42.24L208.512 163.2l-45.248 45.312 138.24 138.496A218.624 218.624 0 0 0 259.008 448H64v64h195.008c5.504 37.76 20.48 72 42.496 100.992l-138.24 138.496 45.248 45.248L347.008 658.24C376 680 410.496 695.232 448 700.736V896h64V700.8a222.4 222.4 0 0 0 100.992-42.56l138.496 138.496 45.248-45.248L658.24 612.992A216.32 216.32 0 0 0 700.992 512H896v-64H700.992a216.32 216.32 0 0 0-42.752-100.992l138.496-138.496-45.248-45.248-138.496 138.24A224.832 224.832 0 0 0 512 259.2V64zm32 256c88.768 0 160 71.232 160 160s-71.232 160-160 160a159.488 159.488 0 0 1-160-160c0-88.768 71.232-160 160-160z"></path></svg></div></button></div><div style="height:3.25rem"></div><div class="Post-sc-1u8x57o-0 Post__PostWrapper-sc-q8sq7-1 bzjUit hPLIeh"><div class="info"><h1>如何设计一个好用的组件-以chakra-ui为例</h1><div class="user"><img class="img" src="/assets/authors/alfxjx.jpg" alt="Alfxjx"/><span class="title">Alfxjx</span><div class="date">2021-10-28</div></div></div><div class="post"><blockquote>
<p>同时发布于 <a href="https://www.yuque.com/alfxjx/notes/wchz9f">语雀</a></p>
</blockquote>
<h2>引子</h2>
<p>最近公司在搭建部门的统一平台，我负责了统一登录前端的开发，因为要对接很多的系统，所以开发了统一登录的sdk，说是sdk其实就是一个组件库。以此为契机，外加之前开发其他的系统中也用了很多种不同的组件库（饿了没-ui/vant/antd/chakra-ui...），今天写一篇文章说说，什么样的组件设计是比较合理的，以及如何设计一个好用的组件。</p>
<h2>研究chakra-ui</h2>
<p><img src="/assets/blog/chakra-ui.png" alt=""></p>
<p>比较来说我觉得设计比较有特色的一个组件库，就是 <a href="https://chakra-ui.com/">chakra-ui</a> 了，不过国内使用的并不多，我也是在之前技术选型的时候偶然找到的，但是仔细读了她的文档之后我发现这个是一个很有特色的组件库，下面细说：</p>
<h3>样式自定义</h3>
<p>找到这个 chakra-ui 的时候，就是因为需要在使用 tailwind CSS 的同时使用一个组件库，chakra-ui 的一个特色就是使用了和 tailwind CSS 几乎相同的样式 api , 例如：</p>
<pre><code>import { Box } from "@chakra-ui/react"

// m={2} refers to the value of `theme.space[2]`
&#x3C;Box m={2}>Tomato&#x3C;/Box>

// You can also use custom values
&#x3C;Box maxW="960px" mx="auto" />

// sets margin `8px` on all viewports and `16px` from the first breakpoint and up
&#x3C;Box m={[2, 3]} />
</code></pre>
<p>这样只要你记住了 tailwind CSS 的api， 那么就可以很快的上手 chakra-ui 。
那么这个是怎么实现的呢？
一开始我以为是组件库使用了tailwind CSS ，但是看了源码发现，chakra 将 styled-components 进行了二次封装，而这种 tailwindLike 的 api 是进行了模拟导致的。
在 <a href="https://github.com/chakra-ui/chakra-ui/blob/main/packages/styled-system/src/config/background.ts">/packages/styled-system/config/</a> 里面 写入了不同样式以及缩写，以 background 为例：</p>
<pre><code>export const background: Config = {
  background: t.colors("background"),
  ...
  bg: t.colors("background"),
  ...
}
</code></pre>
<p>这样实现的，可以说把dirty的工作封装了起来，展示出来的结果都是好用的。</p>
<h3>组件组合</h3>
<p>书接上文，组件里面做了很多的映射封装，为了减少代码量，统一进行管理，组件库进行了组件的组合（compose）。从一个基本的组件出发，通过默认一些样式，创造了一些新的组件。
例如<a href="https://chakra-ui.com/docs/layout/center#square-and-circle"> Square Circle </a>组件，是基于 Box 组件extend而来的。</p>
<pre><code>export const Square = forwardRef&#x3C;SquareProps, "div">((props, ref) => {
  const { size, centerContent = true, ...rest } = props

  const styles: SystemStyleObject = centerContent
    ? { display: "flex", alignItems: "center", justifyContent: "center" }
    : {}

  return (
    &#x3C;Box
      ref={ref}
      boxSize={size}
      __css={{
        ...styles,
        flexShrink: 0,
        flexGrow: 0,
      }}
      {...rest}
    />
  )
})

if (__DEV__) {
  Square.displayName = "Square"
}

export const Circle = forwardRef&#x3C;SquareProps, "div">((props, ref) => {
  const { size, ...rest } = props
  return &#x3C;Square size={size} ref={ref} borderRadius="9999px" {...rest} />
})

if (__DEV__) {
  Circle.displayName = "Circle"
}
</code></pre>
<p>这样写减少了重复的代码并且可以保持更好的可维护性。我们在开发的过程中也可以借鉴这种模式，开发出最抽象的组件，从这个最抽象的父类出发来进行派生。</p>
<h3>Theminig</h3>
<p>chakra ui 的另外一个特点就是拥有一个高度自定义的主题系统， 使用的方式类似于 tailwind CSS <a href="https://tailwindcss.com/docs/theme">设置</a>，也就是说你可同时将一个theme文件应用到两个库中，使用方法可以看一下<a href="https://chakra-ui.com/docs/theming/customize-theme">chakra文档</a>，那么这个主题是如何实现的呢？
首先 chakra ui 维护了一个default theme ,用于在没有自定义 theme 或者 自定义了一部分的theme的时候进行合并，合并的过程（<code>toCSSVar</code>）是使用了 <code>createThemeVars</code> 方法将自己配置的theme转化成css var变量，然后将默认的theme和生成的theme进行合并。最后在 :</p>
<pre><code>
export const ThemeProvider = (props: ThemeProviderProps) => {
  const { cssVarsRoot = ":host, :root", theme, children } = props
  const computedTheme = React.useMemo(() => toCSSVar(theme), [theme])
  return (
    &#x3C;EmotionThemeProvider theme={computedTheme}>
      &#x3C;Global styles={(theme: any) => ({ [cssVarsRoot]: theme.__cssVars })} />
      {children}
    &#x3C;/EmotionThemeProvider>
  )
}
</code></pre>
<p>这里是借用了 emotion 的 <a href="https://emotion.sh/docs/theming#themeprovider-reactcomponenttype">ThemeProvider</a>。这么一看其实主题设置还是很简单的。这样可以很方便的设置了一个自定义的主题
除此之外，如果想在二次开发的主题上进行三次开发，可以使用 chakra-ui 提供的api <a href="https://chakra-ui.com/docs/theming/customize-theme#using-theme-extensions">Theme extensions</a>。提供了一个类似于 HOC 的包裹函数，以withDefaultColorScheme为例：</p>
<pre><code>export function withDefaultColorScheme({colorScheme,components}): ThemeExtension {
  return (theme) => {
    let names = Object.keys(theme.components || {})
		// ....
    return mergeThemeOverride(theme, {
      components: Object.fromEntries(
        names.map((componentName) => {
          const withColorScheme = {
            defaultProps: {
              colorScheme,
            },
          }
          return [componentName, withColorScheme]
        }),
      ),
    })
  }
}
</code></pre>
<p>将配置的颜色Scheme赋值给了配置的对应的组件。内部实现大同小异，都是调用了 <code>mergeThemeOverride</code>这个方法</p>
<pre><code>export function mergeThemeOverride&#x3C;BaseTheme extends ChakraTheme = ChakraTheme>(
  ...overrides: ThemeOverride&#x3C;BaseTheme>[]
): ThemeOverride&#x3C;BaseTheme> {
  return mergeWith({}, ...overrides, mergeThemeCustomizer)
}
</code></pre>
<p>内部使用了 <code>lodash.mergewith</code>的方法实现融合，对于此方法 chakra-ui 写了一个mergeThemeCustomizer 作为 <a href="https://www.lodashjs.com/docs/lodash.mergeWith/">lodash.mergwith</a> 的第三个参数，这里的自定义mergeThemeCustomizer方法使用了递归的方式进行merge。</p>
<pre><code>
function mergeThemeCustomizer(
  source: unknown,
  override: unknown,
  key: string,
  object: any,
) {
  if (
    (isFunction(source) || isFunction(override)) &#x26;&#x26;
    Object.prototype.hasOwnProperty.call(object, key)
  ) {
    return (...args: unknown[]) => {
      const sourceValue = isFunction(source) ? source(...args) : source

      const overrideValue = isFunction(override) ? override(...args) : override

      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer)
    }
  }

  // fallback to default behaviour
  return undefined
}
</code></pre>
<h3>外部组件与二次封装</h3>
<p>从上面可以看到，组件库也不是全部从零开始，也使用了很多第三方的库，例如样式库 emotion， styled-components，工具方法库 lodash，这里没啥特别好说的。
另外chakra-ui官方也推荐将组件库和许多第三方的lib一起使用，例如 表单验证库<a href="https://chakra-ui.com/docs/form/form-control#usage-with-form-libraries">formik</a>，此外，在element-ui中也会直接封装throttle-debounce， async-validator等第三方的库。</p>
<h3>提供escape</h3>
<p>在使用其他的组件库的时候，很多情况下会出现某些组件的细节和设计要求不一致的情况，对于element-ui和ant design来说，由于使用了sass/less等预处理器，可以使用覆盖的方式来覆写样式。在 chakra ui 中，则提供了一个 <a href="https://chakra-ui.com/docs/features/the-sx-prop">sx Props</a> 来直接向组件传入样式。</p>
<pre><code>&#x3C;Box sx={{ "--my-color": "#53c8c4" }}>
  &#x3C;Heading color="var(--my-color)" size="lg">
    This uses CSS Custom Properties!
  &#x3C;/Heading>
&#x3C;/Box>
</code></pre>
<p>这个方式很强大，还支持嵌套样式，media query等。这里的sx是一个封装自@emotion/styled的方法，在 <a href="https://github.com/chakra-ui/chakra-ui/blob/main/packages/system/src/system.ts">packages/system/src/system.ts</a>, styled方法里面调用了 toCSSObject ，这里拿取到了输入的样式，而所有的ui 组件都会调用这个 styled方法，sx Props 就这样全局生效了。</p>
<pre><code>export function styled&#x3C;T extends As, P = {}>(
  component: T,
  options?: StyledOptions,
) {
  const { baseStyle, ...styledOptions } = options ?? {}
	// ...
  const styleObject = toCSSObject({ baseStyle })
  return _styled(
    component as React.ComponentType&#x3C;any>,
    styledOptions,
  )(styleObject) as ChakraComponent&#x3C;T, P>
}

export const toCSSObject: GetStyleObject = ({ baseStyle }) => (props) => {
  const { theme, css: cssProp, __css, sx, ...rest } = props
  const styleProps = objectFilter(rest, (_, prop) => isStyleProp(prop))
  const finalBaseStyle = runIfFn(baseStyle, props)
  const finalStyles = Object.assign({}, __css, finalBaseStyle, styleProps, sx)
  const computedCSS = css(finalStyles)(props.theme)
  return cssProp ? [computedCSS, cssProp] : computedCSS
}
</code></pre>
<h2>如何设计一个好用的组件</h2>
<p>参考了很多设计，那么如何设计一个好用的组件呢，这里以一个progressBar为例。</p>
<h3>MVP 版本以及存在的问题</h3>
<pre><code>import React, { useState, useEffect } from "react";
import styled from "styled-components";

const ProgressBarWrapper = styled.div&#x3C;{ progress: number }>`
	width: 100%;
	height: 4px;
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	z-index: 9999;
	.bar-used {
		background: #34c;
		width: ${({ progress }) => progress + "%"};
		height: 100%;
		border-radius: 0 2px 2px 0;
	}
`;

const ProgressBar = () => {
	const [progress, setProgress] = useState(0);
	useEffect(() => {
		window.addEventListener("scroll", () => {
			setProgress(
				(document.documentElement.scrollTop /
					(document.body.scrollHeight - window.innerHeight)) *
					100
			);
		});
		return () => {
			window.removeEventListener("scroll", () => {});
		};
	});
	return (
		&#x3C;ProgressBarWrapper progress={progress}>
			&#x3C;div className='bar-used'>&#x3C;/div>
		&#x3C;/ProgressBarWrapper>
	);
};

export { ProgressBar };

</code></pre>
<p>这里展示了一个页面顶部进度条的组件，类似于 <a href="https://es6.ruanyifeng.com/#docs/decorator">es6标准入门</a> 这里的样式，上面的功能可以很快的就实现出来，但是只是比较符合单一的应用场景，进度条固定在顶部，只有从左往右增长一种情况。但是实际上的进度条可能会用到很多的地方，因此我们需要对照可能的场景以及代码中的变量进行判断，哪些是需要做成参数，并设置对应的默认值。
需求有以下几种：</p>
<ol>
<li>颜色可调，位置可调，方向可调，这三个是比较全局的可调整类型</li>
<li>具体样式修改，高度修改，圆角修改，这些是其他的一些props，如果保持progressbar的功能不变可能不太会用到的props</li>
</ol>
<p>此外，这里的progeressBar还存在的一个问题就是，这个组件将展示和逻辑杂糅在了一起，组件内部就有对于页面滚动进度的计算逻辑（useEffect），但是如果使用的时候不需要这个逻辑呢？
根据上面的一些要修改的点以及一些问题，我们来对这个组件进行拆分和重构。</p>
<h3>重构</h3>
<p>首先是把逻辑和展示分开。新建一个hook用于计算百分比。</p>
<pre><code>import { useState, useEffect } from "react";

export function useProgress() {
	const [progress, setProgress] = useState(0);
	useEffect(() => {
		window.addEventListener("scroll", () => {
			setProgress(
				(document.documentElement.scrollTop /
					(document.body.scrollHeight - window.innerHeight)) *
					100
			);
		});
		return () => {
			window.removeEventListener("scroll", () => {});
		};
	});
	return progress;
}

</code></pre>
<p>之后是给需要的参数添加props,并设置默认值，这里只以高度为例，设置一个可选的高度参数，当传入的时候就使用传入的值否则是默认的。
同时注意颜色等可以使用一个theme系统。</p>
<pre><code>
const ProgressBarWrapper = styled.div&#x3C;{ progress: number; height?: string }>`
	width: 100%;
	height: ${({ height }) => (height ? height : "4px")};
	.bar-used {
		background: ${({ theme }) => theme.themeColor};
		width: ${({ progress }) => progress + "%"};
		height: 100%;
		border-radius: ${({ height }) =>
			height ? `0 calc( ${height}/ 2) calc(${height}/ 2) 0` : "0 2px 2px 0"};
	}
`;
</code></pre>
<p>除此之外，将fixed布局抽象出来，方便后面进行组合</p>
<pre><code>const FixedTopWrapper = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	z-index: 9999;
`;
// 组合之后就是这样的
const ProgressBarWrapperFixed = styled(FixedTopWrapper)&#x3C;{
	progress: number;
	height?: string;
}>`.....`;

</code></pre>
<p>这样组件就是这样的，分成了默认好用的 ProgressBar 和 自定义功能更多的 SimpleProgressBar</p>
<pre><code>
interface ProgressProps {
	progress: number;
	height?: string;
}
const ProgressBar = ({
	height,
}: Omit&#x3C;ProgressProps, "progress">) => {
	const progress = useProgress();
	return (
		&#x3C;ProgressBarWrapperFixed progress={progress} height={height}>
			&#x3C;div className='bar-used'>&#x3C;/div>
		&#x3C;/ProgressBarWrapperFixed>
	);
};

const SimpleProgressBar = ({
	progress,
	height,
}: ProgressProps) => {
	return (
		&#x3C;ProgressBarWrapper progress={progress} height={height}>
			&#x3C;div className='bar-used'>&#x3C;/div>
		&#x3C;/ProgressBarWrapper>
	);
};
</code></pre>
<p>另外就是添加 合适的 escape，方便使用的时候如果不符合需要可以自行修改。这里直接在组件上添加一个 style参数，</p>
<pre><code>// usage
&#x3C;ProgressBar style={{ background: "#000" }}>&#x3C;/ProgressBar>
// 修改组件 添加rest参数接受附加的style,并且修改一下类型
const ProgressBar = ({
	height,
	...rest
}: Omit&#x3C;ProgressProps, "progress"> &#x26; React.HTMLAttributes&#x3C;HTMLDivElement>) => {
	const progress = useProgress();
	return (
		&#x3C;ProgressBarWrapperFixed {...rest} progress={progress} height={height}>
			&#x3C;div className='bar-used'>&#x3C;/div>
		&#x3C;/ProgressBarWrapperFixed>
	);
};
</code></pre>
<p>这样就写好了一个好用的ProgressBar组件了，并且提供了SimpleProgressBar用于其他的自定义用途。</p>
<p>在线演示：<a href="https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010">https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010</a></p>
<h2>总结</h2>
<p>经过上面对 chakra ui 组件库源码的研究以及一个示例，相信你以及知道了该如何设计一个好用的组件库了，希望你能为你的公司也开发一套组件库，能更好的完成你的kpi/okr/etc...</p>
<h2>Reference</h2>
<ol>
<li><a href="https://github.com/chakra-ui/chakra-ui">https://github.com/chakra-ui/chakra-ui</a></li>
<li><a href="https://chakra-ui.com/">https://chakra-ui.com/</a></li>
<li><a href="https://emotion.sh/">https://emotion.sh/</a></li>
<li><a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a></li>
<li><a href="https://tailwindcss.com/">https://tailwindcss.com/</a></li>
<li><a href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></li>
<li><a href="https://ant.design/index-cn">https://ant.design/index-cn</a></li>
<li><a href="https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen">https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen</a></li>
</ol>
</div><div id="comments"></div></div><div class="Footer__FooterWrapper-sc-1ysspqt-0 llpwQT"><div class="my-main-font text"><span>Powerd by Next.js on gh-pages, </span><a href="http://www.anbandon.work">More in old blog</a></div><div class="Footer__IconList-sc-1ysspqt-1 liWOyP"><a href="https://github.com/alfxjx"><svg class="github_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="32" height="32"><path d="M960 512c0 97.76-28.704 185.216-85.664 263.264-56.96 78.016-130.496 131.84-220.64 161.856-10.304 1.824-18.368.448-22.848-4.032a22.4 22.4 0 0 1-7.2-17.504v-122.88c0-37.632-10.304-65.44-30.464-82.912a409.856 409.856 0 0 0 59.616-10.368 222.752 222.752 0 0 0 54.72-22.816c18.848-10.784 34.528-23.36 47.104-38.592 12.544-15.232 22.848-35.904 30.912-61.44 8.096-25.568 12.128-54.688 12.128-87.904 0-47.072-15.232-86.976-46.208-120.16 14.368-35.456 13.024-74.912-4.48-118.848-10.752-3.616-26.432-1.344-47.072 6.272s-38.56 16.16-53.824 25.568l-21.984 13.888C587.776 285.088 550.56 280.16 512 280.16s-75.776 4.928-112.096 15.232a444.48 444.48 0 0 0-24.672-15.68c-10.336-6.272-26.464-13.888-48.896-22.432-21.952-8.96-39.008-11.232-50.24-8.064-17.024 43.936-18.368 83.424-4.032 118.848-30.496 33.632-46.176 73.536-46.176 120.608 0 33.216 4.032 62.336 12.128 87.456 8.032 25.12 18.368 45.76 30.496 61.44 12.544 15.68 28.224 28.704 47.072 39.04 18.848 10.304 37.216 17.92 54.72 22.816a409.6 409.6 0 0 0 59.648 10.368c-15.712 13.856-25.12 34.048-28.704 60.064a99.744 99.744 0 0 1-26.464 8.512 178.208 178.208 0 0 1-33.184 2.688c-13.024 0-25.568-4.032-38.144-12.544-12.544-8.512-23.296-20.64-32.256-36.32a97.472 97.472 0 0 0-28.256-30.496c-11.232-8.064-21.088-12.576-28.704-13.92l-11.648-1.792c-8.096 0-13.92.928-17.056 2.688-3.136 1.792-4.032 4.032-2.688 6.72s3.136 5.408 5.376 8.096 4.928 4.928 7.616 7.168l4.032 2.688c8.544 4.032 17.056 11.232 25.568 21.984 8.544 10.752 14.368 20.64 18.4 29.6l5.824 13.44c4.928 14.816 13.44 26.912 25.568 35.872 12.096 8.992 25.088 14.816 39.008 17.504 13.888 2.688 27.36 4.032 40.352 4.032s23.776-.448 32.288-2.24l13.472-2.24c0 14.784 0 32.288.416 52.032 0 19.744.48 30.496.48 31.392a22.624 22.624 0 0 1-7.648 17.472c-4.928 4.48-12.992 5.824-23.296 4.032-90.144-30.048-163.68-83.84-220.64-161.888C92.256 697.216 64 609.312 64 512c0-81.152 20.192-156.064 60.096-224.672s94.176-122.88 163.232-163.232C355.936 84.192 430.816 64 512 64s156.064 20.192 224.672 60.096 122.88 94.176 163.232 163.232C939.808 355.488 960 430.848 960 512"></path></svg></a><a href="https://weibo.com/u/1950371745"><svg class="weibo_svg__icon" viewBox="0 0 1026 1024" xmlns="http://www.w3.org/2000/svg" width="32.063" height="32"><path d="M0 61.5zM780 577c-11-2-18-5.5-21-9.5-3-4.5-4-8-1.5-12l3-5.5c.5-.5 1.5-2 2-3 .5-1.5 2-4.5 4.5-9 2-4.5 4-9.5 5-14s2-10.5 2.5-17 .5-13.5-.5-19.5-3-12.5-6.5-20c-3.5-7-7.5-13.5-13.5-19.5-10-10-23-16.5-39.5-19.5-16-3-32.5-3-48.5-.5s-31.5 5.5-45.5 9.5c-14.5 4-26 7.5-35.5 11.5l-14 6.5c-7 2-13 3.5-18 4.5-4.5.5-8.5.5-11-.5s-4.5-2-6-3-2-3.5-1.5-7.5.5-7.5 1-10c.5-3 1.5-7.5 2.5-13.5 1.5-6 2.5-11 3-14.5 0-8.5-.5-16.5-1.5-24s-3.5-16-7-25.5-9-17-15.5-22.5c-7-5.5-15.5-10.5-26-14s-24-4.5-40.5-3-35 5.5-56 13c-25 8.5-50.5 21.5-76.5 38-26 17-48 34.5-67 52.5-19 18.5-36.5 36-52 53.5-16 17-28 31-36.5 42l-12 17c-23.5 31-41 61.5-52.5 92.5s-17 54-16 70V723c4.5 34.5 15 65.5 31.5 92.5 17 27.5 37 49.5 60 66 23.5 17 51 31 82.5 43s62 20.5 91 26 59.5 9 92 11.5c53 4.5 108 0 165-12.5s110-34.5 159-65c49-31 84-68 104-111 12-25 18.5-49 19-71s-3.5-40.5-11.5-54.5-18-26.5-30.5-37c-12.5-11-24.5-18.5-35.5-23.5-10-6-20-9.5-28.5-10.5zM452 911.5c-77.5 3.5-143.5-11.5-197.5-45s-81-76.5-81-128c0-51 27-95 80.5-132s120-57 198-61S596 555 650 584s80.5 69.5 80.5 120.5c0 51.5-27.5 98-82.5 139.5s-120 64-196 67.5zm-31.5-298c-21 2-39.5 7-56 14.5S335 644 326 654c-9.5 9.5-17 20-23.5 31s-11 22-13.5 33-4 20.5-5 29.5c-.5 9-1 16-1 21l1 8.5v4.5c0 2 .5 6.5 2 13s3.5 12.5 6 18 6.5 11.5 12.5 18 12.5 12 20.5 16c47.5 23 91.5 30 132.5 21s74-29.5 99-62c10-12 16.5-27.5 20-45 3-18 2.5-36-2-54.5s-12.5-35-24-50-28.5-26.5-51-35c-23.5-9-49.5-11-79-7.5zM382 817c-4.5.5-8.5 1-12.5.5s-7.5-1-11-2-6.5-2.5-9.5-4-6-3.5-8-6l-6-7.5c-2-2.5-3-5.5-4.5-8.5s-1.5-6.5-1.5-10c0-8 2-15.5 6.5-23s10-14 18-19.5c7.5-5.5 16-8.5 25.5-9 6.5-.5 12.5-.5 19 .5 6 1 11.5 3 15.5 5.5 4.5 2.5 8 5.5 11.5 8.5 3 3 5.5 7 7 11.5s2 9 2 14c0 8-2.5 15.5-7 22.5S416 804 408 809c-8 4-16.5 7-26 8zm91.5-77.5c-5 3.5-10 5-15.5 5-5.5-.5-9-2.5-11.5-7l-2-4.5c-.5-1.5-1-3-1-4.5V724c0-2 .5-4 1-5.5l2-4.5c.5-1.5 2-2.5 3-3l3-4.5c5.5-4.5 11.5-6 16.5-5.5s9 3.5 11.5 8.5c2 3 3 6 2.5 9.5s-1.5 7-3 10c-1.5 4.5-4 7.5-6.5 10.5zm382-225c4.5 0 8.5-1 12-3s6.5-5 8.5-8 3.5-6.5 4.5-10c.5-.5 1-2 1-3 8.5-82-20-128.5-86-140-19.5-3.5-37.5-4-54-1-5 0-9.5 1.5-13 4s-6.5 5.5-9 9.5-4 8-4 12.5c0 7 2.5 13.5 7.5 18.5s11 7.5 18.5 7.5c56-13 86 5 90.5 54 1.5 12 .5 23.5-2 34.5 0 7 2.5 13.5 7.5 18.5 4.5 3.5 10.5 6 18 6zM837 211c-31.5-7-74-5.5-127 4.5-.5 0-1.5.5-2 1l-1 2-1 1c-8 2-14.5 6.5-19.5 13.5s-7.5 14-7.5 22c0 11 3.5 19.5 11 27 7 7 16 11 26 11h3c.5 0 2.5-.5 5-1s5-1.5 8-1.5c3-.5 6-1 9-2s6-2 8.5-3S757 284 764 284s16 .5 26.5 1.5 22 4 34.5 8c12.5 4.5 25 9.5 37.5 16s25 15.5 37.5 27 23.5 24.5 33 40c18.5 42.5 22.5 83 11 122.5 0 .5 0 1.5-.5 2s-1 2.5-1.5 5.5-1.5 5.5-2 8-1.5 5.5-2 9.5-1 7.5-1 10c0 6.5 2 12 5.5 16 3.5 4.5 8 7.5 13.5 9 5.5 2 11.5 2.5 19 2.5 20 0 32-12 35.5-36.5 8.5-28 13.5-54.5 14.5-80s-.5-48-5.5-67c-4.5-19.5-11.5-37.5-21-54.5s-20-31-32.5-43c-12-12-26-22.5-41-32.5-15-9.5-29.5-17.5-43.5-23-15-5.5-29.5-10.5-44.5-14z"></path></svg></a><a href="https://juejin.cn/user/2330620383728551"><svg class="juejin_svg__icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M832 739.533h57.958v30.105H587.571v-30.105h48.538l-31.54-184.525-.819-4.506 4.608-.716 21.095-3.482 4.505-.717.82 4.506 32.46 189.645h49.87V510.874H571.391v-30.106h145.613V381.44H619.93v-30.106h228.556v30.106H747.52v99.328h162.918v30.106H747.622v228.659h53.453l32.461-189.543.717-4.505 4.505.717 21.095 3.481 4.608.717-.82 4.506L832 739.533zm-428.032-9.728V582.45h74.854V423.22h-30.617v129.127h-44.237V413.798H373.35v138.548h-43.52V423.219h-30.617v159.232h74.137v147.354h-43.52V602.624h-30.617V759.91H478.72V602.624h-30.618v127.18h-44.134zM148.89 582.45l-21.607 21.197-3.174 3.174-3.175-3.174L105.78 588.8l-3.379-3.277 3.38-3.277 43.11-42.393V364.237h-37.684V334.13h37.684V254.26h30.617v79.872h44.135v30.106h-44.135v145.715l25.6-25.088 3.175-3.174 3.174 3.174 15.155 14.746 3.38 3.276-3.38 3.277-47.104 46.285v65.024c0 33.178-5.12 65.024-13.824 94.413-5.325 18.022-10.547 31.13-14.745 39.629l-4.71 9.42-2.049 3.994-4.096-1.946-19.251-9.113-4.198-2.048 2.048-4.199 4.608-9.42c.716-1.332 2.252-4.813 3.993-9.319 2.97-7.475 5.94-15.974 8.704-25.497 7.885-26.932 12.698-56.013 12.698-86.016V582.45zm97.792 180.122.921-4.506 2.15-10.24c12.8-61.645 17.511-195.584 16.999-358.605h220.672v-134.86H234.496l.102 4.71.205 10.65c.205 10.24.615 32.768.82 59.904.409 44.748.511 91.033.102 136.601-1.229 129.536-6.144 227.84-16.077 275.559l-2.15 10.24-.922 4.505 4.506.922 20.992 4.198 4.608.922zm19.865-403.456-1.024-74.65h191.181v74.65H266.547zm634.266 31.437 3.072-3.277 14.54-15.36 3.175-3.38-3.482-3.174-121.344-109.875-3.072-1.229h-126.77l-3.073 1.229-121.241 109.875-3.482 3.175 3.174 3.379 14.541 15.36 3.072 3.277 3.38-2.97 115.2-103.014h103.833l115.2 103.014 3.277 2.97z"></path></svg></a></div></div></div><div class="Toast__StyledContainer-sc-1p228qg-0 gWqgDn"><div class="Toastify"></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"如何设计一个好用的组件-以chakra-ui为例","date":"2021-10-28T12:52:42.712Z","slug":"design-a-component","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"\u003cblockquote\u003e\n\u003cp\u003e同时发布于 \u003ca href=\"https://www.yuque.com/alfxjx/notes/wchz9f\"\u003e语雀\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e引子\u003c/h2\u003e\n\u003cp\u003e最近公司在搭建部门的统一平台，我负责了统一登录前端的开发，因为要对接很多的系统，所以开发了统一登录的sdk，说是sdk其实就是一个组件库。以此为契机，外加之前开发其他的系统中也用了很多种不同的组件库（饿了没-ui/vant/antd/chakra-ui...），今天写一篇文章说说，什么样的组件设计是比较合理的，以及如何设计一个好用的组件。\u003c/p\u003e\n\u003ch2\u003e研究chakra-ui\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/chakra-ui.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e比较来说我觉得设计比较有特色的一个组件库，就是 \u003ca href=\"https://chakra-ui.com/\"\u003echakra-ui\u003c/a\u003e 了，不过国内使用的并不多，我也是在之前技术选型的时候偶然找到的，但是仔细读了她的文档之后我发现这个是一个很有特色的组件库，下面细说：\u003c/p\u003e\n\u003ch3\u003e样式自定义\u003c/h3\u003e\n\u003cp\u003e找到这个 chakra-ui 的时候，就是因为需要在使用 tailwind CSS 的同时使用一个组件库，chakra-ui 的一个特色就是使用了和 tailwind CSS 几乎相同的样式 api , 例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { Box } from \"@chakra-ui/react\"\n\n// m={2} refers to the value of `theme.space[2]`\n\u0026#x3C;Box m={2}\u003eTomato\u0026#x3C;/Box\u003e\n\n// You can also use custom values\n\u0026#x3C;Box maxW=\"960px\" mx=\"auto\" /\u003e\n\n// sets margin `8px` on all viewports and `16px` from the first breakpoint and up\n\u0026#x3C;Box m={[2, 3]} /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样只要你记住了 tailwind CSS 的api， 那么就可以很快的上手 chakra-ui 。\n那么这个是怎么实现的呢？\n一开始我以为是组件库使用了tailwind CSS ，但是看了源码发现，chakra 将 styled-components 进行了二次封装，而这种 tailwindLike 的 api 是进行了模拟导致的。\n在 \u003ca href=\"https://github.com/chakra-ui/chakra-ui/blob/main/packages/styled-system/src/config/background.ts\"\u003e/packages/styled-system/config/\u003c/a\u003e 里面 写入了不同样式以及缩写，以 background 为例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport const background: Config = {\n  background: t.colors(\"background\"),\n  ...\n  bg: t.colors(\"background\"),\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样实现的，可以说把dirty的工作封装了起来，展示出来的结果都是好用的。\u003c/p\u003e\n\u003ch3\u003e组件组合\u003c/h3\u003e\n\u003cp\u003e书接上文，组件里面做了很多的映射封装，为了减少代码量，统一进行管理，组件库进行了组件的组合（compose）。从一个基本的组件出发，通过默认一些样式，创造了一些新的组件。\n例如\u003ca href=\"https://chakra-ui.com/docs/layout/center#square-and-circle\"\u003e Square Circle \u003c/a\u003e组件，是基于 Box 组件extend而来的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport const Square = forwardRef\u0026#x3C;SquareProps, \"div\"\u003e((props, ref) =\u003e {\n  const { size, centerContent = true, ...rest } = props\n\n  const styles: SystemStyleObject = centerContent\n    ? { display: \"flex\", alignItems: \"center\", justifyContent: \"center\" }\n    : {}\n\n  return (\n    \u0026#x3C;Box\n      ref={ref}\n      boxSize={size}\n      __css={{\n        ...styles,\n        flexShrink: 0,\n        flexGrow: 0,\n      }}\n      {...rest}\n    /\u003e\n  )\n})\n\nif (__DEV__) {\n  Square.displayName = \"Square\"\n}\n\nexport const Circle = forwardRef\u0026#x3C;SquareProps, \"div\"\u003e((props, ref) =\u003e {\n  const { size, ...rest } = props\n  return \u0026#x3C;Square size={size} ref={ref} borderRadius=\"9999px\" {...rest} /\u003e\n})\n\nif (__DEV__) {\n  Circle.displayName = \"Circle\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样写减少了重复的代码并且可以保持更好的可维护性。我们在开发的过程中也可以借鉴这种模式，开发出最抽象的组件，从这个最抽象的父类出发来进行派生。\u003c/p\u003e\n\u003ch3\u003eTheminig\u003c/h3\u003e\n\u003cp\u003echakra ui 的另外一个特点就是拥有一个高度自定义的主题系统， 使用的方式类似于 tailwind CSS \u003ca href=\"https://tailwindcss.com/docs/theme\"\u003e设置\u003c/a\u003e，也就是说你可同时将一个theme文件应用到两个库中，使用方法可以看一下\u003ca href=\"https://chakra-ui.com/docs/theming/customize-theme\"\u003echakra文档\u003c/a\u003e，那么这个主题是如何实现的呢？\n首先 chakra ui 维护了一个default theme ,用于在没有自定义 theme 或者 自定义了一部分的theme的时候进行合并，合并的过程（\u003ccode\u003etoCSSVar\u003c/code\u003e）是使用了 \u003ccode\u003ecreateThemeVars\u003c/code\u003e 方法将自己配置的theme转化成css var变量，然后将默认的theme和生成的theme进行合并。最后在 :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nexport const ThemeProvider = (props: ThemeProviderProps) =\u003e {\n  const { cssVarsRoot = \":host, :root\", theme, children } = props\n  const computedTheme = React.useMemo(() =\u003e toCSSVar(theme), [theme])\n  return (\n    \u0026#x3C;EmotionThemeProvider theme={computedTheme}\u003e\n      \u0026#x3C;Global styles={(theme: any) =\u003e ({ [cssVarsRoot]: theme.__cssVars })} /\u003e\n      {children}\n    \u0026#x3C;/EmotionThemeProvider\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里是借用了 emotion 的 \u003ca href=\"https://emotion.sh/docs/theming#themeprovider-reactcomponenttype\"\u003eThemeProvider\u003c/a\u003e。这么一看其实主题设置还是很简单的。这样可以很方便的设置了一个自定义的主题\n除此之外，如果想在二次开发的主题上进行三次开发，可以使用 chakra-ui 提供的api \u003ca href=\"https://chakra-ui.com/docs/theming/customize-theme#using-theme-extensions\"\u003eTheme extensions\u003c/a\u003e。提供了一个类似于 HOC 的包裹函数，以withDefaultColorScheme为例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport function withDefaultColorScheme({colorScheme,components}): ThemeExtension {\n  return (theme) =\u003e {\n    let names = Object.keys(theme.components || {})\n\t\t// ....\n    return mergeThemeOverride(theme, {\n      components: Object.fromEntries(\n        names.map((componentName) =\u003e {\n          const withColorScheme = {\n            defaultProps: {\n              colorScheme,\n            },\n          }\n          return [componentName, withColorScheme]\n        }),\n      ),\n    })\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将配置的颜色Scheme赋值给了配置的对应的组件。内部实现大同小异，都是调用了 \u003ccode\u003emergeThemeOverride\u003c/code\u003e这个方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport function mergeThemeOverride\u0026#x3C;BaseTheme extends ChakraTheme = ChakraTheme\u003e(\n  ...overrides: ThemeOverride\u0026#x3C;BaseTheme\u003e[]\n): ThemeOverride\u0026#x3C;BaseTheme\u003e {\n  return mergeWith({}, ...overrides, mergeThemeCustomizer)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e内部使用了 \u003ccode\u003elodash.mergewith\u003c/code\u003e的方法实现融合，对于此方法 chakra-ui 写了一个mergeThemeCustomizer 作为 \u003ca href=\"https://www.lodashjs.com/docs/lodash.mergeWith/\"\u003elodash.mergwith\u003c/a\u003e 的第三个参数，这里的自定义mergeThemeCustomizer方法使用了递归的方式进行merge。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nfunction mergeThemeCustomizer(\n  source: unknown,\n  override: unknown,\n  key: string,\n  object: any,\n) {\n  if (\n    (isFunction(source) || isFunction(override)) \u0026#x26;\u0026#x26;\n    Object.prototype.hasOwnProperty.call(object, key)\n  ) {\n    return (...args: unknown[]) =\u003e {\n      const sourceValue = isFunction(source) ? source(...args) : source\n\n      const overrideValue = isFunction(override) ? override(...args) : override\n\n      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer)\n    }\n  }\n\n  // fallback to default behaviour\n  return undefined\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e外部组件与二次封装\u003c/h3\u003e\n\u003cp\u003e从上面可以看到，组件库也不是全部从零开始，也使用了很多第三方的库，例如样式库 emotion， styled-components，工具方法库 lodash，这里没啥特别好说的。\n另外chakra-ui官方也推荐将组件库和许多第三方的lib一起使用，例如 表单验证库\u003ca href=\"https://chakra-ui.com/docs/form/form-control#usage-with-form-libraries\"\u003eformik\u003c/a\u003e，此外，在element-ui中也会直接封装throttle-debounce， async-validator等第三方的库。\u003c/p\u003e\n\u003ch3\u003e提供escape\u003c/h3\u003e\n\u003cp\u003e在使用其他的组件库的时候，很多情况下会出现某些组件的细节和设计要求不一致的情况，对于element-ui和ant design来说，由于使用了sass/less等预处理器，可以使用覆盖的方式来覆写样式。在 chakra ui 中，则提供了一个 \u003ca href=\"https://chakra-ui.com/docs/features/the-sx-prop\"\u003esx Props\u003c/a\u003e 来直接向组件传入样式。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;Box sx={{ \"--my-color\": \"#53c8c4\" }}\u003e\n  \u0026#x3C;Heading color=\"var(--my-color)\" size=\"lg\"\u003e\n    This uses CSS Custom Properties!\n  \u0026#x3C;/Heading\u003e\n\u0026#x3C;/Box\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个方式很强大，还支持嵌套样式，media query等。这里的sx是一个封装自@emotion/styled的方法，在 \u003ca href=\"https://github.com/chakra-ui/chakra-ui/blob/main/packages/system/src/system.ts\"\u003epackages/system/src/system.ts\u003c/a\u003e, styled方法里面调用了 toCSSObject ，这里拿取到了输入的样式，而所有的ui 组件都会调用这个 styled方法，sx Props 就这样全局生效了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport function styled\u0026#x3C;T extends As, P = {}\u003e(\n  component: T,\n  options?: StyledOptions,\n) {\n  const { baseStyle, ...styledOptions } = options ?? {}\n\t// ...\n  const styleObject = toCSSObject({ baseStyle })\n  return _styled(\n    component as React.ComponentType\u0026#x3C;any\u003e,\n    styledOptions,\n  )(styleObject) as ChakraComponent\u0026#x3C;T, P\u003e\n}\n\nexport const toCSSObject: GetStyleObject = ({ baseStyle }) =\u003e (props) =\u003e {\n  const { theme, css: cssProp, __css, sx, ...rest } = props\n  const styleProps = objectFilter(rest, (_, prop) =\u003e isStyleProp(prop))\n  const finalBaseStyle = runIfFn(baseStyle, props)\n  const finalStyles = Object.assign({}, __css, finalBaseStyle, styleProps, sx)\n  const computedCSS = css(finalStyles)(props.theme)\n  return cssProp ? [computedCSS, cssProp] : computedCSS\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e如何设计一个好用的组件\u003c/h2\u003e\n\u003cp\u003e参考了很多设计，那么如何设计一个好用的组件呢，这里以一个progressBar为例。\u003c/p\u003e\n\u003ch3\u003eMVP 版本以及存在的问题\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eimport React, { useState, useEffect } from \"react\";\nimport styled from \"styled-components\";\n\nconst ProgressBarWrapper = styled.div\u0026#x3C;{ progress: number }\u003e`\n\twidth: 100%;\n\theight: 4px;\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tz-index: 9999;\n\t.bar-used {\n\t\tbackground: #34c;\n\t\twidth: ${({ progress }) =\u003e progress + \"%\"};\n\t\theight: 100%;\n\t\tborder-radius: 0 2px 2px 0;\n\t}\n`;\n\nconst ProgressBar = () =\u003e {\n\tconst [progress, setProgress] = useState(0);\n\tuseEffect(() =\u003e {\n\t\twindow.addEventListener(\"scroll\", () =\u003e {\n\t\t\tsetProgress(\n\t\t\t\t(document.documentElement.scrollTop /\n\t\t\t\t\t(document.body.scrollHeight - window.innerHeight)) *\n\t\t\t\t\t100\n\t\t\t);\n\t\t});\n\t\treturn () =\u003e {\n\t\t\twindow.removeEventListener(\"scroll\", () =\u003e {});\n\t\t};\n\t});\n\treturn (\n\t\t\u0026#x3C;ProgressBarWrapper progress={progress}\u003e\n\t\t\t\u0026#x3C;div className='bar-used'\u003e\u0026#x3C;/div\u003e\n\t\t\u0026#x3C;/ProgressBarWrapper\u003e\n\t);\n};\n\nexport { ProgressBar };\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里展示了一个页面顶部进度条的组件，类似于 \u003ca href=\"https://es6.ruanyifeng.com/#docs/decorator\"\u003ees6标准入门\u003c/a\u003e 这里的样式，上面的功能可以很快的就实现出来，但是只是比较符合单一的应用场景，进度条固定在顶部，只有从左往右增长一种情况。但是实际上的进度条可能会用到很多的地方，因此我们需要对照可能的场景以及代码中的变量进行判断，哪些是需要做成参数，并设置对应的默认值。\n需求有以下几种：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e颜色可调，位置可调，方向可调，这三个是比较全局的可调整类型\u003c/li\u003e\n\u003cli\u003e具体样式修改，高度修改，圆角修改，这些是其他的一些props，如果保持progressbar的功能不变可能不太会用到的props\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此外，这里的progeressBar还存在的一个问题就是，这个组件将展示和逻辑杂糅在了一起，组件内部就有对于页面滚动进度的计算逻辑（useEffect），但是如果使用的时候不需要这个逻辑呢？\n根据上面的一些要修改的点以及一些问题，我们来对这个组件进行拆分和重构。\u003c/p\u003e\n\u003ch3\u003e重构\u003c/h3\u003e\n\u003cp\u003e首先是把逻辑和展示分开。新建一个hook用于计算百分比。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { useState, useEffect } from \"react\";\n\nexport function useProgress() {\n\tconst [progress, setProgress] = useState(0);\n\tuseEffect(() =\u003e {\n\t\twindow.addEventListener(\"scroll\", () =\u003e {\n\t\t\tsetProgress(\n\t\t\t\t(document.documentElement.scrollTop /\n\t\t\t\t\t(document.body.scrollHeight - window.innerHeight)) *\n\t\t\t\t\t100\n\t\t\t);\n\t\t});\n\t\treturn () =\u003e {\n\t\t\twindow.removeEventListener(\"scroll\", () =\u003e {});\n\t\t};\n\t});\n\treturn progress;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e之后是给需要的参数添加props,并设置默认值，这里只以高度为例，设置一个可选的高度参数，当传入的时候就使用传入的值否则是默认的。\n同时注意颜色等可以使用一个theme系统。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nconst ProgressBarWrapper = styled.div\u0026#x3C;{ progress: number; height?: string }\u003e`\n\twidth: 100%;\n\theight: ${({ height }) =\u003e (height ? height : \"4px\")};\n\t.bar-used {\n\t\tbackground: ${({ theme }) =\u003e theme.themeColor};\n\t\twidth: ${({ progress }) =\u003e progress + \"%\"};\n\t\theight: 100%;\n\t\tborder-radius: ${({ height }) =\u003e\n\t\t\theight ? `0 calc( ${height}/ 2) calc(${height}/ 2) 0` : \"0 2px 2px 0\"};\n\t}\n`;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e除此之外，将fixed布局抽象出来，方便后面进行组合\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst FixedTopWrapper = styled.div`\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tz-index: 9999;\n`;\n// 组合之后就是这样的\nconst ProgressBarWrapperFixed = styled(FixedTopWrapper)\u0026#x3C;{\n\tprogress: number;\n\theight?: string;\n}\u003e`.....`;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样组件就是这样的，分成了默认好用的 ProgressBar 和 自定义功能更多的 SimpleProgressBar\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\ninterface ProgressProps {\n\tprogress: number;\n\theight?: string;\n}\nconst ProgressBar = ({\n\theight,\n}: Omit\u0026#x3C;ProgressProps, \"progress\"\u003e) =\u003e {\n\tconst progress = useProgress();\n\treturn (\n\t\t\u0026#x3C;ProgressBarWrapperFixed progress={progress} height={height}\u003e\n\t\t\t\u0026#x3C;div className='bar-used'\u003e\u0026#x3C;/div\u003e\n\t\t\u0026#x3C;/ProgressBarWrapperFixed\u003e\n\t);\n};\n\nconst SimpleProgressBar = ({\n\tprogress,\n\theight,\n}: ProgressProps) =\u003e {\n\treturn (\n\t\t\u0026#x3C;ProgressBarWrapper progress={progress} height={height}\u003e\n\t\t\t\u0026#x3C;div className='bar-used'\u003e\u0026#x3C;/div\u003e\n\t\t\u0026#x3C;/ProgressBarWrapper\u003e\n\t);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e另外就是添加 合适的 escape，方便使用的时候如果不符合需要可以自行修改。这里直接在组件上添加一个 style参数，\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// usage\n\u0026#x3C;ProgressBar style={{ background: \"#000\" }}\u003e\u0026#x3C;/ProgressBar\u003e\n// 修改组件 添加rest参数接受附加的style,并且修改一下类型\nconst ProgressBar = ({\n\theight,\n\t...rest\n}: Omit\u0026#x3C;ProgressProps, \"progress\"\u003e \u0026#x26; React.HTMLAttributes\u0026#x3C;HTMLDivElement\u003e) =\u003e {\n\tconst progress = useProgress();\n\treturn (\n\t\t\u0026#x3C;ProgressBarWrapperFixed {...rest} progress={progress} height={height}\u003e\n\t\t\t\u0026#x3C;div className='bar-used'\u003e\u0026#x3C;/div\u003e\n\t\t\u0026#x3C;/ProgressBarWrapperFixed\u003e\n\t);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样就写好了一个好用的ProgressBar组件了，并且提供了SimpleProgressBar用于其他的自定义用途。\u003c/p\u003e\n\u003cp\u003e在线演示：\u003ca href=\"https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010\"\u003ehttps://codepen.io/alfxjx/pen/ZEJyygo?editors=0010\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e经过上面对 chakra ui 组件库源码的研究以及一个示例，相信你以及知道了该如何设计一个好用的组件库了，希望你能为你的公司也开发一套组件库，能更好的完成你的kpi/okr/etc...\u003c/p\u003e\n\u003ch2\u003eReference\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/chakra-ui/chakra-ui\"\u003ehttps://github.com/chakra-ui/chakra-ui\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://chakra-ui.com/\"\u003ehttps://chakra-ui.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://emotion.sh/\"\u003ehttps://emotion.sh/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.lodashjs.com/\"\u003ehttps://www.lodashjs.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://tailwindcss.com/\"\u003ehttps://tailwindcss.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://element.eleme.cn/#/zh-CN\"\u003ehttps://element.eleme.cn/#/zh-CN\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ant.design/index-cn\"\u003ehttps://ant.design/index-cn\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen\"\u003ehttps://stackoverflow.com/questions/55318165/add-styled-components-to-codepen\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n","coverImage":"/assets/blog/chakra-ui.png"}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"design-a-component"},"buildId":"Ehk_RCBKDfsxeu7pxJYZH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>