{"pageProps":{"post":{"title":"[Regex]手把手教你解析一个URL字符串","date":"2021-01-22T22:15:42.712Z","slug":"rgex-url","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"<h2>需求</h2>\n<p>实现对网页地址链接的匹配；\n一些典型的网页链接如下：</p>\n<ul>\n<li><a href=\"http://www.baidu.com\">http://www.baidu.com</a></li>\n<li><a href=\"https://www.abc.com/a/b\">https://www.abc.com/a/b</a></li>\n<li><a href=\"http://admin.afin.com:23456\">http://admin.afin.com:23456</a></li>\n<li><a href=\"http://www.vuejs.org/#/home\">http://www.vuejs.org/#/home</a></li>\n<li><a href=\"http://%20www.163.com/a?day=1234&#x26;night=2345\">http:// www.163.com/a?day=1234&#x26;night=2345</a></li>\n</ul>\n<p>如上所示，需要匹配下面的6个：</p>\n<h3>协议</h3>\n<p>协议头一般有http、https、ftp等这里写一下匹配的方式：</p>\n<pre><code>let protocol = /(?:ht|f)tp(?:s)?(?=:\\/\\/)/\nprotocol.exec('http://1234')\n// [\"http\", index: 0, input: \"http://1234\", groups: undefined]\n</code></pre>\n<p>解释：</p>\n<ul>\n<li>使用非捕获组<code>/(?:ht|f)/</code>，只对值判断，但是不将结果，也就是(ht|p)看作是一个捕获组；</li>\n<li>使用正向零宽断言<code>(?=:\\/\\/)</code>,匹配后面的://，只有有此符号才算匹配。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/2547f0e3e809\">正则表达式之捕获组和非捕获组</a></p>\n</blockquote>\n<h3>域名</h3>\n<p>对于域名，一般来说有两种情况，一个事数字的ip域名，一种是字符域名。</p>\n<blockquote>\n<p>IP地址的长度为32位(共有2^32个IP地址)，分为4段，每段8位\n用十进制数字表示，每段数字范围为0～255，段与段之间用句点隔开。\n<a href=\"https://www.jianshu.com/p/82886d77440c\">https://www.jianshu.com/p/82886d77440c</a></p>\n</blockquote>\n<ol>\n<li>对于ip域名：\n<ol>\n<li>数字在0~255之间，<code>/^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$/</code></li>\n<li>总共4段： <code>/^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?:(?:\\.)(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3,3}$/</code></li>\n<li>解释一下，上面的匹配数字的方法避免了001这样的匹配，然后匹配四段后面的<code>{3,3}</code>则是保证只能是4段。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p><a href=\"http://baike.baidu.com/view/22276.htm\">DNS</a>规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写字母。标号中除连字符（-）外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。\n<a href=\"https://developer.aliyun.com/article/297853\">https://developer.aliyun.com/article/297853</a></p>\n</blockquote>\n<ol start=\"2\">\n<li>对于字符的域名：\n<ol>\n<li>按照规则可以写出一个域名： 'test-12.admin.abandon.work'</li>\n<li>匹配它： <code>/^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$/</code></li>\n</ol>\n</li>\n<li>将两中匹配的规则合并起来：\n<ol>\n<li>首先匹配ip，然后再匹配域名</li>\n<li>将二者合并起来</li>\n<li>参考： <a href=\"https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address\">Regular expression to match DNS hostname or IP Address?</a></li>\n<li><code>/^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?:(?:\\.)(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3,3}$|^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$/</code></li>\n</ol>\n</li>\n</ol>\n<pre><code>/^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?:(?:\\.)(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3,3}$|^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$/.exec(\"www.abandon.work\");\n// [\"www.abandon.work\", undefined, \"abandon.\", \"abandon\", \"work\", index: 0, input: \"www.abandon.work\", groups: undefined]\n</code></pre>\n<p><a href=\"https://regexr.com/5gu8v\">在线演示请看这里</a>\n这里还可以对捕获组进行一点优化，聪明的小伙伴你看看是怎么搞的。</p>\n<h3>端口号</h3>\n<p>其实最困难的部分已经过去啦，下面对端口号的匹配就很简单了，匹配的是冒号后面的数字。</p>\n<pre><code>/(?&#x3C;=\\:)[0-9]+$/.exec('http://www.abandon.wor:8080');\n// [\"8080\", index: 23, input: \"http://www.abandon.wor:8080\", groups: undefined]\n</code></pre>\n<ul>\n<li>需要注意的是这里使用了一个<a href=\"https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html\">正向后行断言</a>，用来判断端口号前面的冒号，这样匹配的捕获组里面就没有冒号啦。</li>\n<li>当然 不是所有的域名都会把端口号暴露在外面，为了保护自己的底裤，很多的页面是没有端口号显示的，因此在最后拼接正则表达式的时候需要注意这一点。</li>\n</ul>\n<h3>路由</h3>\n<p>对于路由，如法炮制，注意路由是由一个/开始的，并且这个斜杠的后面一个字符一定不是/：</p>\n<pre><code>/(\\/[0-9a-z#.]+)+|(\\/)/.exec('abandon.work/');\n\n// [\"/\", undefined, \"/\", index: 12, input: \"abandon.work/\", groups: undefined]\n\n/(\\/[0-9a-z#.]+)+|(\\/)/.exec('abandon.work/admin/#/articles/id');\n\n// [\"/admin/#/articles/id\", \"/id\", index: 12, input: \"abandon.work/admin/#/articles/id\", groups: undefined]\n</code></pre>\n<ul>\n<li>这里我认为还有优化的空间，可以把每一个都匹配出来才是最方便的。<strong></strong></li>\n</ul>\n<h3>query参数</h3>\n<p>query参数从？开始，中间是&#x26;链接，键值对保持key=value形态。\n上代码：</p>\n<pre><code>/(\\?[0-9a-z&#x26;=]+)/.exec('abandon.work/api?tab=10&#x26;date=10-11');\n\n// [\"?tab=10&#x26;date=10\", \"?tab=10&#x26;date=10\", index: 16, input: \"abandon.work/api?tab=10&#x26;date=10-11\", groups: undefined]\n</code></pre>\n<p>要是可以直接匹配出键值对就好了。或者匹配出key=value的形式。</p>\n<pre><code>var url = 'name=ooo&#x26;age=10';\nvar reg = /([^&#x26;=]+)=?([^&#x26;]*)/g;\n// 每执行一次就吐出一堆key&#x26;value\nreg.exec(url)\n[\"name=ooo\", \"name\", \"ooo\", index: 0, input: \"name=ooo&#x26;age=10\", groups: undefined]\nreg.exec(url)\n[\"age=10\", \"age\", \"10\", index: 9, input: \"name=ooo&#x26;age=10\", groups: undefined]\n</code></pre>\n<p>根据上面的代码可以写出一个很常见的<a href=\"https://www.jianshu.com/p/708c915fb905\">查询参数的方法</a>：</p>\n<pre><code>const getParams = (url ,name) => {\n\tlet reg = new RegExp(\"(^|&#x26;)\" + name + \"=([^&#x26;]*)(&#x26;|$)\", \"i\");\n  let r = url.match(reg);\n  if (r != null) {\n    return decodeURIComponent(r[2]);\n  };\n  return null;\n}\nlet url = 'https://cn.bing.com/search?q=ip%E5%9C%B0%E5%9D%80+%E8%A7%84%E5%88%99&#x26;qs=n&#x26;form=QBRE&#x26;sp=-1&#x26;pq=ip%E5%9C%B0%E5%9D%80+%E8%A7%84%E5%88%99&#x26;sc=1-7&#x26;sk=&#x26;cvid=FC57C982563B4F188629B32CAE541761';\ngetParams(url, \"pq\")\n// \"ip地址+规则\"\n</code></pre>\n<p>另外， <a href=\"https://www.cnblogs.com/fengshuzi/p/3378957.html\">正则表达式获取url中的所有参数和值</a></p>\n<h3>页面hash</h3>\n<p>页面的hash匹配的是文章阅读的锚点，注意不要和hash路由搞混了。</p>\n<pre><code>/#([0-9a-zA-Z\\-]+)/.exec('abandon.work/api#introduction')\n\n// [\"#introduction\", \"introduction\", index: 16, input: \"abandon.work/api#introduction\", groups: undefined]\n</code></pre>\n<h2>总结</h2>\n<p>合并上面的正则的时候要注意有时候url中没有某些参数也是正确的。</p>\n<pre><code>const http = /(?:ht|f)tp(?:s)?(?=:\\/\\/)/;\nconst domain = /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?:(?:\\.)(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3,3}$|^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\nconst port = /((?&#x3C;=\\:)[0-9]+)$/;\nconst route = /(\\/[0-9a-z#.]+)+|(\\/)/;\nconst query = /(\\?[0-9a-z&#x26;=]+)/;\nconst hash = /#([0-9a-zA-Z\\-]+)/;\n\nconst url = \"https://www.abandon.work:6001/#/blog?startDate=1&#x26;endDate=10&#x26;promote=false#test\";\nconst regex = /^*$/i; &#x3C;TODO>\nregex.exec(url);\nregex.test(url)\n</code></pre>\n<pre><code>regex.exec(url)\n[\n  \"http://www.abandon.work:6001/#/blog?startDate=1&#x26;endDate=10&#x26;promote=false#test\",\n  \"http://\",\n  \"www.abandon.work\",\n  \":6001\",\n  \"/#/blog\",\n  \"?startDate=1&#x26;endDate=10&#x26;promote=false\",\n  \"#test\",\n  index: 0,\n  input: \"http://www.abandon.work:6001/blog?startDate=1&#x26;endDate=10&#x26;promote=false#test\",\n  groups: undefined\n]\n</code></pre>\n<p>大功告成！希望之后你能用正则解决更多的问题。</p>\n<h2>Ref</h2>\n<p><a href=\"https://www.jianshu.com/p/2547f0e3e809\">正则表达式之捕获组和非捕获组</a>\n<a href=\"https://www.runoob.com/jsref/jsref-obj-regexp.html\">菜鸟教程 Regex</a></p>\n","coverImage":"/assets/blog/regex.jpeg"}},"__N_SSG":true}