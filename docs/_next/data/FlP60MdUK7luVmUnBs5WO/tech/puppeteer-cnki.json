{"pageProps":{"post":{"title":"[Puppeteer]我是如何做到写EXCEL时速3k行的","date":"2020-05-03T16:35:07.322Z","slug":"puppeteer-cnki","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"<h2>起因</h2>\n<p>之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目</p>\n<p>统计某某期刊的信息。</p>\n<p>粗粗看了一下14个人的群里，有我这样延毕的~~老狗~~ 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法：</p>\n<p><strong>CODING</strong>!!!</p>\n<h2>开干吧</h2>\n<p>首先确定技术栈，因为主攻前端不懂就问，所以选择node作为主要的开发语言，加之要做的是统计文章的信息，稍微想了一下，这个需求不就是~~爬虫~~CV嘛。</p>\n<p><code>puppeteer</code>是<code>nodejs</code>中一个很好用的自动化工具，都不能说他是爬虫，因为他广泛应用于自动化测试中，可以看看<a href=\"https://zhuanlan.zhihu.com/p/76237595\">这篇文章</a>。</p>\n<p>借鉴一下我朋友的<a href=\"http://www.weidongwei.com/blog/15?title=puppeteer%E7%88%AC%E7%9F%A5%E4%B9%8E\">这个文章</a>，首先：</p>\n<pre><code>npm i -S puppeteer\n</code></pre>\n<p>这里因为一下众所周知的原因，下载<code>Chromium</code>可能有点费劲，我这边之前玩<code>puppeteer</code>的时候就装好了，看官可以自行解决一下（搬瓦工啥的）；</p>\n<p><code>puppeteer</code> 作为一个自动化测试的库，其实就是自己在操作<code>Chrome</code>浏览器在进行一下指令，所以使用这个编写的代码我觉得还是很直观的。</p>\n<h2>观察需求</h2>\n<ul>\n<li>获取2014-2015年焊接学报的所有学术文章的标题，作者与单位，起止页码，摘要关键词等信息</li>\n<li>作者需要按行分开，作者和单位需要对应上</li>\n<li>在上面的基础上，其他行需要合并。\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480345-841eca98-9523-4f7b-a31c-8c0d14bf5202.png#align=left&#x26;display=inline&#x26;height=779&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=779&#x26;originWidth=1440&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1440\" alt=\"\">\n<a href=\"http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&#x26;pykm=HJXB&#x26;Year=&#x26;Issue=&#x26;Entry=\">文章列表页</a>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480374-000ad5f3-f718-4157-875d-9c4fd4f2134e.png#align=left&#x26;display=inline&#x26;height=737&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=737&#x26;originWidth=1440&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1440\" alt=\"\">\n<a href=\"http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=HJXB201401001&#x26;dbname=CJFD2014&#x26;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhMFE3R2FlMkI4akFIS1N4bGlEUUZtWT0%3D%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!\">单个文章的示例</a></li>\n</ul>\n<h2>解决方案</h2>\n<ul>\n<li>入口是CNKI的期刊文章列表页，基于ASPX生成。</li>\n<li>在文章列表页，就可以得到一部分信息</li>\n<li>摘要，关键词需要进入对应的文章页面去获取</li>\n<li>作者和单位的对应需要进入pdf查看**（未完成）**</li>\n<li>完成抓取之后再将数据导出成excel</li>\n</ul>\n<blockquote>\n<p>可以看出，信息呈现三层形式保存。</p>\n</blockquote>\n<h2>爬取所有的首层信息</h2>\n<p>首先一些准备工作，引入包和规定的格式：</p>\n<pre><code class=\"language-javascript\">const puppeteer = require('puppeteer');\nconst url = 'https://navi.cnki.net/knavi/JournalDetail?pcode=CJFD&#x26;pykm=HJXB';\n// 统一设定一个等待时间，防止操作太快被目标认出来\nconst TIME = 3000;\n</code></pre>\n<p>接下来就是主函数：</p>\n<pre><code class=\"language-javascript\">// 一个立即执行的异步函数\n(async () => {\n    const browser = await puppeteer.launch({\n\t\t// headless: false, // false浏览器界面启动\n\t\tslowMo: 100, // 放慢浏览器执行速度，方便测试观察\n\t\targs: [\n\t\t\t// 启动 Chrome 的参数\n\t\t\t'–no-sandbox',\n\t\t\t// '--window-size=1280,960',\n\t\t],\n\t});\n    // 创建新页面\n    const page = await browser.newPage();\n    // 这一句就是前往目标页面\n    await page.goto(url, {\n\t\t// 网络空闲说明已加载完毕\n\t\twaitUntil: 'networkidle2',\n\t});\n\tconsole.log('page加载完成！');\n})()\n</code></pre>\n<p>经过上面的描述可以看出，<code>puppeteer</code>和<code>Electron</code>等有点类似，都是主进程中创建子进程进行操作。</p>\n<p>接着就是在列表页选择对应的年份和期数，并且循环执行。</p>\n<p><code>puppeteer</code>意为<strong>提线木偶</strong>，所以想让浏览器做什么就发出对应的指令即可：</p>\n<p>首先是用到的两个<code>util</code>函数：</p>\n<pre><code class=\"language-javascript\">// 因为网页上年份的按钮的id是数字开头，直接S()会出错\n// 所以需要把它转换成Unicode\nfunction getID(year) {\n\tlet num = year - 2010;\n\treturn `#\\\\0032\\\\0030\\\\0031\\\\003${num}\\\\005f\\\\0059\\\\0065\\\\0061\\\\0072\\\\005f\\\\0049\\\\0073\\\\0073\\\\0075\\\\0065`;\n}\n\n// 选择某一年某一期的id\nfunction getNoDotID(year, num) {\n\tlet _num = num &#x3C; 10 ? `0${num}` : `${num}`;\n\treturn `#yq${year}${_num}`;\n}\n</code></pre>\n<p>接下来：</p>\n<pre><code class=\"language-javascript\">// 选择2014年，对每一期进行点击\n// 年份点击事件\nlet yearNum = 2014;\nconst yearBtn = await page.$(getID(yearNum));\nawait yearBtn.click();\nawait page.waitFor(TIME);\nlet accNum = 1;\n// 输出的结果，是一个二维数组。\nlet output = [];\n// 从第一期开始，一个月一期\nwhile (accNum &#x3C; 13) {\n    // 循环选择第几期\n    let NoDot = await page.$(getNoDotID(yearNum, accNum));\n    NoDot.click();\n\n    // 保存所有的信息\n    await page.waitFor(TIME);\n\n    console.log('选择列表...' + accNum);\n    const list = await page.$('#CataLogContent');\n    const items = await list.?('dd');\n\n    const res = await page.evaluate(list => {\n        // ...\n    }, list);\n    output.push(res);\n    accNum++;\n}\n</code></pre>\n<ul>\n<li><code>page.$(), page.?()</code>类似于<code>document.querySelector/querySelectorAll</code>，返回一个节点元素</li>\n<li><code>page.evaluate(function,node)</code> 是对上面选择到的对应的node节点进行浏览器内操作的方法，在function中实现。，function接受node作为参数。</li>\n</ul>\n<p>在<code>page.evaluate</code>的内部，我们将文章的信息（标题，起止页码等）以及链接提取出来保存起来。</p>\n<pre><code class=\"language-javascript\">const res = await page.evaluate(list => {\n    // 在这里就可以使用browser的对象啦\n    const itemList = list.querySelectorAll('dd');\n    let arr = [];\n    // console.log(itemList);\n    for (let item of itemList) {\n        // 这里是发现cnki是基于aspx的网页\n        // 并且跳转到对应的页面是有规律的，和filename之后的id有关\n        // 另外，不同的年份有不同的数据库\n        const getPaperId = function(id) {\n            let match = /filename=(\\w+)&#x26;/i.exec(id);\n            return match[1];\n        }\n        let paperID = item.querySelector('.opts > .btn-view >a').href;\n        let id = getPaperId(paperID);\n        // 最后将2014年某一条的innerText和id保存成一个字符串，留着之后解析\n        let content = item.innerText + '&#x26;' +id;\n        arr.push(content);\n    }\n    return arr;\n}, list);\n</code></pre>\n<p>这样运行一下<code>npm start</code>，得到的数据就log出来了。目前我就是直接复制了一下，当然也有其他的办法。</p>\n<p>最终得到的<code>data.txt</code>:</p>\n<pre><code class=\"language-javascript\">[\n    [\"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\\n樊丁;蒋锴;余淑荣;张健;\\n1-4+113&#x26;HJXB201401001\",\"铝合金超声-MIG焊接电弧行为\\n范成磊;谢伟峰;杨春利;寇毅;\\n5-8+113&#x26;HJXB201401002\",...],\n     ...\n ]\n</code></pre>\n<h2>爬取摘要，关键词等信息</h2>\n<p>目前是有了部分信息，但是摘要和关键词还需要在第二层里面获取;</p>\n<h3>对数据进行一些预处理</h3>\n<p><code>npm run analysis</code></p>\n<p>这一部分就是对上面得到的list进行处理，首先把2维数组拍平：</p>\n<pre><code class=\"language-javascript\">const out2014S = require('./output2014');\nconst out2015S = require('./output2015');\nconst fs = require('fs');\n\n// 获取引用\nlet out2014 = out2014S;\nlet out2015 = out2015S;\n// flat\nwhile (out2014.some(Array.isArray)) {\n\tout2014 = [].concat(...out2014);\n}\n\nwhile (out2015.some(Array.isArray)) {\n\tout2015 = [].concat(...out2015);\n}\n</code></pre>\n<p>目前得到的数据示例如下：</p>\n<pre><code class=\"language-javascript\">\"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\\n樊丁;蒋锴;余淑荣;张健;\\n1-4+113&#x26;HJXB201401001\",\n    ...\n\n</code></pre>\n<p>需要对这个进行分析，自定义一个split函数：</p>\n<pre><code class=\"language-javascript\">function SecondeSplit(arr, year) {\n    // 数据序列化一下，保存下\\n用于分割\n\tlet str = JSON.stringify(arr);\n\tconsole.log('str' + str);\n\tlet nArr = str.split('\\\\n');\n\tconsole.log('nArr' + nArr);\n\t// 0 title\n\t// 1 string authors\n\t// 2 pages and link\n\tlet res = {};\n    // clean\n\tres.title = nArr[0].replace(/\\\"/i, '');\n\tlet names = nArr[1].split(';');\n\tres.name = names.slice(0, names.length - 1);\n    // 存在有的文章没有页码和链接等问题\n\tif (nArr[2]) {\n\t\tlet linkArr = nArr[2].split('&#x26;');\n        // clean\n\t\tlet link = linkArr[1].replace(/\\\"/i, '');\n        // 两年的dbname稍有不同\n\t\tif (year === 2014) {\n\t\t\tres.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=${link}&#x26;dbname=CJFD2014`;\n\t\t}\n\t\tif (year === 2015) {\n\t\t\tres.link = `http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=${link}&#x26;dbname=CJFDLAST2015`;\n\t\t}\n\t\tlet pages = linkArr[0].split('+');\n\t\tlet pageArr = pages[0].split('-');\n\t\tres.start = pageArr[0];\n\t\tres.end = pageArr[1];\n\t}\n\treturn res;\n}\n\n// 对两年的数据进行操作\nlet ret2014 = [];\nout2014.forEach(i => {\n\tlet tmp = SecondeSplit(i, 2014);\n\tret2014.push(tmp);\n});\n// ... 2015一样\n\nlet ret = ret2014.concat(ret2015);\n\nlet jsonObj = {};\njsonObj.data = ret;\n// \\t能够保存一个比较美观的json\nlet wObj = JSON.stringify(jsonObj, '', '\\t');\nfs.writeFile('data.json', wObj, err => {\n\tconsole.log(err);\n});\n\n</code></pre>\n<h3>爬取摘要等</h3>\n<p><code>npm run abstract</code></p>\n<p>这里的主要思路就是继续操作<code>puppeteer</code>，对每一个链接，获取对应摘要，学校和关键词信息</p>\n<p>这里的<code>puppeteer</code>并没有用基于<code>async</code>的写法，用<code>then</code>也很方便。</p>\n<pre><code class=\"language-javascript\">const obj = require('../data1.json');\nconst fs = require('fs');\nconst puppeteer = require('puppeteer');\n// 因为要对obj操作\nlet data = obj;\nconst len = data.data.length;\npuppeteer\n\t.launch({\n\t\theadless: true,\n\t})\n\t.then(async browser => {\n\t\tfor (let i = 0; i &#x3C; len; i++) {\n\t\t\tif (data.data[i].link) {\n\t\t\t\tconst res = await getAbstract(i, data.data[i].link, browser);\n                // 这里就用keyword来判断是否抓取成功了\n\t\t\t\tconsole.log(i + ': ' + res.keywords);\n\t\t\t\tdata.data[i].abstract = res.abstract;\n\t\t\t\tdata.data[i].school = res.school;\n\t\t\t\tdata.data[i].keywords = res.keywords;\n\t\t\t}\n\t\t}\n\t})\n\t.then(() => {\n\t\tconsole.log('获取信息完成！');\n\t\t// console.log(data.data[0].abstract);\n    \t// 保存到data1.json\n\t\tsave(data);\n\t});\n\n</code></pre>\n<p><code>getAbstract</code>是一个获取摘要的函数，需要传browser实例，链接和序号：</p>\n<pre><code class=\"language-javascript\">async function getAbstract(num, link, browser) {\n\tconst page = await browser.newPage();\n\tawait page.goto(link);\n\tawait page.waitFor(3000);\n    // 摘要\n\tlet abs = await page.$('#ChDivSummary');\n\tlet abstract = await page.evaluate(abs => {\n\t\treturn abs.innerText;\n\t}, abs);\n    // 学校\n\tlet schoolDOM = await page.$('.orgn');\n\tlet school = await page.evaluate(schoolDOM => {\n\t\tlet arr = schoolDOM.querySelectorAll('span > a');\n\t\tlet res = '';\n\t\tarr.forEach(i => {\n\t\t\tres += i.text + ',';\n\t\t});\n        // 拼接为字符串后就删掉最后一个逗号\n\t\treturn res.slice(0, res.length - 1);\n\t}, schoolDOM);\n    // 关键词\n\tlet keysDOM = await page.$('#catalog_KEYWORD');\n\tlet keys = await page.evaluate(keysDOM => {\n    // let arr = keysDOM.querySelectorAll('p')[2].querySelectorAll('a');\n    // 上面的写法并不好，因为有的挂了基金有的没挂，所以不一定是第三个\n    // 发现关键词里面一个dom是有id的\n    // 所以选用了兄弟节点的方法。\n    let arr = keysDOM.parentNode.children;\n    let res = '';\n    for(let j=1;j&#x3C;arr.length;j++){\n      res += arr[j].text.replace(/ /g, '').replace(/\\n/g, '');\n    }\n\t\treturn res;\n\t}, keysDOM);\n\tawait page.waitFor(3000);\n    // 节省内存，每次查询完就关闭页面\n\tawait page.close();\n\treturn {\n\t\tabstract: abstract,\n\t\tschool: school,\n\t\tkeywords: keys,\n\t};\n}\n\n</code></pre>\n<p>这样就得到了完整的数据：</p>\n<pre><code class=\"language-json\">{\n\t\"data\": [\n\t\t{\n\t\t\t\"title\": \"5052铝合金/镀锌钢涂粉CO2激光熔钎焊工艺特性\",\n\t\t\t\"name\": [\n\t\t\t\t\"樊丁\",\n\t\t\t\t\"蒋锴\",\n\t\t\t\t\"余淑荣\",\n\t\t\t\t\"张健\"\n\t\t\t],\n\t\t\t\"link\": \"http://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&#x26;filename=HJXB201401001&#x26;dbname=CJFD2014\",\n\t\t\t\"start\": \"1\",\n\t\t\t\"end\": \"4\",\n\t\t\t\"abstract\": \"以5052铝合金和热镀锌ST04Z钢为研究对象,采用预置涂粉CO2激光搭接熔钎焊方法进行工艺试验.利用光学显微镜、扫描电镜和拉伸试验机对熔钎焊接头的微观组织和力学性能进行了研究.结果表明,涂助溶剂和粉末后,焊缝成形明显改善,镀锌层没有烧损;熔—钎焊接头过渡层最大厚度小于10μm,针状Al-Fe金属间化合物没有向熔化的铝侧明显析出;接头具有较高的力学性能,最大机械抗载能力可达到208 MPa,约为5052铝合金母材抗拉强度的95.41%. \",\n\t\t\t\"school\": \"兰州理工大学甘肃省有色金属新材料省部共建国家重点实验室,兰州理工大学有色金属合金及加工教育部重点实验室\",\n\t\t\t\"keywords\": \"铝钢;激光焊接;熔钎焊;粉末;\"\n\t\t},\n        ...\n    ]\n}\n\n</code></pre>\n<h2>将数据导出到EXCEL</h2>\n<p>这里就是将数据导出啦，需求里面写的还是很明白的：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/502233/1610436480515-8d1e0e12-02a0-40ca-90ca-173fbd56336f.png#align=left&#x26;display=inline&#x26;height=362&#x26;margin=%5Bobject%20Object%5D&#x26;originHeight=362&#x26;originWidth=1492&#x26;size=0&#x26;status=done&#x26;style=none&#x26;width=1492\" alt=\"\"></p>\n<p>我的想法就是根据每一个item的作者list的长度，首先是写出若干行，然后再将除了作者和单位之外的行进行合并。</p>\n<pre><code class=\"language-javascript\">const Excel = require('exceljs');\nconst data = require('../data1.json');\n\n// 数据预处理\nlet input = [];\nlet obj = data.data;\nobj.forEach((item, index) => {\n\tlet len = item.name.length;\n\n\tlet link = item.link;\n\tlet reg = /HJXB201(4|5)([0-9]{2})/i;\n\n\tlet year = -1;\n\tlet juan = -1;\n\tlet vol = -1;\n\tif (link) {\n\t\tyear = link.substring(link.length - 4, link.length);\n        // 2014年是35卷，2015=36卷\n\t\tjuan = year == 2014 ? 35 : 36;\n        // 期数在链接里面就可以查出，是第二个匹配项\n\t\tvol = reg.exec(link)[2];\n\t}\n\n\tfor (let i = 0; i &#x3C; len; i++) {\n        // 将数据整理成exceljs需要的样子\n\t\tinput.push({\n\t\t\tindex: index + 1,\n\t\t\ttitle: item.title,\n\t\t\tname: item.name[i],\n\t\t\tlang: '中文',\n\t\t\tschool: item.school,\n\t\t\tabstract: item.abstract,\n\t\t\tyear: year,\n\t\t\tjuan: juan,\n\t\t\tvol: vol,\n\t\t\tkeyType: '关键词',\n\t\t\tpaperName: '焊接学报',\n\t\t\tkeywords: item.keywords,\n\t\t\tstart: item.start,\n\t\t\tend: item.end,\n\t\t});\n\t}\n});\n\n</code></pre>\n<p>接着使用exceljs来创建工作表：</p>\n<pre><code class=\"language-javascript\">// excel处理\nlet workbook = new Excel.Workbook();\n\nworkbook.creator = 'xujx';\n\nlet sheet = workbook.addWorksheet('sheet 1');\n\nsheet.columns = [\n\t{ header: '序号', key: 'index', width: 10 },\n\t{ header: '唯一标识类型', key: 'onlykey', width: 10 },\n\t{ header: '唯一标识', key: 'onlyid', width: 10 },\n\t{ header: '题名', key: 'title', width: 15 },\n\t{ header: '正文语种', key: 'lang', width: 10 },\n\t{ header: '责任者/责任者姓名', key: 'name', width: 15 },\n\t{ header: '责任者/责任者机构/责任机构名称', key: 'school', width: 15 },\n\t{ header: '摘要', key: 'abstract', width: 15 },\n\t{ header: '主题/主题元素类型', key: 'keyType', width: 15 },\n\t{ header: '主题/主题名称', key: 'keywords', width: 15 },\n\t{ header: '期刊名称', key: 'paperName', width: 15 },\n\t{ header: '出版年', key: 'year', width: 15 },\n\t{ header: '规范期刊URI', key: 'URI', width: 15 },\n\t{ header: '卷', key: 'juan', width: 15 },\n\t{ header: '期', key: 'vol', width: 15 },\n\t{ header: '起始页码', key: 'start', width: 15 },\n\t{ header: '结束页码', key: 'end', width: 15 },\n\t{ header: '收录信息/收录类别代码', key: 'typeCode', width: 15 },\n];\n\nsheet.addRows(input);\n\n</code></pre>\n<p>在这之后就合并单元格：</p>\n<pre><code class=\"language-javascript\">// 合并单元格\n// 首先获取每一项的作者个数，保存在一个array中\nlet nameLength = [];\nobj.forEach(item => {\n\tif (item.name.length) {\n\t\tnameLength.push(item.name.length);\n\t} else {\n\t\tnameLength.push(0);\n\t}\n});\n\n</code></pre>\n<p>合并单元格从第二行开始（第一行是表头）：</p>\n<pre><code class=\"language-javascript\">for (let j = 0; j &#x3C; ret.length; j += 2) {\n\tsheet.mergeCells(`A${ret[j]}:A${ret[j + 1]}`);\n\tsheet.mergeCells(`B${ret[j]}:B${ret[j + 1]}`);\n\tsheet.mergeCells(`C${ret[j]}:C${ret[j + 1]}`);\n\tsheet.mergeCells(`D${ret[j]}:D${ret[j + 1]}`);\n\tsheet.mergeCells(`E${ret[j]}:E${ret[j + 1]}`);\n\tsheet.mergeCells(`H${ret[j]}:H${ret[j + 1]}`);\n\tsheet.mergeCells(`I${ret[j]}:I${ret[j + 1]}`);\n\tsheet.mergeCells(`J${ret[j]}:J${ret[j + 1]}`);\n\tsheet.mergeCells(`K${ret[j]}:K${ret[j + 1]}`);\n\tsheet.mergeCells(`L${ret[j]}:L${ret[j + 1]}`);\n\tsheet.mergeCells(`M${ret[j]}:M${ret[j + 1]}`);\n\tsheet.mergeCells(`N${ret[j]}:N${ret[j + 1]}`);\n\tsheet.mergeCells(`O${ret[j]}:O${ret[j + 1]}`);\n\tsheet.mergeCells(`P${ret[j]}:P${ret[j + 1]}`);\n\tsheet.mergeCells(`Q${ret[j]}:Q${ret[j + 1]}`);\n\tsheet.mergeCells(`R${ret[j]}:R${ret[j + 1]}`);\n}\n\nworkbook.xlsx.writeFile('1.xlsx').then(function() {\n\t// done\n\tconsole.log('done');\n});\n\n</code></pre>\n<p>上面的数组<code>ret</code>是这样得到的，它保存了合并单元格的起止位置。</p>\n<pre><code class=\"language-javascript\">let ret = [];\n// 是从第2行开始\nret.push(2);\n// 对于每一个作者长度\nfor (let i = 0; i &#x3C; nameLength.length; i++) {\n    // 表示尾部的那个节点的位置\n\tlet head = ret[ret.length - 1];\n    // 目前数组长度为偶数，说明现在是成对的，因此需要把尾部节点的下一个数加入数组\n\tif (ret.length % 2 === 0) {\n\t\tret.push(head + 1);\n        // 同时，由于这一循环并没有用到nameLength数组，所以不算做循环++\n    \ti--;\n\t} else {\n        // 如果是奇数，说明需要添加一个步长，来合并单元格\n        // 所以需要一个作者个数-1的步长\n    \tret.push(head + nameLength[i] - 1);\n\t}\n}\n\n</code></pre>\n<p>这样就完成了99%了！</p>\n<h3>未完成的部分</h3>\n<ul>\n<li>但是需求里面还说需要作者和作者的单位对应，这就需要把文章下载下来分析了。</li>\n<li>我目前的尝试是<code>pdf2json</code>，不过并不成功，时间紧迫就开启人工智能模式 ——手动搞了一下</li>\n<li>确实有点累。</li>\n</ul>\n<h2>源码地址</h2>\n<p><a href=\"https://github.com/Alfxjx/CNKI-HJXB-Crawler\">Github 求个star吧555</a></p>\n<p><a href=\"https://juejin.cn/post/6844904083921305614\">原文地址</a></p>\n","coverImage":"/assets/blog/puppeteer.jfif"}},"__N_SSG":true}