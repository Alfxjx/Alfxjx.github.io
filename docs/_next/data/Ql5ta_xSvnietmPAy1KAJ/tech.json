{"pageProps":{"newOneContent":{"content":"<blockquote>\n<p>同时发布于 <a href=\"https://www.yuque.com/alfxjx/notes/wchz9f\">语雀</a></p>\n</blockquote>\n<h2>引子</h2>\n<p>最近公司在搭建部门的统一平台，我负责了统一登录前端的开发，因为要对接很多的系统，所以开发了统一登录的sdk，说是sdk其实就是一个组件库。以此为契机，外加之前开发其他的系统中也用了很多种不同的组件库（饿了没-ui/vant/antd/chakra-ui...），今天写一篇文章说说，什么样的组件设计是比较合理的，以及如何设计一个好用的组件。</p>\n<h2>研究chakra-ui</h2>\n<p><img src=\"/assets/blog/chakra-ui.png\" alt=\"\"></p>\n<p>比较来说我觉得设计比较有特色的一个组件库，就是 <a href=\"https://chakra-ui.com/\">chakra-ui</a> 了，不过国内使用的并不多，我也是在之前技术选型的时候偶然找到的，但是仔细读了她的文档之后我发现这个是一个很有特色的组件库，下面细说：</p>\n<h3>样式自定义</h3>\n<p>找到这个 chakra-ui 的时候，就是因为需要在使用 tailwind CSS 的同时使用一个组件库，chakra-ui 的一个特色就是使用了和 tailwind CSS 几乎相同的样式 api , 例如：</p>\n<pre><code class=\"language-typescript\">import { Box } from \"@chakra-ui/react\"\n\n// m={2} refers to the value of `theme.space[2]`\n&#x3C;Box m={2}>Tomato&#x3C;/Box>\n\n// You can also use custom values\n&#x3C;Box maxW=\"960px\" mx=\"auto\" />\n\n// sets margin `8px` on all viewports and `16px` from the first breakpoint and up\n&#x3C;Box m={[2, 3]} />\n</code></pre>\n<p>这样只要你记住了 tailwind CSS 的api， 那么就可以很快的上手 chakra-ui 。\n那么这个是怎么实现的呢？\n一开始我以为是组件库使用了tailwind CSS ，但是看了源码发现，chakra 将 styled-components 进行了二次封装，而这种 tailwindLike 的 api 是进行了模拟导致的。\n在 <a href=\"https://github.com/chakra-ui/chakra-ui/blob/main/packages/styled-system/src/config/background.ts\">/packages/styled-system/config/</a> 里面 写入了不同样式以及缩写，以 background 为例：</p>\n<pre><code class=\"language-typescript\">export const background: Config = {\n  background: t.colors(\"background\"),\n  ...\n  bg: t.colors(\"background\"),\n  ...\n}\n</code></pre>\n<p>这样实现的，可以说把dirty的工作封装了起来，展示出来的结果都是好用的。</p>\n<h3>组件组合</h3>\n<p>书接上文，组件里面做了很多的映射封装，为了减少代码量，统一进行管理，组件库进行了组件的组合（compose）。从一个基本的组件出发，通过默认一些样式，创造了一些新的组件。\n例如<a href=\"https://chakra-ui.com/docs/layout/center#square-and-circle\"> Square Circle </a>组件，是基于 Box 组件extend而来的。</p>\n<pre><code class=\"language-typescript\">export const Square = forwardRef&#x3C;SquareProps, \"div\">((props, ref) => {\n  const { size, centerContent = true, ...rest } = props\n\n  const styles: SystemStyleObject = centerContent\n    ? { display: \"flex\", alignItems: \"center\", justifyContent: \"center\" }\n    : {}\n\n  return (\n    &#x3C;Box\n      ref={ref}\n      boxSize={size}\n      __css={{\n        ...styles,\n        flexShrink: 0,\n        flexGrow: 0,\n      }}\n      {...rest}\n    />\n  )\n})\n\nif (__DEV__) {\n  Square.displayName = \"Square\"\n}\n\nexport const Circle = forwardRef&#x3C;SquareProps, \"div\">((props, ref) => {\n  const { size, ...rest } = props\n  return &#x3C;Square size={size} ref={ref} borderRadius=\"9999px\" {...rest} />\n})\n\nif (__DEV__) {\n  Circle.displayName = \"Circle\"\n}\n</code></pre>\n<p>这样写减少了重复的代码并且可以保持更好的可维护性。我们在开发的过程中也可以借鉴这种模式，开发出最抽象的组件，从这个最抽象的父类出发来进行派生。</p>\n<h3>Theminig</h3>\n<p>chakra ui 的另外一个特点就是拥有一个高度自定义的主题系统， 使用的方式类似于 tailwind CSS <a href=\"https://tailwindcss.com/docs/theme\">设置</a>，也就是说你可同时将一个theme文件应用到两个库中，使用方法可以看一下<a href=\"https://chakra-ui.com/docs/theming/customize-theme\">chakra文档</a>，那么这个主题是如何实现的呢？\n首先 chakra ui 维护了一个default theme ,用于在没有自定义 theme 或者 自定义了一部分的theme的时候进行合并，合并的过程（<code>toCSSVar</code>）是使用了 <code>createThemeVars</code> 方法将自己配置的theme转化成css var变量，然后将默认的theme和生成的theme进行合并。最后在 <ThemeProvider />:</p>\n<pre><code class=\"language-typescript\">\nexport const ThemeProvider = (props: ThemeProviderProps) => {\n  const { cssVarsRoot = \":host, :root\", theme, children } = props\n  const computedTheme = React.useMemo(() => toCSSVar(theme), [theme])\n  return (\n    &#x3C;EmotionThemeProvider theme={computedTheme}>\n      &#x3C;Global styles={(theme: any) => ({ [cssVarsRoot]: theme.__cssVars })} />\n      {children}\n    &#x3C;/EmotionThemeProvider>\n  )\n}\n</code></pre>\n<p>这里是借用了 emotion 的 <a href=\"https://emotion.sh/docs/theming#themeprovider-reactcomponenttype\">ThemeProvider</a>。这么一看其实主题设置还是很简单的。这样可以很方便的设置了一个自定义的主题\n除此之外，如果想在二次开发的主题上进行三次开发，可以使用 chakra-ui 提供的api <a href=\"https://chakra-ui.com/docs/theming/customize-theme#using-theme-extensions\">Theme extensions</a>。提供了一个类似于 HOC 的包裹函数，以withDefaultColorScheme为例：</p>\n<pre><code class=\"language-typescript\">export function withDefaultColorScheme({colorScheme,components}): ThemeExtension {\n  return (theme) => {\n    let names = Object.keys(theme.components || {})\n\t\t// ....\n    return mergeThemeOverride(theme, {\n      components: Object.fromEntries(\n        names.map((componentName) => {\n          const withColorScheme = {\n            defaultProps: {\n              colorScheme,\n            },\n          }\n          return [componentName, withColorScheme]\n        }),\n      ),\n    })\n  }\n}\n</code></pre>\n<p>将配置的颜色Scheme赋值给了配置的对应的组件。内部实现大同小异，都是调用了 <code>mergeThemeOverride</code>这个方法</p>\n<pre><code class=\"language-typescript\">export function mergeThemeOverride&#x3C;BaseTheme extends ChakraTheme = ChakraTheme>(\n  ...overrides: ThemeOverride&#x3C;BaseTheme>[]\n): ThemeOverride&#x3C;BaseTheme> {\n  return mergeWith({}, ...overrides, mergeThemeCustomizer)\n}\n</code></pre>\n<p>内部使用了 <code>lodash.mergewith</code>的方法实现融合，对于此方法 chakra-ui 写了一个mergeThemeCustomizer 作为 <a href=\"https://www.lodashjs.com/docs/lodash.mergeWith/\">lodash.mergwith</a> 的第三个参数，这里的自定义mergeThemeCustomizer方法使用了递归的方式进行merge。</p>\n<pre><code class=\"language-typescript\">\nfunction mergeThemeCustomizer(\n  source: unknown,\n  override: unknown,\n  key: string,\n  object: any,\n) {\n  if (\n    (isFunction(source) || isFunction(override)) &#x26;&#x26;\n    Object.prototype.hasOwnProperty.call(object, key)\n  ) {\n    return (...args: unknown[]) => {\n      const sourceValue = isFunction(source) ? source(...args) : source\n\n      const overrideValue = isFunction(override) ? override(...args) : override\n\n      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer)\n    }\n  }\n\n  // fallback to default behaviour\n  return undefined\n}\n</code></pre>\n<h3>外部组件与二次封装</h3>\n<p>从上面可以看到，组件库也不是全部从零开始，也使用了很多第三方的库，例如样式库 emotion， styled-components，工具方法库 lodash，这里没啥特别好说的。\n另外chakra-ui官方也推荐将组件库和许多第三方的lib一起使用，例如 表单验证库<a href=\"https://chakra-ui.com/docs/form/form-control#usage-with-form-libraries\">formik</a>，此外，在element-ui中也会直接封装throttle-debounce， async-validator等第三方的库。</p>\n<h3>提供escape</h3>\n<p>在使用其他的组件库的时候，很多情况下会出现某些组件的细节和设计要求不一致的情况，对于element-ui和ant design来说，由于使用了sass/less等预处理器，可以使用覆盖的方式来覆写样式。在 chakra ui 中，则提供了一个 <a href=\"https://chakra-ui.com/docs/features/the-sx-prop\">sx Props</a> 来直接向组件传入样式。</p>\n<pre><code class=\"language-typescript\">&#x3C;Box sx={{ \"--my-color\": \"#53c8c4\" }}>\n  &#x3C;Heading color=\"var(--my-color)\" size=\"lg\">\n    This uses CSS Custom Properties!\n  &#x3C;/Heading>\n&#x3C;/Box>\n</code></pre>\n<p>这个方式很强大，还支持嵌套样式，media query等。这里的sx是一个封装自@emotion/styled的方法，在 <a href=\"https://github.com/chakra-ui/chakra-ui/blob/main/packages/system/src/system.ts\">packages/system/src/system.ts</a>, styled方法里面调用了 toCSSObject ，这里拿取到了输入的样式，而所有的ui 组件都会调用这个 styled方法，sx Props 就这样全局生效了。</p>\n<pre><code class=\"language-typescript\">export function styled&#x3C;T extends As, P = {}>(\n  component: T,\n  options?: StyledOptions,\n) {\n  const { baseStyle, ...styledOptions } = options ?? {}\n\t// ...\n  const styleObject = toCSSObject({ baseStyle })\n  return _styled(\n    component as React.ComponentType&#x3C;any>,\n    styledOptions,\n  )(styleObject) as ChakraComponent&#x3C;T, P>\n}\n\nexport const toCSSObject: GetStyleObject = ({ baseStyle }) => (props) => {\n  const { theme, css: cssProp, __css, sx, ...rest } = props\n  const styleProps = objectFilter(rest, (_, prop) => isStyleProp(prop))\n  const finalBaseStyle = runIfFn(baseStyle, props)\n  const finalStyles = Object.assign({}, __css, finalBaseStyle, styleProps, sx)\n  const computedCSS = css(finalStyles)(props.theme)\n  return cssProp ? [computedCSS, cssProp] : computedCSS\n}\n</code></pre>\n<h2>如何设计一个好用的组件</h2>\n<p>参考了很多设计，那么如何设计一个好用的组件呢，这里以一个progressBar为例。</p>\n<h3>MVP 版本以及存在的问题</h3>\n<pre><code class=\"language-typescript\">import React, { useState, useEffect } from \"react\";\nimport styled from \"styled-components\";\n\nconst ProgressBarWrapper = styled.div&#x3C;{ progress: number }>`\n\twidth: 100%;\n\theight: 4px;\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tz-index: 9999;\n\t.bar-used {\n\t\tbackground: #34c;\n\t\twidth: ${({ progress }) => progress + \"%\"};\n\t\theight: 100%;\n\t\tborder-radius: 0 2px 2px 0;\n\t}\n`;\n\nconst ProgressBar = () => {\n\tconst [progress, setProgress] = useState(0);\n\tuseEffect(() => {\n\t\twindow.addEventListener(\"scroll\", () => {\n\t\t\tsetProgress(\n\t\t\t\t(document.documentElement.scrollTop /\n\t\t\t\t\t(document.body.scrollHeight - window.innerHeight)) *\n\t\t\t\t\t100\n\t\t\t);\n\t\t});\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"scroll\", () => {});\n\t\t};\n\t});\n\treturn (\n\t\t&#x3C;ProgressBarWrapper progress={progress}>\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\n\t\t&#x3C;/ProgressBarWrapper>\n\t);\n};\n\nexport { ProgressBar };\n\n</code></pre>\n<p>这里展示了一个页面顶部进度条的组件，类似于 <a href=\"https://es6.ruanyifeng.com/#docs/decorator\">es6标准入门</a> 这里的样式，上面的功能可以很快的就实现出来，但是只是比较符合单一的应用场景，进度条固定在顶部，只有从左往右增长一种情况。但是实际上的进度条可能会用到很多的地方，因此我们需要对照可能的场景以及代码中的变量进行判断，哪些是需要做成参数，并设置对应的默认值。\n需求有以下几种：</p>\n<ol>\n<li>颜色可调，位置可调，方向可调，这三个是比较全局的可调整类型</li>\n<li>具体样式修改，高度修改，圆角修改，这些是其他的一些props，如果保持progressbar的功能不变可能不太会用到的props</li>\n</ol>\n<p>此外，这里的progeressBar还存在的一个问题就是，这个组件将展示和逻辑杂糅在了一起，组件内部就有对于页面滚动进度的计算逻辑（useEffect），但是如果使用的时候不需要这个逻辑呢？\n根据上面的一些要修改的点以及一些问题，我们来对这个组件进行拆分和重构。</p>\n<h3>重构</h3>\n<p>首先是把逻辑和展示分开。新建一个hook用于计算百分比。</p>\n<pre><code class=\"language-typescript\">import { useState, useEffect } from \"react\";\n\nexport function useProgress() {\n\tconst [progress, setProgress] = useState(0);\n\tuseEffect(() => {\n\t\twindow.addEventListener(\"scroll\", () => {\n\t\t\tsetProgress(\n\t\t\t\t(document.documentElement.scrollTop /\n\t\t\t\t\t(document.body.scrollHeight - window.innerHeight)) *\n\t\t\t\t\t100\n\t\t\t);\n\t\t});\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"scroll\", () => {});\n\t\t};\n\t});\n\treturn progress;\n}\n\n</code></pre>\n<p>之后是给需要的参数添加props,并设置默认值，这里只以高度为例，设置一个可选的高度参数，当传入的时候就使用传入的值否则是默认的。\n同时注意颜色等可以使用一个theme系统。</p>\n<pre><code class=\"language-typescript\">\nconst ProgressBarWrapper = styled.div&#x3C;{ progress: number; height?: string }>`\n\twidth: 100%;\n\theight: ${({ height }) => (height ? height : \"4px\")};\n\t.bar-used {\n\t\tbackground: ${({ theme }) => theme.themeColor};\n\t\twidth: ${({ progress }) => progress + \"%\"};\n\t\theight: 100%;\n\t\tborder-radius: ${({ height }) =>\n\t\t\theight ? `0 calc( ${height}/ 2) calc(${height}/ 2) 0` : \"0 2px 2px 0\"};\n\t}\n`;\n</code></pre>\n<p>除此之外，将fixed布局抽象出来，方便后面进行组合</p>\n<pre><code class=\"language-typescript\">const FixedTopWrapper = styled.div`\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tz-index: 9999;\n`;\n// 组合之后就是这样的\nconst ProgressBarWrapperFixed = styled(FixedTopWrapper)&#x3C;{\n\tprogress: number;\n\theight?: string;\n}>`.....`;\n\n</code></pre>\n<p>这样组件就是这样的，分成了默认好用的 ProgressBar 和 自定义功能更多的 SimpleProgressBar</p>\n<pre><code class=\"language-typescript\">\ninterface ProgressProps {\n\tprogress: number;\n\theight?: string;\n}\nconst ProgressBar = ({\n\theight,\n}: Omit&#x3C;ProgressProps, \"progress\">) => {\n\tconst progress = useProgress();\n\treturn (\n\t\t&#x3C;ProgressBarWrapperFixed progress={progress} height={height}>\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\n\t\t&#x3C;/ProgressBarWrapperFixed>\n\t);\n};\n\nconst SimpleProgressBar = ({\n\tprogress,\n\theight,\n}: ProgressProps) => {\n\treturn (\n\t\t&#x3C;ProgressBarWrapper progress={progress} height={height}>\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\n\t\t&#x3C;/ProgressBarWrapper>\n\t);\n};\n</code></pre>\n<p>另外就是添加 合适的 escape，方便使用的时候如果不符合需要可以自行修改。这里直接在组件上添加一个 style参数，</p>\n<pre><code class=\"language-typescript\">// usage\n&#x3C;ProgressBar style={{ background: \"#000\" }}>&#x3C;/ProgressBar>\n// 修改组件 添加rest参数接受附加的style,并且修改一下类型\nconst ProgressBar = ({\n\theight,\n\t...rest\n}: Omit&#x3C;ProgressProps, \"progress\"> &#x26; React.HTMLAttributes&#x3C;HTMLDivElement>) => {\n\tconst progress = useProgress();\n\treturn (\n\t\t&#x3C;ProgressBarWrapperFixed {...rest} progress={progress} height={height}>\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\n\t\t&#x3C;/ProgressBarWrapperFixed>\n\t);\n};\n</code></pre>\n<p>这样就写好了一个好用的ProgressBar组件了，并且提供了SimpleProgressBar用于其他的自定义用途。</p>\n<p>在线演示：<a href=\"https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010\">https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010</a></p>\n<h2>总结</h2>\n<p>经过上面对 chakra ui 组件库源码的研究以及一个示例，相信你以及知道了该如何设计一个好用的组件库了，希望你能为你的公司也开发一套组件库，能更好的完成你的kpi/okr/etc...</p>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://github.com/chakra-ui/chakra-ui\">https://github.com/chakra-ui/chakra-ui</a></li>\n<li><a href=\"https://chakra-ui.com/\">https://chakra-ui.com/</a></li>\n<li><a href=\"https://emotion.sh/\">https://emotion.sh/</a></li>\n<li><a href=\"https://www.lodashjs.com/\">https://www.lodashjs.com/</a></li>\n<li><a href=\"https://tailwindcss.com/\">https://tailwindcss.com/</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN\">https://element.eleme.cn/#/zh-CN</a></li>\n<li><a href=\"https://ant.design/index-cn\">https://ant.design/index-cn</a></li>\n<li><a href=\"https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen\">https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen</a></li>\n</ol>\n","title":"如何设计一个好用的组件-以chakra-ui为例","date":"2021-10-28T12:52:42.712Z","slug":"design-a-component","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/chakra-ui.png"},"allPosts":[{"title":"如何设计一个好用的组件-以chakra-ui为例","date":"2021-10-28T12:52:42.712Z","slug":"design-a-component","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/chakra-ui.png","excerpt":"最近公司在搭建部门的统一平台，我负责了统一登录前端的开发，因为要对接很多的系统，所以开发了统一登录的sdk，说是sdk其实就是一个组件库。以此为契机，外加之前开发其他的系统中也用了很多种不同的组件库（饿了没-ui/vant/antd/chakra-ui...），今天写一篇文章说说，什么样的组件设计是比较合理的，以及如何设计一个好用的组件。"},{"title":"Next.js 项目迁移到 create-react-app","date":"2021-09-20T17:10:00.000Z","slug":"migrating-cra","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/nextjs.jfif","excerpt":"公司的统一登录项目之前部署在私有云上采用的是 `next.js`，虽然存在一些问题但是还能使用。现在统一部署到公司自建的 devops 平台，由于平台只有通用的 `react` 流水线，部署之后是客户端渲染的类型（`CSR`），导致之前的服务端渲染部署上去存在很多问题，调整成 `SSG` 模式部署上去也存在很多问题，例如 `redux` 状态管理问题以及 `router` 跳转问题，针对这些问题，最终决定从 `next.js` 框架切换到 `create- react-app` 的客户端渲染模式。这个需求还是很奇葩的，网上搜了一圈也没这个先例，于是就写了此文记录一下迁移以及都 `CRA` 的一些配置。"},{"title":"[CSS]矩形进度条的两种实现","date":"2021-07-19T20:35:07.322Z","slug":"loading-in-css","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/css-loading.png","excerpt":"最近开发接到一个需求，前端展示付款的验证码，验证码时效 10 分钟，到期过期，同时在二维码的外侧有一个倒计时条，原本的实现方式是通过 JS 来控制，设置左上，左下，右上，右下四个矩形，每个矩形只显示一个折角的边框，从而模拟整个外框。"},{"title":"[Vue]前端项目重构小记","date":"2021-04-13T16:35:07.322Z","slug":"refactor-vue","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/vue-jquery.jfif","excerpt":"原有的旧项目原本时前后端不分离的，在开发过程中对前端开发人员需要全项目启动，比较麻烦，同时项目在进行前后端分离之后，前端部分开发使用的时http-server启动服务，不支持HMR，修改完成之后需要手动刷新。另外，原本的项目采用的基于jQuery的传统技术栈，在之后项目的迭代升级中，制约了项目的开发。因此开始了本次的前端项目重构。"},{"title":"[Regex]手把手教你解析一个URL字符串","date":"2021-01-22T22:15:42.712Z","slug":"rgex-url","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/regex.jpeg","excerpt":"本文从如何使用正则去判断一个字符串是不是url地址出发，介绍了正则的相关规则与技巧"},{"title":"[译] 使用 clamp() 进行响应式设计","date":"2020-11-05T14:52:42.712Z","slug":"clamp-design","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/css-math-functions.jpg","excerpt":"新的 CSS 函数 `clamp()` 提供了一种通过给目标值设置最大最小值的范围来计算实际值方法。它的语法是 `clamp([min], [calculated], [max])`。当你基于屏幕尺寸，使用长度单位 `vw` 来缩放一些值时，这个函数很有用。"},{"title":"如何用正则表达式判断一个数是否是质数","date":"2020-10-08T12:44:58.817Z","slug":"judge-a-number","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","excerpt":"本文展示了一种判断一个数是否是质数的奇技淫巧，采用的是正则表达式方法。"},{"title":"CSS 的 RGB 颜色覆盖","date":"2020-09-27T08:18:39.741Z","slug":"css-rgb-color","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/css-rgb.jpeg","excerpt":"浅薄的研究了一下，希望可以和我讨论"},{"title":"[译] 如何基于 D3.js 使用外部数据源创建图表","date":"2020-09-27T08:18:39.741Z","slug":"d3-charts","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/d3.png","excerpt":"D3 是一个运行于 web 端的 Javascript 可视化库。D3 的第一个版本发布于 2011 年，并且随着社区支持的增加而成熟。对于早期版本的 D3，学习曲线有些陡峭，但对于 JavaScript 初学者来说，最新版本学习起来更容易。大多数为 Web 构建的可视化都依赖于动态数据源 —— 因此，本文的目的是使您能够在 D3 中使用外部数据源创建图表。"},{"title":"[Puppeteer]我是如何做到写EXCEL时速3k行的","date":"2020-05-03T16:35:07.322Z","slug":"puppeteer-cnki","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","coverImage":"/assets/blog/puppeteer.jfif","excerpt":"之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目统计某某期刊的信息。粗粗看了一下14个人的群里，有我这样延毕的老狗 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法："}]},"__N_SSG":true}