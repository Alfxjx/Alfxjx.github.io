{"pageProps":{"newOneContent":{"content":"<h2>why axios？</h2>\n<p>前后端交互最常见的就是 <code>http</code> 请求，为了提高效率，需要对 <code>http</code> 请求进行封装，目前的现代开发过程中，可以使用 Axios，一种对于 <code>http</code> 请求的封装，或者是<code>fetch</code>，全新的异步请求<code>api</code>，本文主要是介绍我们项目中是如何根据后端返回的类型，对请求进行封装。</p>\n<p><a href=\"https://www.axios-http.cn/\">Axios</a> 是一个基于 promise 的网络请求库，可以用于浏览器和 <code>node.js</code>。<code>api</code> 简单，返回一个 <code>Promise</code> 对象，以供异步的处理。\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API\">Fetch API</a> 提供了一个 JavaScript 接口，用于访问和操纵 <code>HTTP</code> 管道的一些具体部分，例如请求和响应。它还提供了一个全局 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/fetch\">fetch()</a> 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。\n事实上两种都可以，相信你看了这篇文章之后也可以自己封装一下 <code>fetch</code>，甚至可以使用适配器模式去一统两种 api。那下面就看看是怎么对 <code>axios</code> 进行封装的。</p>\n<h2>Requests</h2>\n<p>首先先看看实际生产中，<code>axios</code> 需要做什么工作:</p>\n<h3>拦截器，错误处理</h3>\n<p><code>axios</code> 在使用的过程中需要生成一个 <code>axiosBase</code> 实例，从开始发送请求到收到响应可以分成以下几个过程：</p>\n<ol>\n<li>发起请求 <code>axiosInstance.get()</code></li>\n<li>进入请求拦截器 <code>axiosBase.interceptors.request.use(...requestIntercepter);</code></li>\n<li>(server) 服务端进行响应</li>\n<li>进入响应拦截器 <code>axiosBase.interceptors.response.use(responseIntercepter);</code></li>\n<li>返回响应，在业务中进行使用。</li>\n</ol>\n<p>可以看出除了请求和响应之外，<code>axios</code> 提供的最多的配置就是请求拦截和响应拦截，程序设计的目的就是写出可维护并且能复用的代码，因此在两个拦截器中类似管道做通用的处理。</p>\n<h3>请求和响应</h3>\n<ol>\n<li>业务中常见的有 <code>GET/POST/PUT</code> 请求，<code>post</code> 请求又会根据 <code>content-type</code> 分成两种，针对这些变化的量，锚定住代码中不变的量，需要进行设计。</li>\n<li>在常见的业务中，可能会是使用 <code>access-token</code> 的方式进行鉴权，在请求的拦截器中，可以拿到 <code>config</code> 参数，可以添加认证信息</li>\n<li>对于返回的响应报文，由于一般的返回报文是一样的，在响应拦截器中对响应进行第一步的通用处理，减少业务端的重复代码。</li>\n</ol>\n<h3>业务异常 VS Http 异常</h3>\n<p>响应拦截中，最常见的就是对异常情况进行处理，由于 <code>axios</code> 返回的是一个 <code>Promise</code>对象，因此要对返回的结果进行处理判断，之后返回 <code>Promise.reject</code> / <code>Promise.resolve</code>; 对于 <code>http</code> 的异常来说，由于本身就是一个 error，一般会放在 <code>Promise.catch</code> 里面去处理。</p>\n<h2>Wrapping</h2>\n<h3>生成实例</h3>\n<p>一般来说 baseURL 是不太会改变的,如果项目如果是比较稳定的话，可以把全局的设置也写上，如： <code>withCredentials</code></p>\n<pre><code>axios.defaults.headers.post[\"Content-Type\"] = \"application/json\";\naxios.defaults.withCredentials = true;\nconst baseURL = NODE_ENV === \"development\" ? \"/api\" : VUE_APP_PROD_API;\n\n// 基本的axios实例\nconst axiosBase = axios.create({\n\tbaseURL: baseURL,\n});\n</code></pre>\n<p>如果项目中依赖多个api，那么这里可以生成多个实例，配置不同的 baseURL (开发中需要配置对于的proxies).</p>\n<pre><code>// next.js 之类的 jamstack，可以自己生成 api routes 的，具有不同的 backend\nconst axioRoutes = axios.create({\n  baseURL: \"/api-routes\"\n});\n</code></pre>\n<h3>拦截器</h3>\n<p>拦截器的主要功能就是对请求和响应进行处理，包装，最常见的就是附带token进行鉴权的操作：</p>\n<pre><code>axiosBase.interceptors.request.use((config: AxiosRequestConfig) => {\n\tconst token = sessionStorage.getItem(\"token\");\n\tif (token &#x26;&#x26; config.headers) {\n\t\tconfig.headers.Authorization = `Bearer ${token}`;\n\t}\n\treturn config;\n});\naxiosBase.interceptors.response.use(\n\t(res: AxiosResponse&#x3C;IResponse&#x3C;any>>) => {\n\t\tif (!res) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Object.prototype.hasOwnProperty.call(res.data, \"token\")) {\n\t\t\tsessionStorage.setItem(\"token\", res.data.token as string);\n\t\t}\n\t\treturn res;\n\t},\n\t(err: AxiosError&#x3C;{ errorMessage: string; success: boolean }>) =>\n\t\tPromise.reject(err)\n);\n\n</code></pre>\n<h2>处理异常</h2>\n<p>请求一个很重复的操作就是处理异常，一般来说异常都很有规律性，可分成业务操作错误导致的业务异常和由于请求失败导致的HTTP异常。</p>\n<h3>业务异常</h3>\n<p><code>AxiosInstance</code> 会返回一个 <code>Promise</code>，对于业务异常都是在http returnCode 为200的时候。以 POST 请求为例子：</p>\n<p>定义一个 标准的返回体：</p>\n<pre><code>export interface IResponse&#x3C;T> {\n\tdata: T;\n\terrorMessage: string;\n\tsuccess: boolean;\n\ttoken?: string;\n}\n</code></pre>\n<p>当返回success为false的时候，表示出现了业务异常。 由于是Promise.then，可以在拦截器里面进行处理，也可以在实例返回中进行处理，这个地方如果不同的请求方法处理方式不同，就放到对应请求的实例里面去处理，反之就存在拦截器就可以。一般来说不同的请求方式返回的应是一致的：</p>\n<pre><code>axiosBase.interceptors.response.use(\n\t(res: AxiosResponse&#x3C;IResponse&#x3C;any>>) => {\n\t\tif (!res) {\n\t\t\treturn false;\n\t\t}\n    if (!res.data.success) {\n\t\t\tnotify.warning(res.data.errorMessage);\n\t\t}\n    // token...\n\t},\n\t(err: AxiosError&#x3C;{ errorMessage: string; success: boolean }>) =>\n\t\tPromise.reject(err)\n);\n\n</code></pre>\n<h3>http error</h3>\n<p>对于 http 的异常，为了能够在封装中对其进行统一处理，需要对实例返回的Promise进行二次封装，还是以POST请求为例：</p>\n<pre><code>const httpFuncs = {\n  post&#x3C;T>(\n\t\t\turl: string,\n\t\t\tdata: any,\n\t\t\tconfig?: AxiosRequestConfig\n\t\t): Promise&#x3C;AxiosResponse&#x3C;IResponse&#x3C;T>>> {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\taxiosInstance\n\t\t\t\t\t.post(url, data, config)\n\t\t\t\t\t.then((res: AxiosResponse&#x3C;IResponse&#x3C;T>>) => resolve(res))\n          // http error\n\t\t\t\t\t.catch((err: AxiosError&#x3C;IErrorProps>) => {\n\t\t\t\t\t\tnotify.error(err.response?.data.errorMessage as string);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terr.response?.status === 401 &#x26;&#x26;\n\t\t\t\t\t\t\tisNoAuth(window.location.pathname)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\twindow.location.href = \"/person/login\";\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n}\n</code></pre>\n<p>在 <code>Promise.catch</code>中，处理返回的http error， 主要是401 和其他的500错误，这样就无需在具体的业务中关心这些异常的处理了。</p>\n<h2>More</h2>\n<p>到此，基本就是完成了对 <code>axios</code> 等请求库的常规封装。</p>\n<h3>设计模式？</h3>\n<p>或许可以使用一个httpFactory来对http请求进行统一的管理，这样就不会在从mock升级到正式的情况都时候，要到每一个实例里面去修改了。</p>\n<pre><code>enum enumType {\n\tBASE,\n\tMOCK\n}\n\nexport class HttpFactory {\n  public static getHttp(type:enumType){\n    switch (type) {\n      case enumType.BASE:\n        return http\n      case enumType.MOCK:\n        return httpMock\n      default:\n        return http\n    }\n  }\n}\n\n</code></pre>\n<p>使用的时候就直接使用 <code>HttpFactory.getHttp(enumType.MOCK).post&#x3C;IUserInfo>('/userinfo')</code>, 这样升级的时候，直接把枚举修改一下即可。</p>\n<p>实际生产中，可以使用配置文件来写这个枚举，这样就可以做到统一的管理。</p>\n<h2>End</h2>\n<p><a href=\"\">在线演示</a></p>\n<p>总的来说最适合应用的才是最好的，本文只是介绍了我们在改造为 ts + axios  + next.js 时候的经验，事实上对于 next.js，可以使用 <a href=\"https://swr.vercel.app\">useSWR</a> 等库，也进行了很好的封装。</p>\n<h2>References</h2>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000021071492\">比较 fetch()和 Axios</a></li>\n<li><a href=\"https://juejin.cn/post/6968630178163458084\">完整的 Axios 封装-单独 API 管理层、参数序列化、取消重复请求、Loading、状态码...</a></li>\n<li><a href=\"https://juejin.cn/post/7053471988752318472\">封装 Axios 只看这一篇文章就行了</a></li>\n<li><a href=\"https://juejin.cn/post/6969070102868131853#heading-4\">错误处理 - 最后的完善</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000021769678\">vue+ts下对axios的封装</a></li>\n<li><a href=\"https://www.cnblogs.com/double-W/p/12875623.html\">TS 泛型接口</a></li>\n<li><a href=\"https://markdowner.net/article/153598623580815360\">如何使用装饰器模式极大地增强fetch()</a></li>\n</ol>\n","title":"On Axios Requests & Wrapping","date":"2022-02-22T14:22:22.712Z","slug":"axios-wrapping","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["Axios","Next.js","TypeScript"],"coverImage":"/assets/blog/axios.jpg"},"allPosts":[{"title":"On Axios Requests & Wrapping","date":"2022-02-22T14:22:22.712Z","slug":"axios-wrapping","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["Axios","Next.js","TypeScript"],"coverImage":"/assets/blog/axios.jpg","excerpt":"前后端交互最常见的就是 `http` 请求，为了提高效率，需要对 `http` 请求进行封装，目前的现代开发过程中，可以使用 Axios，一种对于 `http` 请求的封装，或者是`fetch`，全新的异步请求`api`，本文主要是介绍我们项目中是如何根据后端返回的类型，对请求进行封装。"},{"title":"如何设计一个好用的组件-以chakra-ui为例","date":"2021-10-28T12:52:42.712Z","slug":"design-a-component","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["ui","react"],"coverImage":"/assets/blog/chakra-ui.png","excerpt":"最近公司在搭建部门的统一平台，我负责了统一登录前端的开发，因为要对接很多的系统，所以开发了统一登录的sdk，说是sdk其实就是一个组件库。以此为契机，外加之前开发其他的系统中也用了很多种不同的组件库（饿了没-ui/vant/antd/chakra-ui...），今天写一篇文章说说，什么样的组件设计是比较合理的，以及如何设计一个好用的组件。"},{"title":"Next.js 项目迁移到 create-react-app","date":"2021-09-20T17:10:00.000Z","slug":"migrating-cra","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["next.js","react"],"coverImage":"/assets/blog/nextjs.jfif","excerpt":"公司的统一登录项目之前部署在私有云上采用的是 `next.js`，虽然存在一些问题但是还能使用。现在统一部署到公司自建的 devops 平台，由于平台只有通用的 `react` 流水线，部署之后是客户端渲染的类型（`CSR`），导致之前的服务端渲染部署上去存在很多问题，调整成 `SSG` 模式部署上去也存在很多问题，例如 `redux` 状态管理问题以及 `router` 跳转问题，针对这些问题，最终决定从 `next.js` 框架切换到 `create- react-app` 的客户端渲染模式。这个需求还是很奇葩的，网上搜了一圈也没这个先例，于是就写了此文记录一下迁移以及都 `CRA` 的一些配置。"},{"title":"[CSS]矩形进度条的两种实现","date":"2021-07-19T20:35:07.322Z","slug":"loading-in-css","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["CSS","react"],"coverImage":"/assets/blog/css-loading.png","excerpt":"最近开发接到一个需求，前端展示付款的验证码，验证码时效 10 分钟，到期过期，同时在二维码的外侧有一个倒计时条，原本的实现方式是通过 JS 来控制，设置左上，左下，右上，右下四个矩形，每个矩形只显示一个折角的边框，从而模拟整个外框。"},{"title":"[Vue]前端项目重构小记","date":"2021-04-13T16:35:07.322Z","slug":"refactor-vue","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["vue"],"coverImage":"/assets/blog/vue-jquery.jfif","excerpt":"原有的旧项目原本时前后端不分离的，在开发过程中对前端开发人员需要全项目启动，比较麻烦，同时项目在进行前后端分离之后，前端部分开发使用的时http-server启动服务，不支持HMR，修改完成之后需要手动刷新。另外，原本的项目采用的基于jQuery的传统技术栈，在之后项目的迭代升级中，制约了项目的开发。因此开始了本次的前端项目重构。"},{"title":"[Regex]手把手教你解析一个URL字符串","date":"2021-01-22T22:15:42.712Z","slug":"rgex-url","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["regex","javascript"],"coverImage":"/assets/blog/regex.jpeg","excerpt":"本文从如何使用正则去判断一个字符串是不是url地址出发，介绍了正则的相关规则与技巧"},{"title":"[译] 使用 clamp() 进行响应式设计","date":"2020-11-05T14:52:42.712Z","slug":"clamp-design","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["CSS","翻译"],"coverImage":"/assets/blog/css-math-functions.jpg","excerpt":"新的 CSS 函数 `clamp()` 提供了一种通过给目标值设置最大最小值的范围来计算实际值方法。它的语法是 `clamp([min], [calculated], [max])`。当你基于屏幕尺寸，使用长度单位 `vw` 来缩放一些值时，这个函数很有用。"},{"title":"如何用正则表达式判断一个数是否是质数","date":"2020-10-08T12:44:58.817Z","slug":"judge-a-number","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["regex","javascript"],"excerpt":"本文展示了一种判断一个数是否是质数的奇技淫巧，采用的是正则表达式方法。"},{"title":"CSS 的 RGB 颜色覆盖","date":"2020-09-27T08:18:39.741Z","slug":"css-rgb-color","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["CSS"],"coverImage":"/assets/blog/css-rgb.jpeg","excerpt":"浅薄的研究了一下，希望可以和我讨论"},{"title":"[译] 如何基于 D3.js 使用外部数据源创建图表","date":"2020-09-27T08:18:39.741Z","slug":"d3-charts","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["d3js","翻译"],"coverImage":"/assets/blog/d3.png","excerpt":"D3 是一个运行于 web 端的 Javascript 可视化库。D3 的第一个版本发布于 2011 年，并且随着社区支持的增加而成熟。对于早期版本的 D3，学习曲线有些陡峭，但对于 JavaScript 初学者来说，最新版本学习起来更容易。大多数为 Web 构建的可视化都依赖于动态数据源 —— 因此，本文的目的是使您能够在 D3 中使用外部数据源创建图表。"},{"title":"[Puppeteer]我是如何做到写EXCEL时速3k行的","date":"2020-05-03T16:35:07.322Z","slug":"puppeteer-cnki","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"type":"tech","tag":["puppeteer","node.js"],"coverImage":"/assets/blog/puppeteer.jfif","excerpt":"之所以有了这篇文，完全就是前两天，老师又给大家派了一个好麻烦的项目统计某某期刊的信息。粗粗看了一下14个人的群里，有我这样延毕的老狗 同学，也有正当主力的研一研二的同学，貌似还有大四一直跟着老师做项目，美其名曰本科阶段就进入实验室的小朋友（当然还是蛮好的），好是很好啦，但是一看要我复制粘贴的文章有650+，顿时有点难顶，还好聪明的小徐同学很快想出了办法："}]},"__N_SSG":true}