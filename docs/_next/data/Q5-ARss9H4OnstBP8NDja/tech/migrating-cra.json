{"pageProps":{"post":{"title":"Next.js 项目迁移到 create-react-app","date":"2021-09-20T17:10:00.000Z","slug":"migrating-cra","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"<p>公司的统一登录项目之前部署在私有云上采用的是 <code>next.js</code>，虽然存在一些问题但是还能使用。现在统一部署到公司自建的 devops 平台，由于平台只有通用的 <code>react</code> 流水线，部署之后是客户端渲染的类型（<code>CSR</code>），导致之前的服务端渲染部署上去存在很多问题，调整成 <code>SSG</code> 模式部署上去也存在很多问题，例如 <code>redux</code> 状态管理问题以及 <code>router</code> 跳转问题，针对这些问题，最终决定从 <code>next.js</code> 框架切换到 <code>create- react-app</code> 的客户端渲染模式。这个需求还是很奇葩的，网上搜了一圈也没这个先例，于是就写了此文记录一下迁移以及都 <code>CRA</code> 的一些配置。</p>\n<h2>迁移目标</h2>\n<p>原有的项目基于 next.js 使用了 next.js 的路由以及一些 <a href=\"https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation\"><code>getStaticProps</code> (Static Generation)</a> 方法，要对其进行重写，首先是安装 CRA 脚手架，将页面迁移过去，然后再配置 <code>react-router-dom</code>, <code>react-redux-toolkit</code> 等，最后在配置一下 <code>typescript</code> 的开发环境。</p>\n<h2>安装脚手架 create- react-app</h2>\n<pre><code># 在项目的根目录\r\nnpx create-react-app my-app --typescript\n</code></pre>\n<p>这样就在根目录新建了一个项目，这里可以先把子项目 <code>/my-app/node_modules</code> 添加到 <code>.gitignore</code>.</p>\n<p>后面安装依赖：</p>\n<pre><code>{\r\n  \"@reduxjs/toolkit\": \"^1.6.1\",\r\n  \"react-redux\": \"^7.2.4\",\r\n\t\"react-router-dom\": \"^5.2.1\",\r\n  \"redux\": \"^4.1.1\",\r\n  \"@types/react-redux\": \"^7.1.18\",\r\n\t\"@types/react-router-dom\": \"^5.1.8\",\r\n}\n</code></pre>\n<h3>react-router-dom</h3>\n<p>由于之前的 <code>next.js</code> 是约定式路由，改成使用  <code>react-router-dom</code>,  加之公司其他的项目都是使用的配置式的路由，所以需要对其进行改造，经过研究，在项目的 <code>index.tsx</code>引入路由，在 <code>App.tsx</code>中配置路由表。</p>\n<pre><code>npm i -S react-router-dom\r\nnpm i -D @types/react-router-dom\n</code></pre>\n<pre><code>import { HashRouter as Router } from 'react-router-dom';\r\nReactDOM.render(\r\n\t\t&#x3C;React.StrictMode>\r\n\t\t\t&#x3C;Router>\r\n\t\t\t\t&#x3C;App />\r\n\t\t\t&#x3C;/Router>\r\n\t\t&#x3C;/React.StrictMode>\r\n  ,\r\n\tdocument.getElementById('root')\r\n);\n</code></pre>\n<pre><code>import { Route, Switch } from 'react-router-dom';\r\nexport default function App() {\r\n  return (\r\n\t\t&#x3C;div className=\"App\">\r\n\t\t\t&#x3C;Switch>\r\n\t\t\t\t&#x3C;Route path=\"/login\" component={Login} />\r\n\t\t\t\t&#x3C;Route path=\"/oauth\" component={Oauth} />\r\n\t\t\t\t&#x3C;Route path=\"/dashboard\" component={Dashboard} />\r\n\t\t\t&#x3C;/Switch>\r\n\t\t&#x3C;/div>\r\n\t);\r\n}\n</code></pre>\n<blockquote>\n<p>这里的路由是直接写在里面，也可以配置一个 路由表 然后渲染成组件，这样更加解耦</p>\n</blockquote>\n<pre><code>const configRoute = [\r\n  {\r\n    path:'/login', component: Oauth,\r\n    ...\r\n  }\r\n];\r\nreturn (\r\n    &#x3C;Switch>\r\n    \t{configRoute.map(route)=>(\r\n      \t&#x3C;Route path={route.path}, component={route.component}>&#x3C;/Route>\r\n      )}\r\n    &#x3C;/Switch>\r\n    );\n</code></pre>\n<p>对于 <code>next/router</code> 还有一个 <code>useRouter</code>， 可以使用 <code>useHistory</code> , <code>useLocation</code>来代替：</p>\n<pre><code>import { useHistory, useLocation } from 'react-router-dom';\r\nfunction App() {\r\n\tconst history = useHistory();\r\n  // 获取搜索栏的地址\r\n\tconst { search } = useLocation();\r\n\tuseEffect(() => {\r\n\t\tif (search) {\r\n\t\t\thistory.push(`/oauth${search}`);\r\n\t\t} else {\r\n\t\t\thistory.push('/dashboard');\r\n\t\t}\r\n\t}, [history, search]);\r\n\treturn (\r\n\t\t...\r\n\t);\r\n}\n</code></pre>\n<p>这样一来 <code>next/router</code>  的功能就被代替了，下面配置 <code>react-redux</code> 进行状态管理。</p>\n<h3>react-redux</h3>\n<pre><code>npm i -S @reduxjs/toolkit react-redux redux\r\nnpm i -D @types/react-redux\n</code></pre>\n<p>首先是 <code>index.tsx</code></p>\n<pre><code>import { Provider } from 'react-redux';\r\nimport store from './store/store';\r\n\r\nReactDOM.render(\r\n\t&#x3C;Provider store={store}>\r\n\t\t&#x3C;App />\r\n\t&#x3C;/Provider>,\r\n\tdocument.getElementById('root')\r\n);\n</code></pre>\n<p>配置的 store ：</p>\n<pre><code>// store.ts\r\nimport { configureStore, ThunkAction, Action } from '@reduxjs/toolkit'\r\n// 按照模块划分需要保存的状态\r\nimport userReducer from './modules/userSlice'\r\nexport function makeStore() {\r\n  return configureStore({\r\n    reducer: { user: userReducer },\r\n  })\r\n}\r\n\r\nconst store = makeStore()\r\n// 导出类型\r\nexport type AppState = ReturnType&#x3C;typeof store.getState>\r\nexport type AppDispatch = typeof store.dispatch\r\nexport type AppThunk&#x3C;ReturnType = void> = ThunkAction&#x3C;\r\n  ReturnType,\r\n  AppState,\r\n  unknown,\r\n  Action&#x3C;string>\r\n>\r\nexport default store\r\n\n</code></pre>\n<p>user 模块：</p>\n<pre><code>import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\nimport type { AppState } from '@/store/store';\r\n\r\nexport interface UserState {\r\n\tuserName: string;\r\n}\r\n// 创建一个初始的状态\r\nconst initialState: UserState = {\r\n\tuserName: '',\r\n};\r\n\r\nexport const userSlice = createSlice({\r\n\tname: 'user',\r\n\tinitialState,\r\n\treducers: {\r\n    // 类似于 vuex mutations\r\n\t\tgetUserInfo: (state, { payload }: PayloadAction&#x3C;UserState>) => {\r\n\t\t\treturn payload;\r\n\t\t},\r\n\t},\r\n});\r\n\r\nexport const { getUserInfo } = userSlice.actions;\r\n\r\nexport const selectUserName = (state: AppState) => state.user.userName;\r\n\r\nexport default userSlice.reducer;\r\n\n</code></pre>\n<p>另外 <code>react-redux</code> 还提供了几个hook 用于使用：</p>\n<pre><code>import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\r\n\r\nimport type { AppDispatch, AppState } from './store';\r\n\r\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\r\nexport const useAppDispatch = () => useDispatch&#x3C;AppDispatch>();\r\n\r\nexport const useAppSelector: TypedUseSelectorHook&#x3C;AppState> = useSelector;\n</code></pre>\n<p>使用方法可以看这个例子：</p>\n<pre><code>import { useAppDispatch } from '@/store/hooks';\r\nimport { getUserInfo } from '@/store/modules/userSlice';\r\nconst App = ()=>{\r\n  const dispatch = useAppDispatch();\r\n  const handleClick = (data)=>{\r\n    dispatch(getUserInfo({ userInfo: data }));\r\n  }\r\n}\n</code></pre>\n<blockquote>\n<p>对于 异步 actions 回头再研究研究</p>\n</blockquote>\n<h3>eject? customize-cra?</h3>\n<p>上面的配置完成之后，对于之前使用的一些 alias， proxy 等还需要继续配置，这里有两种情况</p>\n<ol>\n<li>运行 <code>npm run eject</code> 弹出隐藏的 <code>webpack</code> 配置，在其中配置参数；</li>\n<li>使用 <code>customize-cra</code> + <code>react-app-rewired</code> 进行个性化配置</li>\n</ol>\n<p>本次迁移中一开始选择使用第二种方法，<code>customize-cra</code> + <code>react-app-rewired</code> ，</p>\n<pre><code>const { useBabelRc, override } = require('customize-cra');\r\nconst { alias, configPaths } = require('react-app-rewire-alias');\r\n\r\nconst aliasMap = configPaths('./tsconfig.path.json')\r\n\r\nconsole.log(__dirname);\r\nconst config = override(\r\n\t// eslint-disable-next-line\r\n\tuseBabelRc(),\r\n\talias(aliasMap)\r\n);\r\n\r\nmodule.exports = config;\n</code></pre>\n<p>但是后面发现每次配置的时候都需要去查对应的封装的包，有点麻烦于是索性 <code>eject</code> ，自由配置 <code>webpack </code> . <code>eject</code> 之后主要配置项就在 <code>/config</code> 目录下了，这里的配置大同小异，不会的小朋友可以去看看 《深入浅出webpack》.</p>\n<p><code>eject</code>还带来了一个目录 <code>/scripts</code> 里面写了打包编译的脚本文件，一般不用动，有时间可以看下，在启动项目和打包的时候 <code>create-react-app</code>到底做了什么工作。</p>\n<h2>去除 next.js 依赖</h2>\n<p>脚手架安装完成之后就是对项目进行迁移，并把<code>next.js</code>相关的 类似于 <code>next/link</code>，<code>next/router</code>等依赖切换成对应的 <code>react-router-dom</code>的方法和包。</p>\n<h2>配置 create-react-app 成为 react 开发环境</h2>\n<ol>\n<li>\n<p>在 <code>.env</code> 文件里 以 <code>REACT_APP_</code> 开头配置地址等文件</p>\n</li>\n<li>\n<p>创建 <code>/src/types/index.d.ts</code>  声明一些静态文件的类型</p>\n</li>\n</ol>\n<pre><code>  declare module '*.svg';\r\n  declare module '*.png';\r\n  declare module '*.jpg';\r\n  declare module '*.jpeg';\r\n  declare module '*.gif';\n</code></pre>\n<ol start=\"3\">\n<li>\n<p>设置别名和 <code>baseUrl</code></p>\n<ul>\n<li>\n<p>一个是在<code>webpack </code>里面设置，用于打包的时候，不过这里<code>create-react-app</code>的配置已经处理了，会读取项目中的<code>t/jsconfig.json</code> 文件里面的配置。</p>\n</li>\n<li>\n<p>还有一个是在 <code>tsconfig.json</code> 设置，用于开发的时候在 ide 里面解析</p>\n</li>\n</ul>\n<pre><code>\"baseUrl\": \"./\",\r\n\"paths\": {\r\n\t\"@/*\": [\"./src/*\"]\r\n}\n</code></pre>\n</li>\n</ol>\n<h2>后记</h2>\n<p>这个文章告诉我们的道理是，技术选型首先要慎重，根据项目的场景选择最合适的技术栈；其次是要选择熟悉的技术，否则后面的维护会受到影响；还有就是一旦遇到问题，当发现技术确实与现有的业务不匹配的时候，抓紧时间进行切换，减少沉默成本。</p>\n","coverImage":"/assets/blog/nextjs.jfif"}},"__N_SSG":true}