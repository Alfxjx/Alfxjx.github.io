{"pageProps":{"post":{"title":"如何设计一个好用的组件-以chakra-ui为例","date":"2021-10-28T12:52:42.712Z","slug":"design-a-component","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"<blockquote>\n<p>同时发布于 <a href=\"https://www.yuque.com/alfxjx/notes/wchz9f\">语雀</a></p>\n</blockquote>\n<h2>引子</h2>\n<p>最近公司在搭建部门的统一平台，我负责了统一登录前端的开发，因为要对接很多的系统，所以开发了统一登录的sdk，说是sdk其实就是一个组件库。以此为契机，外加之前开发其他的系统中也用了很多种不同的组件库（饿了没-ui/vant/antd/chakra-ui...），今天写一篇文章说说，什么样的组件设计是比较合理的，以及如何设计一个好用的组件。</p>\n<h2>研究chakra-ui</h2>\n<p><img src=\"/assets/blog/chakra-ui.png\" alt=\"\"></p>\n<p>比较来说我觉得设计比较有特色的一个组件库，就是 <a href=\"https://chakra-ui.com/\">chakra-ui</a> 了，不过国内使用的并不多，我也是在之前技术选型的时候偶然找到的，但是仔细读了她的文档之后我发现这个是一个很有特色的组件库，下面细说：</p>\n<h3>样式自定义</h3>\n<p>找到这个 chakra-ui 的时候，就是因为需要在使用 tailwind CSS 的同时使用一个组件库，chakra-ui 的一个特色就是使用了和 tailwind CSS 几乎相同的样式 api , 例如：</p>\n<pre><code>import { Box } from \"@chakra-ui/react\"\r\n\r\n// m={2} refers to the value of `theme.space[2]`\r\n&#x3C;Box m={2}>Tomato&#x3C;/Box>\r\n\r\n// You can also use custom values\r\n&#x3C;Box maxW=\"960px\" mx=\"auto\" />\r\n\r\n// sets margin `8px` on all viewports and `16px` from the first breakpoint and up\r\n&#x3C;Box m={[2, 3]} />\n</code></pre>\n<p>这样只要你记住了 tailwind CSS 的api， 那么就可以很快的上手 chakra-ui 。\r\n那么这个是怎么实现的呢？\r\n一开始我以为是组件库使用了tailwind CSS ，但是看了源码发现，chakra 将 styled-components 进行了二次封装，而这种 tailwindLike 的 api 是进行了模拟导致的。\r\n在 <a href=\"https://github.com/chakra-ui/chakra-ui/blob/main/packages/styled-system/src/config/background.ts\">/packages/styled-system/config/</a> 里面 写入了不同样式以及缩写，以 background 为例：</p>\n<pre><code>export const background: Config = {\r\n  background: t.colors(\"background\"),\r\n  ...\r\n  bg: t.colors(\"background\"),\r\n  ...\r\n}\n</code></pre>\n<p>这样实现的，可以说把dirty的工作封装了起来，展示出来的结果都是好用的。</p>\n<h3>组件组合</h3>\n<p>书接上文，组件里面做了很多的映射封装，为了减少代码量，统一进行管理，组件库进行了组件的组合（compose）。从一个基本的组件出发，通过默认一些样式，创造了一些新的组件。\r\n例如<a href=\"https://chakra-ui.com/docs/layout/center#square-and-circle\"> Square Circle </a>组件，是基于 Box 组件extend而来的。</p>\n<pre><code>export const Square = forwardRef&#x3C;SquareProps, \"div\">((props, ref) => {\r\n  const { size, centerContent = true, ...rest } = props\r\n\r\n  const styles: SystemStyleObject = centerContent\r\n    ? { display: \"flex\", alignItems: \"center\", justifyContent: \"center\" }\r\n    : {}\r\n\r\n  return (\r\n    &#x3C;Box\r\n      ref={ref}\r\n      boxSize={size}\r\n      __css={{\r\n        ...styles,\r\n        flexShrink: 0,\r\n        flexGrow: 0,\r\n      }}\r\n      {...rest}\r\n    />\r\n  )\r\n})\r\n\r\nif (__DEV__) {\r\n  Square.displayName = \"Square\"\r\n}\r\n\r\nexport const Circle = forwardRef&#x3C;SquareProps, \"div\">((props, ref) => {\r\n  const { size, ...rest } = props\r\n  return &#x3C;Square size={size} ref={ref} borderRadius=\"9999px\" {...rest} />\r\n})\r\n\r\nif (__DEV__) {\r\n  Circle.displayName = \"Circle\"\r\n}\n</code></pre>\n<p>这样写减少了重复的代码并且可以保持更好的可维护性。我们在开发的过程中也可以借鉴这种模式，开发出最抽象的组件，从这个最抽象的父类出发来进行派生。</p>\n<h3>Theminig</h3>\n<p>chakra ui 的另外一个特点就是拥有一个高度自定义的主题系统， 使用的方式类似于 tailwind CSS <a href=\"https://tailwindcss.com/docs/theme\">设置</a>，也就是说你可同时将一个theme文件应用到两个库中，使用方法可以看一下<a href=\"https://chakra-ui.com/docs/theming/customize-theme\">chakra文档</a>，那么这个主题是如何实现的呢？\r\n首先 chakra ui 维护了一个default theme ,用于在没有自定义 theme 或者 自定义了一部分的theme的时候进行合并，合并的过程（<code>toCSSVar</code>）是使用了 <code>createThemeVars</code> 方法将自己配置的theme转化成css var变量，然后将默认的theme和生成的theme进行合并。最后在 :</p>\n<pre><code>\r\nexport const ThemeProvider = (props: ThemeProviderProps) => {\r\n  const { cssVarsRoot = \":host, :root\", theme, children } = props\r\n  const computedTheme = React.useMemo(() => toCSSVar(theme), [theme])\r\n  return (\r\n    &#x3C;EmotionThemeProvider theme={computedTheme}>\r\n      &#x3C;Global styles={(theme: any) => ({ [cssVarsRoot]: theme.__cssVars })} />\r\n      {children}\r\n    &#x3C;/EmotionThemeProvider>\r\n  )\r\n}\n</code></pre>\n<p>这里是借用了 emotion 的 <a href=\"https://emotion.sh/docs/theming#themeprovider-reactcomponenttype\">ThemeProvider</a>。这么一看其实主题设置还是很简单的。这样可以很方便的设置了一个自定义的主题\r\n除此之外，如果想在二次开发的主题上进行三次开发，可以使用 chakra-ui 提供的api <a href=\"https://chakra-ui.com/docs/theming/customize-theme#using-theme-extensions\">Theme extensions</a>。提供了一个类似于 HOC 的包裹函数，以withDefaultColorScheme为例：</p>\n<pre><code>export function withDefaultColorScheme({colorScheme,components}): ThemeExtension {\r\n  return (theme) => {\r\n    let names = Object.keys(theme.components || {})\r\n\t\t// ....\r\n    return mergeThemeOverride(theme, {\r\n      components: Object.fromEntries(\r\n        names.map((componentName) => {\r\n          const withColorScheme = {\r\n            defaultProps: {\r\n              colorScheme,\r\n            },\r\n          }\r\n          return [componentName, withColorScheme]\r\n        }),\r\n      ),\r\n    })\r\n  }\r\n}\n</code></pre>\n<p>将配置的颜色Scheme赋值给了配置的对应的组件。内部实现大同小异，都是调用了 <code>mergeThemeOverride</code>这个方法</p>\n<pre><code>export function mergeThemeOverride&#x3C;BaseTheme extends ChakraTheme = ChakraTheme>(\r\n  ...overrides: ThemeOverride&#x3C;BaseTheme>[]\r\n): ThemeOverride&#x3C;BaseTheme> {\r\n  return mergeWith({}, ...overrides, mergeThemeCustomizer)\r\n}\n</code></pre>\n<p>内部使用了 <code>lodash.mergewith</code>的方法实现融合，对于此方法 chakra-ui 写了一个mergeThemeCustomizer 作为 <a href=\"https://www.lodashjs.com/docs/lodash.mergeWith/\">lodash.mergwith</a> 的第三个参数，这里的自定义mergeThemeCustomizer方法使用了递归的方式进行merge。</p>\n<pre><code>\r\nfunction mergeThemeCustomizer(\r\n  source: unknown,\r\n  override: unknown,\r\n  key: string,\r\n  object: any,\r\n) {\r\n  if (\r\n    (isFunction(source) || isFunction(override)) &#x26;&#x26;\r\n    Object.prototype.hasOwnProperty.call(object, key)\r\n  ) {\r\n    return (...args: unknown[]) => {\r\n      const sourceValue = isFunction(source) ? source(...args) : source\r\n\r\n      const overrideValue = isFunction(override) ? override(...args) : override\r\n\r\n      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer)\r\n    }\r\n  }\r\n\r\n  // fallback to default behaviour\r\n  return undefined\r\n}\n</code></pre>\n<h3>外部组件与二次封装</h3>\n<p>从上面可以看到，组件库也不是全部从零开始，也使用了很多第三方的库，例如样式库 emotion， styled-components，工具方法库 lodash，这里没啥特别好说的。\r\n另外chakra-ui官方也推荐将组件库和许多第三方的lib一起使用，例如 表单验证库<a href=\"https://chakra-ui.com/docs/form/form-control#usage-with-form-libraries\">formik</a>，此外，在element-ui中也会直接封装throttle-debounce， async-validator等第三方的库。</p>\n<h3>提供escape</h3>\n<p>在使用其他的组件库的时候，很多情况下会出现某些组件的细节和设计要求不一致的情况，对于element-ui和ant design来说，由于使用了sass/less等预处理器，可以使用覆盖的方式来覆写样式。在 chakra ui 中，则提供了一个 <a href=\"https://chakra-ui.com/docs/features/the-sx-prop\">sx Props</a> 来直接向组件传入样式。</p>\n<pre><code>&#x3C;Box sx={{ \"--my-color\": \"#53c8c4\" }}>\r\n  &#x3C;Heading color=\"var(--my-color)\" size=\"lg\">\r\n    This uses CSS Custom Properties!\r\n  &#x3C;/Heading>\r\n&#x3C;/Box>\n</code></pre>\n<p>这个方式很强大，还支持嵌套样式，media query等。这里的sx是一个封装自@emotion/styled的方法，在 <a href=\"https://github.com/chakra-ui/chakra-ui/blob/main/packages/system/src/system.ts\">packages/system/src/system.ts</a>, styled方法里面调用了 toCSSObject ，这里拿取到了输入的样式，而所有的ui 组件都会调用这个 styled方法，sx Props 就这样全局生效了。</p>\n<pre><code>export function styled&#x3C;T extends As, P = {}>(\r\n  component: T,\r\n  options?: StyledOptions,\r\n) {\r\n  const { baseStyle, ...styledOptions } = options ?? {}\r\n\t// ...\r\n  const styleObject = toCSSObject({ baseStyle })\r\n  return _styled(\r\n    component as React.ComponentType&#x3C;any>,\r\n    styledOptions,\r\n  )(styleObject) as ChakraComponent&#x3C;T, P>\r\n}\r\n\r\nexport const toCSSObject: GetStyleObject = ({ baseStyle }) => (props) => {\r\n  const { theme, css: cssProp, __css, sx, ...rest } = props\r\n  const styleProps = objectFilter(rest, (_, prop) => isStyleProp(prop))\r\n  const finalBaseStyle = runIfFn(baseStyle, props)\r\n  const finalStyles = Object.assign({}, __css, finalBaseStyle, styleProps, sx)\r\n  const computedCSS = css(finalStyles)(props.theme)\r\n  return cssProp ? [computedCSS, cssProp] : computedCSS\r\n}\n</code></pre>\n<h2>如何设计一个好用的组件</h2>\n<p>参考了很多设计，那么如何设计一个好用的组件呢，这里以一个progressBar为例。</p>\n<h3>MVP 版本以及存在的问题</h3>\n<pre><code>import React, { useState, useEffect } from \"react\";\r\nimport styled from \"styled-components\";\r\n\r\nconst ProgressBarWrapper = styled.div&#x3C;{ progress: number }>`\r\n\twidth: 100%;\r\n\theight: 4px;\r\n\tposition: fixed;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\tright: 0;\r\n\tz-index: 9999;\r\n\t.bar-used {\r\n\t\tbackground: #34c;\r\n\t\twidth: ${({ progress }) => progress + \"%\"};\r\n\t\theight: 100%;\r\n\t\tborder-radius: 0 2px 2px 0;\r\n\t}\r\n`;\r\n\r\nconst ProgressBar = () => {\r\n\tconst [progress, setProgress] = useState(0);\r\n\tuseEffect(() => {\r\n\t\twindow.addEventListener(\"scroll\", () => {\r\n\t\t\tsetProgress(\r\n\t\t\t\t(document.documentElement.scrollTop /\r\n\t\t\t\t\t(document.body.scrollHeight - window.innerHeight)) *\r\n\t\t\t\t\t100\r\n\t\t\t);\r\n\t\t});\r\n\t\treturn () => {\r\n\t\t\twindow.removeEventListener(\"scroll\", () => {});\r\n\t\t};\r\n\t});\r\n\treturn (\r\n\t\t&#x3C;ProgressBarWrapper progress={progress}>\r\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\r\n\t\t&#x3C;/ProgressBarWrapper>\r\n\t);\r\n};\r\n\r\nexport { ProgressBar };\r\n\n</code></pre>\n<p>这里展示了一个页面顶部进度条的组件，类似于 <a href=\"https://es6.ruanyifeng.com/#docs/decorator\">es6标准入门</a> 这里的样式，上面的功能可以很快的就实现出来，但是只是比较符合单一的应用场景，进度条固定在顶部，只有从左往右增长一种情况。但是实际上的进度条可能会用到很多的地方，因此我们需要对照可能的场景以及代码中的变量进行判断，哪些是需要做成参数，并设置对应的默认值。\r\n需求有以下几种：</p>\n<ol>\n<li>颜色可调，位置可调，方向可调，这三个是比较全局的可调整类型</li>\n<li>具体样式修改，高度修改，圆角修改，这些是其他的一些props，如果保持progressbar的功能不变可能不太会用到的props</li>\n</ol>\n<p>此外，这里的progeressBar还存在的一个问题就是，这个组件将展示和逻辑杂糅在了一起，组件内部就有对于页面滚动进度的计算逻辑（useEffect），但是如果使用的时候不需要这个逻辑呢？\r\n根据上面的一些要修改的点以及一些问题，我们来对这个组件进行拆分和重构。</p>\n<h3>重构</h3>\n<p>首先是把逻辑和展示分开。新建一个hook用于计算百分比。</p>\n<pre><code>import { useState, useEffect } from \"react\";\r\n\r\nexport function useProgress() {\r\n\tconst [progress, setProgress] = useState(0);\r\n\tuseEffect(() => {\r\n\t\twindow.addEventListener(\"scroll\", () => {\r\n\t\t\tsetProgress(\r\n\t\t\t\t(document.documentElement.scrollTop /\r\n\t\t\t\t\t(document.body.scrollHeight - window.innerHeight)) *\r\n\t\t\t\t\t100\r\n\t\t\t);\r\n\t\t});\r\n\t\treturn () => {\r\n\t\t\twindow.removeEventListener(\"scroll\", () => {});\r\n\t\t};\r\n\t});\r\n\treturn progress;\r\n}\r\n\n</code></pre>\n<p>之后是给需要的参数添加props,并设置默认值，这里只以高度为例，设置一个可选的高度参数，当传入的时候就使用传入的值否则是默认的。\r\n同时注意颜色等可以使用一个theme系统。</p>\n<pre><code>\r\nconst ProgressBarWrapper = styled.div&#x3C;{ progress: number; height?: string }>`\r\n\twidth: 100%;\r\n\theight: ${({ height }) => (height ? height : \"4px\")};\r\n\t.bar-used {\r\n\t\tbackground: ${({ theme }) => theme.themeColor};\r\n\t\twidth: ${({ progress }) => progress + \"%\"};\r\n\t\theight: 100%;\r\n\t\tborder-radius: ${({ height }) =>\r\n\t\t\theight ? `0 calc( ${height}/ 2) calc(${height}/ 2) 0` : \"0 2px 2px 0\"};\r\n\t}\r\n`;\n</code></pre>\n<p>除此之外，将fixed布局抽象出来，方便后面进行组合</p>\n<pre><code>const FixedTopWrapper = styled.div`\r\n\tposition: fixed;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\tright: 0;\r\n\tz-index: 9999;\r\n`;\r\n// 组合之后就是这样的\r\nconst ProgressBarWrapperFixed = styled(FixedTopWrapper)&#x3C;{\r\n\tprogress: number;\r\n\theight?: string;\r\n}>`.....`;\r\n\n</code></pre>\n<p>这样组件就是这样的，分成了默认好用的 ProgressBar 和 自定义功能更多的 SimpleProgressBar</p>\n<pre><code>\r\ninterface ProgressProps {\r\n\tprogress: number;\r\n\theight?: string;\r\n}\r\nconst ProgressBar = ({\r\n\theight,\r\n}: Omit&#x3C;ProgressProps, \"progress\">) => {\r\n\tconst progress = useProgress();\r\n\treturn (\r\n\t\t&#x3C;ProgressBarWrapperFixed progress={progress} height={height}>\r\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\r\n\t\t&#x3C;/ProgressBarWrapperFixed>\r\n\t);\r\n};\r\n\r\nconst SimpleProgressBar = ({\r\n\tprogress,\r\n\theight,\r\n}: ProgressProps) => {\r\n\treturn (\r\n\t\t&#x3C;ProgressBarWrapper progress={progress} height={height}>\r\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\r\n\t\t&#x3C;/ProgressBarWrapper>\r\n\t);\r\n};\n</code></pre>\n<p>另外就是添加 合适的 escape，方便使用的时候如果不符合需要可以自行修改。这里直接在组件上添加一个 style参数，</p>\n<pre><code>// usage\r\n&#x3C;ProgressBar style={{ background: \"#000\" }}>&#x3C;/ProgressBar>\r\n// 修改组件 添加rest参数接受附加的style,并且修改一下类型\r\nconst ProgressBar = ({\r\n\theight,\r\n\t...rest\r\n}: Omit&#x3C;ProgressProps, \"progress\"> &#x26; React.HTMLAttributes&#x3C;HTMLDivElement>) => {\r\n\tconst progress = useProgress();\r\n\treturn (\r\n\t\t&#x3C;ProgressBarWrapperFixed {...rest} progress={progress} height={height}>\r\n\t\t\t&#x3C;div className='bar-used'>&#x3C;/div>\r\n\t\t&#x3C;/ProgressBarWrapperFixed>\r\n\t);\r\n};\n</code></pre>\n<p>这样就写好了一个好用的ProgressBar组件了，并且提供了SimpleProgressBar用于其他的自定义用途。</p>\n<p>在线演示：<a href=\"https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010\">https://codepen.io/alfxjx/pen/ZEJyygo?editors=0010</a></p>\n<h2>总结</h2>\n<p>经过上面对 chakra ui 组件库源码的研究以及一个示例，相信你以及知道了该如何设计一个好用的组件库了，希望你能为你的公司也开发一套组件库，能更好的完成你的kpi/okr/etc...</p>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://github.com/chakra-ui/chakra-ui\">https://github.com/chakra-ui/chakra-ui</a></li>\n<li><a href=\"https://chakra-ui.com/\">https://chakra-ui.com/</a></li>\n<li><a href=\"https://emotion.sh/\">https://emotion.sh/</a></li>\n<li><a href=\"https://www.lodashjs.com/\">https://www.lodashjs.com/</a></li>\n<li><a href=\"https://tailwindcss.com/\">https://tailwindcss.com/</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN\">https://element.eleme.cn/#/zh-CN</a></li>\n<li><a href=\"https://ant.design/index-cn\">https://ant.design/index-cn</a></li>\n<li><a href=\"https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen\">https://stackoverflow.com/questions/55318165/add-styled-components-to-codepen</a></li>\n</ol>\n","coverImage":"/assets/blog/chakra-ui.png"}},"__N_SSG":true}