{"pageProps":{"post":{"title":"Next.js 项目迁移到 create-react-app","date":"2021-09-20T17:10:00.000Z","slug":"migrating-cra","author":{"name":"Alfxjx","picture":"/assets/authors/alfxjx.jpg"},"content":"<p>公司的统一登录项目之前部署在私有云上采用的是 <code>next.js</code>，虽然存在一些问题但是还能使用。现在统一部署到公司自建的 devops 平台，由于平台只有通用的 <code>react</code> 流水线，部署之后是客户端渲染的类型（<code>CSR</code>），导致之前的服务端渲染部署上去存在很多问题，调整成 <code>SSG</code> 模式部署上去也存在很多问题，例如 <code>redux</code> 状态管理问题以及 <code>router</code> 跳转问题，针对这些问题，最终决定从 <code>next.js</code> 框架切换到 <code>create- react-app</code> 的客户端渲染模式。这个需求还是很奇葩的，网上搜了一圈也没这个先例，于是就写了此文记录一下迁移以及都 <code>CRA</code> 的一些配置。</p>\n<h2>迁移目标</h2>\n<p>原有的项目基于 next.js 使用了 next.js 的路由以及一些 <a href=\"https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation\"><code>getStaticProps</code> (Static Generation)</a> 方法，要对其进行重写，首先是安装 CRA 脚手架，将页面迁移过去，然后再配置 <code>react-router-dom</code>, <code>react-redux-toolkit</code> 等，最后在配置一下 <code>typescript</code> 的开发环境。</p>\n<h2>安装脚手架 create- react-app</h2>\n<pre><code class=\"language-shell\"># 在项目的根目录\nnpx create-react-app my-app --typescript\n</code></pre>\n<p>这样就在根目录新建了一个项目，这里可以先把子项目 <code>/my-app/node_modules</code> 添加到 <code>.gitignore</code>.</p>\n<p>后面安装依赖：</p>\n<pre><code class=\"language-json\">{\n  \"@reduxjs/toolkit\": \"^1.6.1\",\n  \"react-redux\": \"^7.2.4\",\n\t\"react-router-dom\": \"^5.2.1\",\n  \"redux\": \"^4.1.1\",\n  \"@types/react-redux\": \"^7.1.18\",\n\t\"@types/react-router-dom\": \"^5.1.8\",\n}\n</code></pre>\n<h3>react-router-dom</h3>\n<p>由于之前的 <code>next.js</code> 是约定式路由，改成使用  <code>react-router-dom</code>,  加之公司其他的项目都是使用的配置式的路由，所以需要对其进行改造，经过研究，在项目的 <code>index.tsx</code>引入路由，在 <code>App.tsx</code>中配置路由表。</p>\n<pre><code class=\"language-shell\">npm i -S react-router-dom\nnpm i -D @types/react-router-dom\n</code></pre>\n<pre><code class=\"language-tsx\">import { HashRouter as Router } from 'react-router-dom';\nReactDOM.render(\n\t\t&#x3C;React.StrictMode>\n\t\t\t&#x3C;Router>\n\t\t\t\t&#x3C;App />\n\t\t\t&#x3C;/Router>\n\t\t&#x3C;/React.StrictMode>\n  ,\n\tdocument.getElementById('root')\n);\n</code></pre>\n<pre><code class=\"language-tsx\">import { Route, Switch } from 'react-router-dom';\nexport default function App() {\n  return (\n\t\t&#x3C;div className=\"App\">\n\t\t\t&#x3C;Switch>\n\t\t\t\t&#x3C;Route path=\"/login\" component={Login} />\n\t\t\t\t&#x3C;Route path=\"/oauth\" component={Oauth} />\n\t\t\t\t&#x3C;Route path=\"/dashboard\" component={Dashboard} />\n\t\t\t&#x3C;/Switch>\n\t\t&#x3C;/div>\n\t);\n}\n</code></pre>\n<blockquote>\n<p>这里的路由是直接写在里面，也可以配置一个 路由表 然后渲染成组件，这样更加解耦</p>\n</blockquote>\n<pre><code class=\"language-tsx\">const configRoute = [\n  {\n    path:'/login', component: Oauth,\n    ...\n  }\n];\nreturn (\n    &#x3C;Switch>\n    \t{configRoute.map(route)=>(\n      \t&#x3C;Route path={route.path}, component={route.component}>&#x3C;/Route>\n      )}\n    &#x3C;/Switch>\n    );\n</code></pre>\n<p>对于 <code>next/router</code> 还有一个 <code>useRouter</code>， 可以使用 <code>useHistory</code> , <code>useLocation</code>来代替：</p>\n<pre><code class=\"language-tsx\">import { useHistory, useLocation } from 'react-router-dom';\nfunction App() {\n\tconst history = useHistory();\n  // 获取搜索栏的地址\n\tconst { search } = useLocation();\n\tuseEffect(() => {\n\t\tif (search) {\n\t\t\thistory.push(`/oauth${search}`);\n\t\t} else {\n\t\t\thistory.push('/dashboard');\n\t\t}\n\t}, [history, search]);\n\treturn (\n\t\t...\n\t);\n}\n</code></pre>\n<p>这样一来 <code>next/router</code>  的功能就被代替了，下面配置 <code>react-redux</code> 进行状态管理。</p>\n<h3>react-redux</h3>\n<pre><code class=\"language-shell\">npm i -S @reduxjs/toolkit react-redux redux\nnpm i -D @types/react-redux\n</code></pre>\n<p>首先是 <code>index.tsx</code></p>\n<pre><code class=\"language-tsx\">import { Provider } from 'react-redux';\nimport store from './store/store';\n\nReactDOM.render(\n\t&#x3C;Provider store={store}>\n\t\t&#x3C;App />\n\t&#x3C;/Provider>,\n\tdocument.getElementById('root')\n);\n</code></pre>\n<p>配置的 store ：</p>\n<pre><code class=\"language-ts\">// store.ts\nimport { configureStore, ThunkAction, Action } from '@reduxjs/toolkit'\n// 按照模块划分需要保存的状态\nimport userReducer from './modules/userSlice'\nexport function makeStore() {\n  return configureStore({\n    reducer: { user: userReducer },\n  })\n}\n\nconst store = makeStore()\n// 导出类型\nexport type AppState = ReturnType&#x3C;typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\nexport type AppThunk&#x3C;ReturnType = void> = ThunkAction&#x3C;\n  ReturnType,\n  AppState,\n  unknown,\n  Action&#x3C;string>\n>\nexport default store\n\n</code></pre>\n<p>user 模块：</p>\n<pre><code class=\"language-tsx\">import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport type { AppState } from '@/store/store';\n\nexport interface UserState {\n\tuserName: string;\n}\n// 创建一个初始的状态\nconst initialState: UserState = {\n\tuserName: '',\n};\n\nexport const userSlice = createSlice({\n\tname: 'user',\n\tinitialState,\n\treducers: {\n    // 类似于 vuex mutations\n\t\tgetUserInfo: (state, { payload }: PayloadAction&#x3C;UserState>) => {\n\t\t\treturn payload;\n\t\t},\n\t},\n});\n\nexport const { getUserInfo } = userSlice.actions;\n\nexport const selectUserName = (state: AppState) => state.user.userName;\n\nexport default userSlice.reducer;\n\n</code></pre>\n<p>另外 <code>react-redux</code> 还提供了几个hook 用于使用：</p>\n<pre><code class=\"language-tsx\">import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\n\nimport type { AppDispatch, AppState } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch&#x3C;AppDispatch>();\n\nexport const useAppSelector: TypedUseSelectorHook&#x3C;AppState> = useSelector;\n</code></pre>\n<p>使用方法可以看这个例子：</p>\n<pre><code class=\"language-tsx\">import { useAppDispatch } from '@/store/hooks';\nimport { getUserInfo } from '@/store/modules/userSlice';\nconst App = ()=>{\n  const dispatch = useAppDispatch();\n  const handleClick = (data)=>{\n    dispatch(getUserInfo({ userInfo: data }));\n  }\n}\n</code></pre>\n<blockquote>\n<p>对于 异步 actions 回头再研究研究</p>\n</blockquote>\n<h3>eject? customize-cra?</h3>\n<p>上面的配置完成之后，对于之前使用的一些 alias， proxy 等还需要继续配置，这里有两种情况</p>\n<ol>\n<li>运行 <code>npm run eject</code> 弹出隐藏的 <code>webpack</code> 配置，在其中配置参数；</li>\n<li>使用 <code>customize-cra</code> + <code>react-app-rewired</code> 进行个性化配置</li>\n</ol>\n<p>本次迁移中一开始选择使用第二种方法，<code>customize-cra</code> + <code>react-app-rewired</code> ，</p>\n<pre><code class=\"language-js\">const { useBabelRc, override } = require('customize-cra');\nconst { alias, configPaths } = require('react-app-rewire-alias');\n\nconst aliasMap = configPaths('./tsconfig.path.json')\n\nconsole.log(__dirname);\nconst config = override(\n\t// eslint-disable-next-line\n\tuseBabelRc(),\n\talias(aliasMap)\n);\n\nmodule.exports = config;\n</code></pre>\n<p>但是后面发现每次配置的时候都需要去查对应的封装的包，有点麻烦于是索性 <code>eject</code> ，自由配置 <code>webpack </code> . <code>eject</code> 之后主要配置项就在 <code>/config</code> 目录下了，这里的配置大同小异，不会的小朋友可以去看看 《深入浅出webpack》.</p>\n<p><code>eject</code>还带来了一个目录 <code>/scripts</code> 里面写了打包编译的脚本文件，一般不用动，有时间可以看下，在启动项目和打包的时候 <code>create-react-app</code>到底做了什么工作。</p>\n<h2>去除 next.js 依赖</h2>\n<p>脚手架安装完成之后就是对项目进行迁移，并把<code>next.js</code>相关的 类似于 <code>next/link</code>，<code>next/router</code>等依赖切换成对应的 <code>react-router-dom</code>的方法和包。</p>\n<h2>配置 create-react-app 成为 react 开发环境</h2>\n<ol>\n<li>\n<p>在 <code>.env</code> 文件里 以 <code>REACT_APP_</code> 开头配置地址等文件</p>\n</li>\n<li>\n<p>创建 <code>/src/types/index.d.ts</code>  声明一些静态文件的类型</p>\n</li>\n</ol>\n<pre><code class=\"language-typescript\">  declare module '*.svg';\n  declare module '*.png';\n  declare module '*.jpg';\n  declare module '*.jpeg';\n  declare module '*.gif';\n</code></pre>\n<ol start=\"3\">\n<li>\n<p>设置别名和 <code>baseUrl</code></p>\n<ul>\n<li>\n<p>一个是在<code>webpack </code>里面设置，用于打包的时候，不过这里<code>create-react-app</code>的配置已经处理了，会读取项目中的<code>t/jsconfig.json</code> 文件里面的配置。</p>\n</li>\n<li>\n<p>还有一个是在 <code>tsconfig.json</code> 设置，用于开发的时候在 ide 里面解析</p>\n</li>\n</ul>\n<pre><code class=\"language-json\">\"baseUrl\": \"./\",\n\"paths\": {\n\t\"@/*\": [\"./src/*\"]\n}\n</code></pre>\n</li>\n</ol>\n<h2>后记</h2>\n<p>这个文章告诉我们的道理是，技术选型首先要慎重，根据项目的场景选择最合适的技术栈；其次是要选择熟悉的技术，否则后面的维护会受到影响；还有就是一旦遇到问题，当发现技术确实与现有的业务不匹配的时候，抓紧时间进行切换，减少沉默成本。</p>\n","coverImage":"/assets/blog/nextjs.jfif"}},"__N_SSG":true}