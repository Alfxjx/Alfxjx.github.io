{"pageProps":{"post":{"title":"[CSS]矩形进度条的两种实现","date":"2020-07-19T20:35:07.322Z","slug":"loading-in-css","author":{"name":"Alfxjx","picture":"/assets/blog/authors/alfxjx.jpeg"},"content":"<h1>[CSS]矩形进度条的两种实现</h1>\n<p>最近开发接到一个需求，前端展示付款的验证码，验证码时效 10 分钟，到期过期，同时在二维码的外侧有一个倒计时条，原本的实现方式是通过 JS 来控制，设置左上，左下，右上，右下四个矩形，每个矩形只显示一个折角的边框，从而模拟整个外框。</p>\n<p>根据倒计时的时间轮询计算比例，分别控制四个矩形的宽高，从而实现倒计时的 <code>CountDown</code> 效果。这样的实现方式有几个问题：</p>\n<ol>\n<li>使用4个元素来模拟，导致加入了很多不必要的数据</li>\n<li>js 轮询操作，代码很冗长。</li>\n</ol>\n<p>本文主要介绍两种非 js 控制的矩形倒计时条的实现方法。</p>\n<h2>CSS 实现</h2>\n<p>css 实现方法的原理是：</p>\n<ol>\n<li>设置四个<code>background</code>，使用<code>linear-gradient</code> 形成纯色的图片背景。</li>\n<li>设置background的 <code>size</code> &#x26; <code>position</code>，使他们分布在元素的四周。</li>\n<li>设置一个动画，均分成 4 个阶段，每个阶段将背景的位置按照顺时针平移。</li>\n</ol>\n<p>具体可以看代码</p>\n<pre><code class=\"language-css\">.progress {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: var(--height);\r\n  width: var(--width);\r\n  border-radius: calc(var(--line) / 2);\r\n  background: \r\n    linear-gradient(to right, var(--green) 99.99%, var(--blue))\r\n    calc(-1 * var(--width)) 0rem \r\n    / 100% var(--line),\r\n    linear-gradient(to bottom, var(--green) 99.99%, var(--blue))\r\n    calc(var(--width) - var(--line)) calc(-1 * var(--height)) \r\n    / var(--line) 100%,\r\n    linear-gradient(to right, var(--green) 99.99%, var(--blue)) \r\n    var(--width) calc(var(--height) - var(--line)) \r\n    / 100% var(--line),\r\n    linear-gradient(to top, var(--green), 99.99%, var(--blue)) \r\n    0rem var(--height) \r\n    / var(--line) 100%;\r\n  background-repeat: no-repeat;\r\n  animation: progress var(--time) linear forwards infinite;\r\n}\r\n\r\n@keyframes progress {\r\n  0% {\r\n    background-position: \r\n      calc(-1 * var(--width)) 0rem,\r\n      calc(var(--width) - var(--line)) calc(-1 * var(--height)),\r\n      var(--width) calc(var(--height) - var(--line)), \r\n      0rem var(--height);\r\n  }\r\n  25% {\r\n    background-position: \r\n      0rem 0rem,\r\n      calc(var(--width) - var(--line)) calc(-1 * var(--height)),\r\n      var(--width) calc(var(--height) - var(--line)), \r\n      0rem var(--height);\r\n  }\r\n  50% {\r\n    background-position: \r\n      0rem 0rem, \r\n      calc(var(--width) - var(--line)) 0rem,\r\n      var(--width) calc(var(--height) - var(--line)), \r\n      0rem var(--height);\r\n  }\r\n  75% {\r\n    background-position: \r\n      0rem 0rem, \r\n      calc(var(--width) - var(--line)) 0rem,\r\n      0rem calc(var(--height) - var(--line)), \r\n      0rem var(--height);\r\n  }\r\n  100% {\r\n    background-position: \r\n      0rem 0rem, \r\n      calc(var(--width) - var(--line)) 0rem,\r\n      0rem calc(var(--height) - var(--line)), \r\n      0rem 0rem;\r\n  }\r\n}\r\n\n</code></pre>\n<h2>SVG 实现</h2>\n<p><code>svg</code>的实现则是hack了<code>stroke-dasharray</code>利用这个属性造出间断线来模拟倒计时，只要这个线足够长那么从视觉来看就是可以形成从全满变成全空的效果，这里的代码是这样的：</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"father\">\r\n  &#x3C;svg class=\"progressSvg\" style={{'--speed': speed, '--progress': progress}} viewBox=\"0 0 120 120\">\r\n    &#x3C;rect width=\"100\" height=\"100\" x=\"10\" y=\"10\" rx=\"10\" ry=\"10\" />\r\n  &#x3C;/svg>\r\n  &#x3C;span class=\"son\">{props.svg}&#x3C;/span>\r\n&#x3C;/div>\n</code></pre>\n<p>主要看rect部分，设置了一个圆角，所以矩形的起始位置设置成了<code>x=\"10\" y=\"10\"</code>，并且由于设置了矩形的尺寸，为了能放下，所以 <code>svg</code> 标签的 <code>viewBox=\"0 0 120 120\"</code> 从而放下这个圆角矩形。</p>\n<p>这样以来，矩形的周长就是 400，所以设置<code>stroke-dasharray</code> 只要大于 400 即可，为了保险设置成 1000长度的实线，1000长度的虚线。</p>\n<pre><code class=\"language-css\">.progressSvg rect {\r\n  fill: none;\r\n  stroke: blue;\r\n  stroke-width: 4; // 控制边框的宽度\r\n  /* \tstroke-linecap: round; */\r\n  stroke-dasharray: 1000 1000;\r\n  stroke-dashoffset: 0;\r\n  animation: spin 60s infinite linear;\r\n}\r\n\n</code></pre>\n<p>接着就是让它动起来，这里使用的是控制<code>stroke-offset</code>来控制，就从0（完全是边框）转到 -400（旋转了所有的边框），因为实线的前面是虚线，只要开始设置负的 <code>offset</code> 那么就会是类似于被吃掉的效果。</p>\n<pre><code class=\"language-css\">@keyframes spin {\r\n  to {\r\n    stroke-dashoffset: -400;\r\n  }\r\n}\n</code></pre>\n<p>这样我们就实现了最简单的二维码倒计时进度条了。<a href=\"https://codepen.io/alfxjx/pen/jOBPeqX?editors=0010\">在线演示 codepen.io</a></p>\n<h2>组件化 基于 React</h2>\n<p>样式基本不需要修改，修改一下js 文件，主要通过 css 变量来对倒计时时间，进度进行控制。</p>\n<p>这里根据需求：</p>\n<ol>\n<li>页面在加载的时候会给出过期时间，例如总共支付时间10分钟的话，当进度条走了 60% 之后，进度条颜色变成红色。</li>\n<li>根据给出的过期时间，页面刷新的时候，保持当前的进度。</li>\n</ol>\n<pre><code class=\"language-jsx\">const CountedDown = (props) => {\r\n  const [color, setColor] = React.useState(\"green\");\r\n  const [speed, setSpeed] = React.useState('100s');\r\n  const [progress] = React.useState('0.75');\r\n  return (\r\n    &#x3C;div>\r\n      &#x3C;div class=\"flex\" style={{ \"--bg\": color, \"--time\": speed }}>\r\n        &#x3C;div class=\"countdown\">\r\n          &#x3C;div class=\"progress\">\r\n            &#x3C;div class=\"inner\">\r\n              {props.css}\r\n            &#x3C;/div>\r\n          &#x3C;/div>\r\n        &#x3C;/div>\r\n      &#x3C;/div>\r\n      &#x3C;div class=\"father\">\r\n        &#x3C;svg class=\"progressSvg\" style={{'--speed': speed, '--progress': progress}} viewBox=\"0 0 120 120\">\r\n          &#x3C;rect width=\"100\" height=\"100\" x=\"10\" y=\"10\" rx=\"10\" ry=\"10\" />\r\n        &#x3C;/svg>\r\n        &#x3C;span class=\"son\">{props.svg}&#x3C;/span>\r\n      &#x3C;/div>\r\n    &#x3C;/div>\r\n  );\r\n}  \n</code></pre>\n<p>从上面的代码中，可以看出我们给 <code>css</code> 传入了 <code>--bg</code> 控制进度条的颜色，<code>--time</code>控制倒计时，读者可以自行查看在线演示代码。由于css版本的拐角存在问题，主要介绍svg版本。</p>\n<p>在 svg 版本中， 传入了 <code>--speed</code> 控制速度，<code>--progress</code>控制进度，对应的 css :</p>\n<pre><code class=\"language-css\">.progressSvg rect {\r\n  fill: none;\r\n  stroke: blue;\r\n  stroke-width: 4;\r\n  /* \tstroke-linecap: round; */\r\n  stroke-dasharray: 1000 1000;\r\n  - stroke-dashoffset: 0;\r\n  - animation: spin 60s infinite linear;\r\n  + stroke-dashoffset: calc((1 - var(--progress)) * (-400));\r\n  + animation: spin var(--speed) infinite linear;\r\n}\n</code></pre>\n<p><code>--speed</code>很好理解，主要解释<code>--progress</code>，上文中，我们知道使用动画就是让 <code>stroke-offset</code>按照逆时针旋转到 -400， 那么保存进度就是保存这个 offset 值，当我们认为现在的百分比进度是0.75的话，就需要提前 <strong>手动spin</strong> <code>(1-0.75)*(-400)</code> 。</p>\n<p>可以用于生产的 React 组件 可以参考下面的代码：</p>\n<pre><code class=\"language-css\">/* CountDown.module.css */\r\n.father {\r\n  position: relative;\r\n}\r\n.son {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  width: 12rem;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.progress {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n@keyframes spin {\r\n  to {\r\n    stroke-dashoffset: -400;\r\n  }\r\n}\r\n\r\n.progress rect {\r\n  fill: none;\r\n  stroke: var(--color);\r\n  stroke-width: 4;\r\n  /* \tstroke-linecap: round; */\r\n  stroke-dasharray: 1000 1000;\r\n  stroke-dashoffset: calc(-400 * var(--rate));\r\n  animation: spin 600s infinite linear;\r\n  /*   animation-direction: alternate; */\r\n}\n</code></pre>\n<pre><code class=\"language-tsx\">import React from 'react';\r\n\r\nimport styles from './CountDown.module.css';\r\n\r\ninterface MyCSSProperties extends React.CSSProperties {\r\n  '--color': string;\r\n  '--rate': string;\r\n}\r\n\r\nconst CountDown = ({\r\n  color,\r\n  timer,\r\n  children,\r\n}: {\r\n  color: string;\r\n  timer: number;\r\n  children: React.ReactNode;\r\n}) => {\r\n  const style: MyCSSProperties = {\r\n    // Add a CSS Custom Property\r\n    '--color': color,\r\n    '--rate': `${1 - timer / (600 * 1000)}`,\r\n  };\r\n\r\n  return (\r\n    &#x3C;div className={styles.father}>\r\n      &#x3C;svg className={styles.progress} viewBox=\"0 0 120 120\">\r\n        &#x3C;rect style={style} width=\"100\" height=\"100\" x=\"10\" y=\"10\" rx=\"6\" ry=\"6\" />\r\n      &#x3C;/svg>\r\n      &#x3C;span className={styles.son}>{children}&#x3C;/span>\r\n    &#x3C;/div>\r\n  );\r\n};\r\n\r\nexport { CountDown };\r\n\n</code></pre>\n<pre><code class=\"language-tsx\">/* usage */\r\nimport { useCountDown } from 'ahooks';\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nconst Index = ()=>{\r\n  const [barColor, setBarColor] = useState('blue'); // red\r\n  const [expiryTimer, setTargetDate, formattedRes] = useCountDown({\r\n    targetDate: dataRes.expiredAt,\r\n    onEnd,\r\n  });\r\n  useEffect(() => {\r\n    if (timer !== 0 &#x26;&#x26; timer &#x3C; 600 * 0.35 * 1000) {\r\n      setBarColor('red');\r\n    }\r\n  }, [expiryTimer]);\r\n  return (\r\n  &#x3C;CountDown color={barColor} timer={timer}>\r\n    &#x3C;div\r\n      className={classNames({\r\n        hidden: show,\r\n      })}\r\n      id=\"qrcode\"\r\n      ref={qrcodeRef}\r\n      />\r\n  &#x3C;/CountDown>\r\n  )\r\n}\n</code></pre>\n","coverImage":"/assets/blog/css-loading.png"}},"__N_SSG":true}